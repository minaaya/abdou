/* Instrumenting functions for quantify profiling	*/
/* Does not affect models behavior.					*/
static void 
olsr_rte_neighborhood_topology_check_hello (void)

	{
	FIN (olsr_rte_neighborhood_topology_check_hello());
	
	olsr_rte_neighborhood_topology_check ();
	
	FOUT;
	}

static void 
olsr_rte_neighborhood_topology_check_TC (void)
	{
	FIN (olsr_rte_neighborhood_topology_check_TC());
	
	olsr_rte_neighborhood_topology_check ();
	
	FOUT;
	}





//kkk
	
static void
olsr_rte_globals_init (void)
	{
	static int initialized = 0;

	/* Iniitalize once shared OLSR globals such as memory pools, global statistics, etc. */
	FIN (olsr_rte_globals_init);

	if (!initialized)
		{
		/* register global statistics */
		global_stat_handles.rte_traf_rcvd_bps_global_shandle = op_stat_reg ("OLSR.Routing Traffic Received (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.rte_traf_rcvd_pps_global_shandle = op_stat_reg ("OLSR.Routing Traffic Received (pkts/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.rte_traf_sent_bps_global_shandle = op_stat_reg ("OLSR.Routing Traffic Sent (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.rte_traf_sent_pps_global_shandle = op_stat_reg ("OLSR.Routing Traffic Sent (pkts/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.total_hello_sent_global_shandle = op_stat_reg ("OLSR.Total Hello Messages Sent", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.hello_traffic_sent_bps_global_handle = op_stat_reg ("OLSR.Hello Traffic Sent (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.total_tc_sent_global_shandle = op_stat_reg ("OLSR.Total TC Messages Sent", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.total_tc_forwarded_global_shandle = op_stat_reg ("OLSR.Total TC Messages Forwarded", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.tc_traffic_sent_bps_global_handle = op_stat_reg ("OLSR.TC Traffic Sent (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.mpr_count_global_shandle = op_stat_reg ("OLSR.MPR Count", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);	
		
		/* OLSR Performance Statistics */
		global_stat_handles.rte_table_calcs_global_shandle = op_stat_reg ("OLSR Performance.Route Table Calcs", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);	
		global_stat_handles.mpr_calcs_global_shandle = op_stat_reg ("OLSR Performance.MPR Calcs", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.nbr_add_global_shandle = op_stat_reg ("OLSR Performance.Total Nbr Additions", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.nbr_delete_global_shandle = op_stat_reg ("OLSR Performance.Total Nbr Deletions", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.two_hop_add_global_shandle = op_stat_reg ("OLSR Performance.Two Hop Nbr Additions", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.nbrhood_change_global_shandle = op_stat_reg ("OLSR Performance.Neighborhood Changes", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.topology_change_global_shandle = op_stat_reg ("OLSR Performance.Topology Changes", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.two_hop_reachability_add_global_shandle = op_stat_reg ("OLSR Performance.Two Hop Reachability Add", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
		global_stat_handles.two_hop_reachability_del_global_shandle = op_stat_reg ("OLSR Performance.Two Hop Reachability Delete", OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);

		/* initialize various memory pools */
		olsr_djk_state_pmoh = op_prg_pmo_define ("OLSR Dijkstra State", 
			sizeof (OlsrT_Djk_State), 100);
		noeud_state_pmoh = op_prg_pmo_define ("noud state", 
			sizeof (neoud_state), 100);
		
		olsr_djk_edge_state_pmoh = op_prg_pmo_define ("OLSR Dijkstra Edge State", 
		 	sizeof (OlsrT_Djk_Edge_State), 100);

		dup_entry_pmh = op_prg_pmo_define ("OLSR Duplicate Set Entry", 
			sizeof (OlsrT_Duplicate_Set_Entry), 32);

		rt_entry_pmh = op_prg_pmo_define ("OLSR Routing Table Entry",
			sizeof (OlsrT_Routing_Table_Entry), 32);

		mpr_set_entry_pmh = op_prg_pmo_define ("OLSR MPR Set Entry",
			sizeof (OlsrT_MPR_Set_Entry), 32);

		link_set_entry_pmh = op_prg_pmo_define ("OLSR Link Set Entry",
			sizeof (OlsrT_Link_Set_Entry), 32);

		mpr_selector_set_entry_pmh = op_prg_pmo_define ("OLSR MPR Selector Set Entry",
			sizeof (OlsrT_MPR_Selector_Set_Entry), 32);

		nbr_set_entry_pmh = op_prg_pmo_define ("OLSR Neighbor Set Entry",
			sizeof (OlsrT_Neighbor_Set_Entry), 32);

		nbr_addr_set_entry_pmh = op_prg_pmo_define ("OLSR Nbr Addr Two Hop Entry", 
			sizeof (OlsrT_Nbr_Addr_Two_Hop_Entry), 32);
		
		two_nbr_set_entry_pmh = op_prg_pmo_define ("OLSR Two Hop Nbr Set Entry", 
			sizeof (OlsrT_Two_Hop_Neighbor_Set_Entry), 32);

		tc_set_pmh = op_prg_pmo_define ("OLSR TC Set Entry",
			sizeof (OlsrT_TC_Set_Entry), 32);
		
		dest_entry_pmh = op_prg_pmo_define ("OLSR TC Dest Addr Entry",
			sizeof (OlsrT_TC_Dest_Addr_Entry), 32);
		
		mid_msg_pmh = op_prg_pmo_define ("OLSR MID Message",
			sizeof (OlsrT_MID_Message), 32);
		
		hello_msg_pmh = op_prg_pmo_define ("OLSR Hello Message",
			sizeof (OlsrT_Hello_Message), 64); /*parce que on a ajouter un champs pour int energie */
		
		hello_data_pmh = op_prg_pmo_define ("OLSR Hello Message Data",
			sizeof (OlsrT_Hello_Message_Data), 64);//////*************32******/////////////////////////////////////

		tc_msg_pmh = op_prg_pmo_define ("OLSR TC Message",
			sizeof (OlsrT_TC_Message), 32);

		olsr_msg_pmh = op_prg_pmo_define ("OLSR Message",
			sizeof (OlsrT_Message), 64);////////////***************32************////////////
		
        new_addr_pmh = op_prg_pmo_define ("OLSR Address",
			sizeof (int), 32);
		
        deferred_hello_info_pmh = prg_pmo_define_with_props ("Deferred OLSR HELLO info",
			sizeof (OlsrT_Rte_Deferred_Hello_Info), 32, PRGC_MEM_DONT_CLEAR);
		
		sdn_pmh = op_prg_pmo_define ("stablilte",
		sizeof (double), 32);

	/*	Msg_SDN_pmh = op_prg_pmo_define ("Message SDN",
			sizeof (Msg_SDN), 32);

		/* Register a namespace for OLSR Topology Graphs.	*/
		prg_graph_state_handler_register ("OLSR Topology Graph", 
			"OLSR Graph State", OPC_NIL, OPC_NIL);
		
		initialized = 1;
		}
	
	FOUT;
	}

static void
olsr_rte_sv_init (void)
	{
	Objid						own_module_objid;
	Objid						own_node_objid;
	Objid						udp_objid;
	List						proc_record_handle_list;
	int							record_handle_list_size;
	OmsT_Pr_Handle				process_record_handle;
	int							i,status, active_interfaces = 0;
	IpT_Interface_Info*			ith_intf_info_ptr;
	IpT_Phys_Interface_Info*	phys_intf_info_ptr;
	InetT_Address				inet_intf_addr;
	InetT_Address				inet_own_main_address;
	int							intf_addr, num_interfaces = 0;
	List*						intf_addr_lptr;
	int*						intf_addr_ptr;
	int							input_strm;
	IpT_Addr_Status				duplicate_status;
	
	OlsrT_Djk_State*			state_ptr;
	void*						old_entry = OPC_NIL;
	
	Boolean 					main_address_assigned = OPC_FALSE;

	/** Initialize the state variables	**/
	FIN (olsr_rte_sv_init (void));
	
	/* Obtain the process id of this module.*/
	own_module_objid = op_id_self ();

	/* Obtain the node ID of the node where this process resides.*/
	own_node_objid = op_topo_parent (own_module_objid);
	
	/* Obtain own process handle. */
	own_prohandle = op_pro_self ();
	
	my_process_id = op_pro_id (own_prohandle);
		
	/* Get IP Module data */
	module_data_ptr = ip_support_module_data_get (own_node_objid);
	
	/* Set up the display string. */
	sprintf (pid_string, "olsr_rte PID (%d)", op_pro_id (own_prohandle));

	/** Open UDP connection **/
	/* The following code is used to obtain the object id of the UDP	*/
	/* module used to transport OLSR packets over IP. Obtain the process*/
	/* record handle of neighboring udp process.						*/
	
	op_prg_list_init (&proc_record_handle_list);
	oms_pr_process_discover (own_module_objid, &proc_record_handle_list, 
							"protocol", 	OMSC_PR_STRING, 	"udp", 
							OPC_NIL);

	/* An error should be created if there are zero or more	*/
	/* than one	UDP process connected to the module.		*/
	record_handle_list_size = op_prg_list_size (&proc_record_handle_list);
	
	if (record_handle_list_size != 1)
		{
		/* Generate a simulation log message first and end simulation.	*/
		op_sim_end ("Error: Either zero or several udp processes connected to manet_dispatch.", "", "", "");
		}
	else
		{
		process_record_handle = (OmsT_Pr_Handle) op_prg_list_access (&proc_record_handle_list, OPC_LISTPOS_HEAD);
		
		/* Obtain the object id of the udp module.*/
		oms_pr_attr_get (process_record_handle, "module objid", OMSC_PR_OBJID, &udp_objid);
		
		/* Determine the input and output stream indices.				*/
		oms_tan_neighbor_streams_find (own_module_objid, udp_objid, &input_strm, &output_strm);
		}
	
	/* Deallocate the list pointer.*/
	while (op_prg_list_size (&proc_record_handle_list) > 0)
		op_prg_list_remove (&proc_record_handle_list, OPC_LISTPOS_HEAD);

	/* Read OLSR attributes. This must happen before  */
	/* the creation and initialization of the UDP ICI */
	olsr_rte_attributes_parse (own_module_objid);
	
	if(command_ici_ptr == OPC_NIL)
		{
		/* Create a receive port for this application.*/ 
		
		/* Issue the CREATE_PORT command. */
		command_ici_ptr = op_ici_create ("udp_command_inet");
		op_ici_attr_set_int32 (command_ici_ptr, "local_port", OLSRC_UDP_PORT);
		op_ici_attr_set (command_ici_ptr, "connection_class", CONNECTION_CLASS_1);
		op_ici_install (command_ici_ptr);
		op_intrpt_force_remote (UDPC_COMMAND_CREATE_PORT, udp_objid);
		}
	
	/* Get the status indication from the ici */
	op_ici_attr_get (command_ici_ptr, "status", &status); 
	
	/* Set the remote port and address in the UDP ici.		*/
	op_ici_attr_set_ptr (command_ici_ptr, "rem_addr", 
		(is_ipv6_enabled ? &InetI_Ipv6_All_Nodes_LL_Mcast_Addr: &InetI_Broadcast_v4_Addr));
	
	/* Setting the remote address in the UDP ici is sufficient  */
	/* to achieve broadcast, as needed in IPv4. However, in the */
	/* case of IPv6, the broadcast becomes multicast. For multi-*/
	/* cast to work, we need a setting into the "strm_index"    */
	/* field of the UDP ici - this setting will eventually be   */
	/* written into the "multicast_major_port" of the IP layer  */
	/* ICI. 													*/
	if (is_ipv6_enabled)
		op_ici_attr_set (command_ici_ptr, "strm_index", IPC_MCAST_ALL_MAJOR_PORTS); 
	
	op_ici_attr_set (command_ici_ptr, "rem_port", OLSRC_UDP_PORT);	

	/* Assign a unique name to this OLSR process.  It will include  */
    /* the name of the routing protocol, which in this case is OLSR */
    /* and the AS number of this process. Once the unique name is   */
    /* obtained, this process can be registered in IPs list of all  */
    /* routing processes.                                           */
    olsr_protocol_id = IP_CMN_RTE_TABLE_UNIQUE_ROUTE_PROTO_ID (IPC_DYN_RTE_OLSR, IPC_NO_MULTIPLE_PROC);
	
    Ip_Cmn_Rte_Table_Install_Routing_Proc (module_data_ptr->ip_route_table, olsr_protocol_id, own_prohandle);

    /* Create a /32 subnet mask for entries in the route table  */
    subnet_mask_32 = inet_smask_from_length_create (32);
	
	/* Create a /128 subnet mask for entries in the route table */
	subnet_mask_128 = inet_smask_from_length_create (128); 
	
	/* Create the tables */
	link_set_table = prg_bin_hash_table_create (4, sizeof (OlsrT_Link_Set_Key));
	neighbor_set_table = prg_bin_hash_table_create (4, 4);
	mpr_set_table = prg_bin_hash_table_create (4, 4);
	two_hop_nbr_set_table = prg_bin_hash_table_create (4, 4);
	mpr_selector_set_table = prg_bin_hash_table_create (4, 4);
	duplicate_set_table = prg_bin_hash_table_create (4, sizeof (OlsrT_Dup_Set_Key));

	tc_set_table = (PrgT_Bin_Hash_Table*) prg_bin_hash_table_create (4, 4);
	
	/* Bin hash table for OLSR rte table	 */
	olsr_routing_table = prg_bin_hash_table_create (4, 4);
		
	/* Create or get the handle for the OLSR TC Table */
	topo_table_hndl = oms_topo_table_create ("OLSR TC Table", olsr_rte_tc_dest_addr_entry_destroy);
	
	/* Initialize the state variables */
	pkt_seq_num = 0;
	msg_seq_num = 0;
	ANSN = 0;
	tc_entry_expiry_time = 5.0;
	neighborhood_changed = OPC_FALSE;
	selectorset_changed = OPC_FALSE;
	topology_changed = OPC_FALSE;
	send_empty_tc_time = 0.0;
	
	rte_calc_already_scheduled = OPC_FALSE;
	
	/* If this node has more than one interface, register it with the 	*/
	/* global interface set table as defined in olsr_support.ex.c 		*/
	/* Obtain the total number of active interfaces. 					*/
	/* Note: This is avoid MID messsage generation. MID messages help 	*/
	/* achieving interface to main addr mapping. Registering addresses	*/
	/* with global interface table is not in RFC						*/
	active_interfaces = inet_rte_num_interfaces_get (module_data_ptr);
 
	intf_addr_lptr = op_prg_list_create ();
	
	for (i=0; i< active_interfaces; i++)
		{
		/* Get the ith intf info ptr */
		ith_intf_info_ptr = inet_rte_intf_tbl_access (module_data_ptr, i);
			
		/* Check if this interface is not shutdown */
		phys_intf_info_ptr = ith_intf_info_ptr->phys_intf_info_ptr;
			
		if (phys_intf_info_ptr->intf_status != IpC_Intf_Status_Shutdown)
			{
			/* For IPv6, in addition to the physical interface not being */
			/* shutdown, we require the IPv6 interface to be active.     */
			/* If the interface is not active, just skip it. 			 */
			if (is_ipv6_enabled && (ip_rte_intf_ipv6_active (ith_intf_info_ptr) == OPC_FALSE))
				continue; 
			
			/* If this interface is not running OLSR, continue			*/
			if (ip_interface_routing_protocols_contains (ip_rte_intf_routing_prot_get (ith_intf_info_ptr), 
				IpC_Rte_Olsr) == OPC_FALSE)
				continue;
			
			/* If the main address has not yet been assigned, the first	*/
			/* OLSR interface we encounter is assigned the main address	*/
			if (!main_address_assigned)
				{
				inet_own_main_address = inet_rte_intf_addr_get (ith_intf_info_ptr, 
					(is_ipv6_enabled ? InetC_Addr_Family_v6:InetC_Addr_Family_v4));
				
				own_main_address = inet_rtab_unique_addr_convert (inet_own_main_address, &duplicate_status);
			if (op_prg_odb_ltrace_active ("mpr_trace"))
					printf ("-Own MA is %d", own_main_address);
				main_address_assigned = OPC_TRUE;
				
				/* Check for duplicate address */
				if (duplicate_status == IPC_ADDR_STATUS_DUPLICATE)
					{
					char   address_str [128]; 
					/* If the main address is a duplicate, we can't use it. */
					/* We could easily look for alternatives to the main    */
					/* address: for instance, in IPv6, there may be multiple*/
					/* IPv6 addresses on the iface, besides the duplicate   */
					/* address. We could therefore use one of the other     */
					/* addresses as the main address. 						*/
		
					/* Although we could find a non-duplicate main address  */
					/* in some cases, as a general policy we choose to just */
					/* ignore any duplicate addresses that arise in OLSR,   */
					/* without looking for alternatives in such cases when  */
					/* alternatives are available (e.g. when multiple IPv6  */
					/* addresses are defined on an interface, not all of    */
					/* which have duplicates in the network. 				*/

					/* If the main address could not be set to a non-dupli- */
					/* cate IP address, this OLSR process cannot continue   */
					/* to function. 									    */
					/* Tell the parent process to kill this OLSR child.     */
					/* The hash tables will be cleared in the termination   */
					/* block. The hello and TC timers will also be cleared  */
					/* in the termination block (if scheduled). 		    */
					op_intrpt_schedule_process (op_pro_parent (own_prohandle), op_sim_time(), IDLE_OLSR);
		
					if (LTRACE_ACTIVE)
						{
						op_prg_odb_print_major ("OLSR process will be killed, because its main address is a duplicate IP address", OPC_NIL); 
						}
		
					/* Notify the user via simulation log */
					inet_address_print (address_str, inet_own_main_address); 
					olsrnl_main_address_duplicate_log_write (address_str); 
		
					/* Destroy the inet_own_main_address to avoid a leak */
					inet_address_destroy (inet_own_main_address); 
		
					FOUT; 
					}
				}

			/* The interface address is gotten from the interface data  */
			/* structure. inet_rte_intf_addr_get() would accomplish the */
			/* task, but it will lead to a memory leak in case of IPv6  */
			/* addresses. When an InetT_Address holds an IPv6 address   */
			/* there is a pointer kept in the InetT_Address structure,  */
			/* that does not exist in the case of InetT_Address holding */
			/* an IPv4 address. The member "ipv6_addr_ptr" is meant to  */
			/* keep this IPv6 address pointer. Here in OLSR, we want to */
			/* avoid duplicating the memory pointed to by the IPv6 ptr  */
			/* in order to prevent a memory leak hazard. To that effect,*/
			/* we should use a version of inet_rte_intf_addr_get(), i.e.*/
			/* inet_rte_intf_addr_get_fast() that does not duplicate the*/
			/* memory pointed from the inner IPv6 address pointer. 		*/
			inet_intf_addr = inet_rte_intf_addr_get_fast (ith_intf_info_ptr, 
				(is_ipv6_enabled ? InetC_Addr_Family_v6:InetC_Addr_Family_v4));
			intf_addr = inet_rtab_unique_addr_convert (inet_intf_addr, &duplicate_status); 	
			
			/* Check for duplicate address */
			if (duplicate_status == IPC_ADDR_STATUS_DUPLICATE)
				{
				/* If this interface address has a duplicate somewhere */
				/* else in the network, we could seek to find an non-  */
				/* duplicate alternative. However, we choose not to    */
				/* follow this path, because this will lead to routing */
				/* tables being populated with non-duplicate addresses,*/
				/* that the applications running in the network will   */
				/* not use as destinations, because the applications   */
				/* do not have this intelligence to look beyond the    */
				/* first address configured on the interface. That is  */
				/* why there may be no benefit in our trying to do     */
				/* more work to recover from such IP misconfigurations */
				/* as duplicate addresses. In fact, IP itself should   */
				/* be responsible to solve the issue of duplicate      */
				/* addresses in a way that is transparent to the higher*/
				/* layers. Here in OLSR, we just take the simplest     */
				/* action to avoid the confusion due to a duplicate IP */
				/* address: simply ignore the interfaces on which such */
				/* address is configured. 						       */
				if (LTRACE_ACTIVE)
					{
					char  inet_address_str[64];
					char  tmp_str [256]; 
					
					inet_address_print (inet_address_str, inet_intf_addr); 
					sprintf (tmp_str, "Ignoring interface of duplicate address %s", inet_address_str); 
					op_prg_odb_print_major (tmp_str, OPC_NIL); 
					}
				
				continue; 
				}
			
			olsr_support_multiple_interface_register (intf_addr, (void*) &own_main_address, 1);
			 
			/* Create address and insert it in the intf_addr_lptr */
			intf_addr_ptr = olsr_rte_address_create (intf_addr);
			op_prg_list_insert (intf_addr_lptr, intf_addr_ptr, PRGC_LISTPOS_TAIL);
			
			/* We also need to register each active interface for */
			/* to join in the multicast group used for IPv6 OLSR  */
			/* to achieve the equivalent of IPv4 OLSR broadcast.  */
			/* Do this only if this is an IPv6 OLSR process.      */
			if (is_ipv6_enabled)
				{
				Inet_Address_Multicast_Register (InetI_Ipv6_All_Nodes_LL_Mcast_Addr, 
					i, OLSRC_UDP_PORT, module_data_ptr); 
				}
			
			num_interfaces++;
			}
		}
	
	if (num_interfaces > 1)
		{
		/* More than one interface is active on this node 						*/
		/* Add another entry in interface table indexed by main address 		*/
		/* This entry will contain the list of interfaces for this main addr 	*/
		olsr_support_multiple_interface_register (own_main_address, (void*) intf_addr_lptr, 2);
		}
	else if (num_interfaces == 1)
		{
		/* Only one address is active on this node 	*/
		/* Free the list of interface address		*/
		intf_addr_ptr = (int*) op_prg_list_remove (intf_addr_lptr, PRGC_LISTPOS_HEAD);
		op_prg_mem_free (intf_addr_ptr);
		op_prg_list_free (intf_addr_lptr);
		op_prg_mem_free (intf_addr_lptr);
		}
	else
		{
		/* There are no interfaces on this node */
		/* Free the list of interface addresses */
		op_prg_list_free (intf_addr_lptr); 
		op_prg_mem_free (intf_addr_lptr);

		/* Tell the parent process to kill this OLSR child.    */
		/* The hash tables will be cleared in the termination  */
		/* block. The hello and TC timers will also be cleared */
		/* in the termination block. 						   */
		op_intrpt_schedule_process (op_pro_parent (own_prohandle), op_sim_time(), IDLE_OLSR); 
		
		if (LTRACE_ACTIVE)
			{
			op_prg_odb_print_major ("OLSR process will be killed, because there are no active interfaces on this node", OPC_NIL); 
			}
		
		olsrnl_no_active_interfaces_log_write(); 
		}

	/* Set print proc for the OLSR control packets */
	op_pk_format_print_proc_set ("olsr", "Message", olsr_rte_olsr_message_print);
	
	/* Start the timer for periodic hellos & TC */
	/* Schedule the first hello & TC interrupt	*/
	hello_timer_evhandle = op_intrpt_schedule_self (op_sim_time () + op_dist_uniform (hello_interval), OLSRC_HELLO_TIMER_EXPIRY);
	tc_timer_evhandle = op_intrpt_schedule_self (op_sim_time () + op_dist_uniform (tc_interval), OLSRC_TC_TIMER_EXPIRY);
	
	if (LTRACE_ACTIVE)
		{
		printf("CREATED OLSR CHILD PROCESS, CONNECTED UDP, NOW WAITING...\n");
		}
	
	/* Clear the IP Cmn Rte Table 															*/
	/* IP table is no longer blindly cleared to preserve direct and static routes			*/
	/* Inet_Cmn_Rte_Table_Clear (module_data_ptr->ip_route_table, (is_ipv6_enabled ? InetC_Addr_Family_v6:InetC_Addr_Family_v4)); */
		
	/* Before exiting this function, we need to destroy */
	/* the memory allocated for pointers inside the     */
	/* the InetT_Address used to get the NATO index of  */
	/* the main OLSR address of this OLSR process.      */
	inet_address_destroy (inet_own_main_address); 
	
	/* Graph related initialization */
	/* Initializations for DJK graph */
			
	 /* Create the graph */
	 prg_graph_ptr = prg_graph_create ("OLSR Topology Graph");
	
	 /* If there was a problem creating the graph, return NIL.	*/
	if (prg_graph_ptr == PRGC_NIL)
		{
		op_sim_end ("Error in olsr_rte_graph_create", "Could not create graph",
			OPC_NIL, OPC_NIL);
		}
		 
	 /* Create hash table to store graph vertices 		 */
	 /* Keys to store graph vertices are their NATO index */
	 djk_hash_table_ptr = prg_bin_hash_table_create (4, 4);
		
	 /* create the root vertex */
	 root_vertex_ptr = prg_graph_vertex_insert (prg_graph_ptr);
				
	 /* Allocate memory for an OSPF DJK node.	*/
	 state_ptr = (OlsrT_Djk_State *) op_prg_pmo_alloc (olsr_djk_state_pmoh);
				
	 state_ptr->addr = own_main_address;
	 state_ptr->willingness = OLSRC_INVALID;
	 state_ptr->dist=0;
				
	 /* Set the client state on the vertex */
	 prg_vertex_client_state_set (root_vertex_ptr, OLSRC_DJK_STATE, (void *) state_ptr);
			
	 /* Insert this entry in hash table */
	 prg_bin_hash_table_item_insert (djk_hash_table_ptr, &own_main_address, root_vertex_ptr, &old_entry);
	 
	 last_rte_calc_time = 0;

	FOUT;
	}

static void
olsr_rte_local_stats_reg (void)
	{	
	/** Initializes the statistic handles	**/
	FIN (olsr_rte_local_stats_reg (void));
			
	/* Register each of the local statistic	*/
	local_stat_handles.rte_traf_rcvd_bps_shandle = op_stat_reg ("OLSR.Routing Traffic Received (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	local_stat_handles.rte_traf_rcvd_pps_shandle = op_stat_reg ("OLSR.Routing Traffic Received (pkts/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	local_stat_handles.rte_traf_sent_bps_shandle = op_stat_reg ("OLSR.Routing Traffic Sent (bits/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	local_stat_handles.rte_traf_sent_pps_shandle = op_stat_reg ("OLSR.Routing Traffic Sent (pkts/sec)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	local_stat_handles.total_hello_sent_shandle = op_stat_reg ("OLSR.Total Hello Messages Sent", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	local_stat_handles.total_tc_sent_shandle = op_stat_reg ("OLSR.Total TC Messages Sent", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	local_stat_handles.total_tc_forwarded_shandle = op_stat_reg ("OLSR.Total TC Messages Forwarded", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	local_stat_handles.mpr_status_shandle = op_stat_reg ("OLSR.MPR Status", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	
	FOUT;
	}
	
static void
olsr_rte_attributes_parse (Objid own_module_objid)
	{
	/* This function reads in the attributes for OLSR */
	Objid			olsr_parms_id;
	Objid			olsr_parms_child_id;
	int				status; 
	
	FIN (olsr_rte_attributes_parse (void));
	
	/* Read the OLSR Parameters	attribute */
	op_ima_obj_attr_get (own_module_objid, "OLSR Parameters", &olsr_parms_id);
	olsr_parms_child_id = op_topo_child (olsr_parms_id, OPC_OBJTYPE_GENERIC, 0);
	
	/* Read in the attributes	*/
	op_ima_obj_attr_get (olsr_parms_child_id, "Willingness", &node_willingness);
	op_ima_obj_attr_get (olsr_parms_child_id, "Hello Interval", &hello_interval);
	op_ima_obj_attr_get (olsr_parms_child_id, "TC Interval", &tc_interval);
	op_ima_obj_attr_get (olsr_parms_child_id, "Neighbor Hold Time", &neighbor_hold_time);
	op_ima_obj_attr_get (olsr_parms_child_id, "Topology Hold Time", &tc_hold_time);
	op_ima_obj_attr_get (olsr_parms_child_id, "Duplicate Message Hold Time", &dup_hold_time);
	op_ima_obj_attr_get(olsr_parms_child_id,"Intial Energy",&intial_energy);
	
	status = op_ima_obj_attr_get (olsr_parms_child_id, "Addressing Mode", &is_ipv6_enabled);

	if (op_ima_sim_attr_exists ("OLSR Hello Processing Time Quantum"))
		op_ima_sim_attr_get (OPC_IMA_DOUBLE, "OLSR Hello Processing Time Quantum", &hello_processing_time_quantum);
	else
		hello_processing_time_quantum = 0;
	
	if (op_ima_sim_attr_exists ("OLSR DJK Processing Time Quantum"))
		op_ima_sim_attr_get (OPC_IMA_DOUBLE, "OLSR DJK Processing Time Quantum", &djk_processing_time_quantum);
	else
		djk_processing_time_quantum = 0;
	
	if (status == OPC_COMPCODE_FAILURE)
		is_ipv6_enabled = OPC_FALSE; 
	
	
	FOUT;
	}


/*********************************************************************/
/******************** PACKET ARRIVAL FUNCTIONS ***********************/
/*********************************************************************/
static int
Packet_Zone (double puissance)
	{

	double zone1,zone2,zone3,zone4,zone5,zone6,zone7,zone8,zone9,zone10,zone11,zone12,zone13,zone14,zone15,zone16,zone17,zone18;
	double zone19,zone20,zone21,zone22,zone23,zone24,zone25,zone26,zone27,zone28,zone29,zone30;
	int 		zone;

	FIN ((<args>));
	
	zone1 = 0.000979643;		
	zone2 = 0.000244910;
	zone3 = 0.000108849;
	zone4 = 0.000061227;
	zone5 = 0.000039185;
	zone6 = 0.000027212;
	zone7 =	0.000019992;
	zone8 = 0.000015306;
	zone9 = 0.000012094;
	zone10= 0.0000097964;
	zone11 = 0.0000080962;		
	zone12 = 0.0000068030;
	zone13 = 0.0000057967;
	zone14 = 0.0000049981;
	zone15 = 0.0000043539;
	zone16 = 0.0000038267;
	zone17 = 0.0000033897;	
	zone18 = 0.0000030235;
	zone19 = 0.0000027136;
	zone20= 0.0000024491;
	zone21 = 0.0000022214;		
	zone22 = 0.000002024;
	zone23 = 0.0000018518;
	zone24 = 0.0000017007;
	zone25 = 0.0000015674;
	zone26 = 0.0000014491;
	zone27 = 0.0000013438;	
	zone28 = 0.0000012495;
	zone29 = 0.0000011648;
	zone30= 0.0000064855;
		
		
		
		
	
	zone = 100;
	
	if(puissance > zone1)
		{zone = 1;}
		else
			if(puissance > zone2)
				{zone = 2;}
				
				else
					if(puissance > zone3)
						{zone = 3;}
						
						else
							if(puissance > zone4)
								zone = 4;
								
								else
									if(puissance > zone5)
										zone = 5;
	
										else
											if(puissance > zone6)
												zone = 6;
												
												else
												if(puissance > zone7)
													zone = 7;
													
														else
														if(puissance > zone8)
															zone = 8;
															
															else
															if(puissance > zone9)
																zone = 9;
	
																else
																	if(puissance > zone10)
																		zone = 10;
																
	else
	if(puissance > zone11)
		{zone = 11;}
		else
			if(puissance > zone12)
				{zone = 12;}
				
				else
					if(puissance > zone13)
						{zone = 13;}
						
						else
							if(puissance > zone14)
								zone = 14;
								
								else
									if(puissance > zone15)
										zone = 15;
	
										else
											if(puissance > zone16)
												zone = 16;
												
												else
												if(puissance > zone17)
													zone = 17;
													
														else
														if(puissance > zone18)
															zone = 18;
															
															else
															if(puissance > zone19)
																zone = 19;
	
																else
																	if(puissance > zone20)
																		zone = 20;
	

	
	else
	if(puissance > zone21)
		{zone = 21;}
		else
			if(puissance > zone22)
				{zone = 22;}
				
				else
					if(puissance > zone23)
						{zone = 23;}
						
						else
							if(puissance > zone24)
								zone = 24;
								
								else
									if(puissance > zone25)
										zone = 25;
	
										else
											if(puissance > zone26)
												zone = 26;
												
												else
												if(puissance > zone27)
													zone = 27;
													
														else
														if(puissance > zone28)
															zone = 28;
															
															else
															if(puissance > zone29)
																zone = 29;
	
																else
																	if(puissance > zone30)
																		zone = 30;

	
	
	
	FRET (zone);
}




static void
olsr_rte_pkt_arrival_handle (void)
	{
	Packet*					pkptr;//olsrpacket
	


	Ici*					ici_ptr;
	Ici*					ara_ici;
	const OlsrT_Message*	olsr_message_ptr;
	InetT_Address*			inet_local_intf_addr_ptr;
	InetT_Address*			inet_ip_src_addr_ptr;
	Boolean					do_not_process = OPC_FALSE;
	InetT_Address			inet_local_intf_addr;
	InetT_Address			inet_ip_src_addr;
	IpT_Addr_Status			is_local_ip_duplicate; 
	IpT_Addr_Status  		is_remote_ip_duplicate; 
	int						local_intf_addr, ip_src_addr;
	int 					addr_num;
	OlsrT_Duplicate_Set_Entry* 	dup_set_entry_ptr;
	OlsrT_Neighbor_Set_Entry*	nbr_set_entry_ptr;
	
	/***************************************/
/*int 					arr_energy;
	/***************************************/

		
	/** Whenever a control packet arrives at the**/
	/** port where OLSR process is listening, 	**/
	/** this process is invoked					**/
	/** A packet has arrived. Handle the packet	**/
	/** appropriately based on its type			**/
	FIN (olsr_rte_pkt_arrival_handle (void));
	/*if(get_energy()< 500   )   {  FOUT ;}
	 update_energy() ;

	/* The process was invoked by the parent		*/
	/* MANET_RTE_MGR process indicating the arrival	*/
	/* of a packet.	The packet is OLSR control		*/
	/* packet. Process depeding upon the MESSAGE	*/
	/* type.										*/
	


	pkptr = (Packet*) op_pro_argmem_access ();
	      
	                                                                              //////////////////// recuperer la puisance du signal du packet ici///////////////////////////

/*****************************************************************/
    ara_ici=op_pk_ici_get(pkptr);
	op_ici_attr_get(ara_ici,"valeur_du_signal",&rcvd_power);

	//printf("%g alpha",signal_to_int(rcvd_power));
	


		
/*****************************************************************/
         
	/******************************/
	
	/*printf("Energy in Arrival : %d",update_energy());
	
	/******************************/
		
	/* Obtain the interface address and ip source address from the installed ICI.*/
	ici_ptr = op_intrpt_ici ();
	
	op_ici_attr_get (ici_ptr, "interface received", &inet_local_intf_addr_ptr);
	op_ici_attr_get (ici_ptr, "rem_addr", &inet_ip_src_addr_ptr);
	
	/* Currently, we support only one message	*/ 
	/* type in each OLSR control packet. 		*/
	
	/* Get the OLSR Message */
	op_pk_nfd_access_read_only_ptr (pkptr, "Message", (const void **) &olsr_message_ptr);

	if ((LTRACE_ACTIVE)||
		(op_prg_odb_ltrace_active ("trace_hello")== OPC_TRUE) ||
		(op_prg_odb_ltrace_active ("trace_tc")== OPC_TRUE))
		{
		if (olsr_message_ptr->message_type == OLSRC_HELLO_MESSAGE)
			op_prg_odb_print_major (pid_string, "\nReceived HELLO message \n", OPC_NIL);
		else if (olsr_message_ptr->message_type == OLSRC_TC_MESSAGE)
			op_prg_odb_print_major (pid_string, "\nReceived TC message \n", OPC_NIL);
		}
	
	/* Update the statistics for the routing traffic received	*/
	olsr_support_routing_traffic_received_stats_update (&local_stat_handles, &global_stat_handles, pkptr);
	
	/* Discard the packet if it carries an IP family different than */
	/* the IP family of this OLSR process (e.g. if the packet is    */
	/* OLSR IPv6, when this process is OLSR IPv4.) 					*/
	if (is_ipv6_enabled != olsr_message_ptr->is_ipv6)
		{
		op_pk_destroy (pkptr); 
		inet_address_destroy_dynamic (inet_local_intf_addr_ptr);
		inet_address_destroy_dynamic (inet_ip_src_addr_ptr);
		
		if ((LTRACE_ACTIVE)||
			(op_prg_odb_ltrace_active ("trace_hello")== OPC_TRUE) ||
			(op_prg_odb_ltrace_active ("trace_tc")== OPC_TRUE))
			{
			printf ("Received a packet of different IP address family. Destroy it \n");
			}
		
		FOUT; 
		}
	
	/* Discard the packet if its a loopback i.e. i received my own packet */
	/* Discard the packet if TTL has reached zero */
	if (olsr_message_ptr->originator_addr == own_main_address)
		{
		op_pk_destroy (pkptr);
		inet_address_destroy_dynamic (inet_local_intf_addr_ptr);
		inet_address_destroy_dynamic (inet_ip_src_addr_ptr);
		
		if ((LTRACE_ACTIVE)||
			(op_prg_odb_ltrace_active ("trace_hello")== OPC_TRUE) ||
			(op_prg_odb_ltrace_active ("trace_tc")== OPC_TRUE))
			{
			printf ("Received my own packet. Destroy it \n");
			}

		FOUT;
		}
		
	if (olsr_message_ptr->ttl == 0)
		{
		op_pk_destroy (pkptr);
		inet_address_destroy_dynamic (inet_local_intf_addr_ptr);
		inet_address_destroy_dynamic (inet_ip_src_addr_ptr);
		
		if ((LTRACE_ACTIVE)||
			(op_prg_odb_ltrace_active ("trace_hello")== OPC_TRUE) ||
			(op_prg_odb_ltrace_active ("trace_tc")== OPC_TRUE))
			{
			printf ("TTL reached zero. Destroy it \n");
			}

		FOUT;
		}

	if (olsr_message_ptr->message_type == OLSRC_HELLO_MESSAGE)
		{
		

		
		
		
		
		/* Defer hello packets processing if appropriate */
		if (hello_processing_time_quantum > 0)
			{
			/*  Insert information about this HELLO at the end of the chain */
			OlsrT_Rte_Deferred_Hello_Info * info_ptr = (OlsrT_Rte_Deferred_Hello_Info *)
				op_prg_pmo_alloc (deferred_hello_info_pmh);

			info_ptr->pkptr = pkptr;
			info_ptr->olsr_message_ptr = olsr_message_ptr;
			info_ptr->inet_local_intf_addr_ptr = inet_local_intf_addr_ptr;
			info_ptr->inet_ip_src_addr_ptr = inet_ip_src_addr_ptr;

			info_ptr->next_ptr = NULL;
			if (hello_processing_deferred_tail_ptr)
				{
				hello_processing_deferred_tail_ptr->next_ptr = info_ptr;
				hello_processing_deferred_tail_ptr = info_ptr;
				}
			else
				{
				hello_processing_deferred_tail_ptr = hello_processing_deferred_head_ptr = info_ptr;

				/* this also implies that interrupt to process hellos is not yet scheduled */
				/* (computation interrupts evenly spaced in simulation time domain to allow better chances of parallel processing) */
				op_intrpt_schedule_self (ceil (op_sim_time () / hello_processing_time_quantum) * hello_processing_time_quantum,
					OLSRC_HELLO_PROCESSING_TIMER_EXPIRY);
				}
			}
		else
			{
			olsr_rte_process_hello_pk (pkptr, olsr_message_ptr, inet_local_intf_addr_ptr, inet_ip_src_addr_ptr);
			
			/* Check if either neighborhood or topology has changed (after processing all hellos) */
			olsr_rte_neighborhood_topology_check_hello ();
			}
		FOUT;
		}
	
	/* Check if this packet has been processed earlier 	*/
	/* Get the duplicate set entry, it it exists 		*/
	{
	OlsrT_Dup_Set_Key	key;
	key.originator_addr = olsr_message_ptr->originator_addr;
	key.message_seq_num = olsr_message_ptr->message_seq_num;
	dup_set_entry_ptr = (OlsrT_Duplicate_Set_Entry*)
		prg_bin_hash_table_item_get (duplicate_set_table, &key);
	}
	
	if (dup_set_entry_ptr != OPC_NIL)
		do_not_process = OPC_TRUE;
	
	/* Get the InetT_Address from pointers */
	inet_local_intf_addr = *inet_local_intf_addr_ptr;
	inet_ip_src_addr = *inet_ip_src_addr_ptr;
				
	/* Convert this InetT_Address to NATO index */
    local_intf_addr = inet_rtab_unique_addr_convert (inet_local_intf_addr, &is_local_ip_duplicate);
    ip_src_addr = inet_rtab_unique_addr_convert (inet_ip_src_addr, &is_remote_ip_duplicate);
			
	/* If this Hello packet has the source or destination IP as duplicate */
	/* addresses, do not process the packet. It will be discarded.  By    */
	/* ignoring such hello packets, we are preventing link set entries    */
	/* with duplicate addresses from entering OLSR. This is not specified */
	/* by the RFC, it is part of this OLSR implementation protection      */
	/* against misconfiguration. 										  */
	if ((is_local_ip_duplicate == IPC_ADDR_STATUS_DUPLICATE) || 
		(is_remote_ip_duplicate == IPC_ADDR_STATUS_DUPLICATE))
		{
		op_pk_destroy (pkptr);
		
		if ((LTRACE_ACTIVE)||
			(op_prg_odb_ltrace_active ("trace_hello")== OPC_TRUE) ||
			(op_prg_odb_ltrace_active ("trace_tc")== OPC_TRUE))
			{
			printf ("Check network for duplicate IP addresses. Destroying the packet\n");
			}
		
		/* Free the memory occupied by these addresses in the ICI */
		inet_address_destroy_dynamic (inet_local_intf_addr_ptr);
		inet_address_destroy_dynamic (inet_ip_src_addr_ptr);
		
		FOUT;
		}
	
	/* This packet was not processed before */
	if (do_not_process == OPC_FALSE)
		{
		/* Process the message according to msg_type (which can only be TC here -- HELLO processed above) */
		
		//////////////////////TC received//////////////////////////////
		switch (olsr_message_ptr->message_type)
			{
			case (OLSRC_TC_MESSAGE):
				{
				Boolean			discard_tc;
				

				
				if (LTRACE_ACTIVE ||(op_prg_odb_ltrace_active ("trace_tc")== OPC_TRUE))
					{
					char			tmp_str [256];
					char			node_name [256];
					InetT_Address	inet_tmp_addr;

					inet_address_print (tmp_str, inet_ip_src_addr);
					inet_address_to_hname (inet_ip_src_addr, node_name);
					printf ("Processing TC received from: %s (%s)\n", tmp_str, node_name);
				
					inet_tmp_addr = inet_rtab_index_to_addr_convert (olsr_message_ptr->originator_addr);
					inet_address_print (tmp_str, inet_tmp_addr);
					inet_address_to_hname (inet_tmp_addr, node_name);
					printf ("TC originator address %s (%s)\n", tmp_str, node_name);
					}
				
				/* Process the  TC message	*/
				discard_tc = olsr_rte_process_TC (olsr_message_ptr, ip_src_addr);
				
				/* Check if either neighborhood or topology has changed */
				olsr_rte_neighborhood_topology_check_TC ();
	
				/* This TC is to be discarded 	*/
				/* It can be due to : 			*/
				/* 1. Heard from Non-Sym nbr	*/
				/* 2. Out of order TC mesg		*/
				if (discard_tc == OPC_TRUE)
					{
					if ((op_prg_odb_ltrace_active ("trace_tc")== OPC_TRUE))
						{
						op_prg_odb_print_minor ("Discarding this TC \n", OPC_NIL);
						}
					
					/* This TC message will not be considered for */
					/* forwarding. Hence, destroy this TC packet  */
					op_pk_destroy (pkptr);
					
					/* Free the memory occupied by these addresses in the ICI */
					inet_address_destroy_dynamic (inet_local_intf_addr_ptr);
					inet_address_destroy_dynamic (inet_ip_src_addr_ptr);
					
					/* Exit the function */
					FOUT;
					}
			
				break;
				}
			
			default:
				{
				/* Invalid message type */
				olsr_rte_error ("Invalid Message Type in OLSR packet", OPC_NIL, OPC_NIL);
				}
			}
		}/*end if do_not_process*/
	else
		{
		/* This else part just prints tracing information. 					*/
		/* Only TC messages add duplicate set entries, hence for HELLO msg, */
		/* do_not_process will never be True. We'll reach here when this 	*/
		/* TC message was already processed. Now consider it for forwarding.*/
		/* Do not destroy this packet yet as forwarding condition needs to	*/
		/* be checked.														*/
		if ((LTRACE_ACTIVE)||
			(op_prg_odb_ltrace_active ("trace_hello")== OPC_TRUE) ||
			(op_prg_odb_ltrace_active ("trace_tc")== OPC_TRUE))
			{
			printf ("Message has already been processed (or it involves duplicate IP addresses). Do not process\n");
			}
		}
		
	/* Reached here either after processing the TC msg, 	*/
	/* or the TC msg was already processed					*/
	/* In either case, check if we need to forward this pkt	*/
	/* Note: We'll not reach here when Hello is received	*/
	
	/* Execute default forwarding algorithm for this TC */
	if (op_prg_odb_ltrace_active ("trace_tc"))
		{
		op_prg_odb_print_minor ("Checking forwarding conditions\n", OPC_NIL);
		}
		
	addr_num = olsr_support_main_addr_get (ip_src_addr);
	nbr_set_entry_ptr = (OlsrT_Neighbor_Set_Entry*) prg_bin_hash_table_item_get (neighbor_set_table, &addr_num);
	//
	/*****************************************************************/
/*if(nbr_set_entry_ptr!=OPC_NIL)
	{	nbr_set_entry_ptr->val_signal.nbr_msg_recevu++;
		  nbr_set_entry_ptr->val_signal.val_signal[nbr_set_entry_ptr->val_signal.nbr_msg_recevu++]=rcvd_power;
	Olsr_Valeur_du_Signal(&nbr_set_entry_ptr,3);
	printf("\n\n\n\n am the freen table %d\n",nbr_set_entry_ptr->nbr_addr);

	nbr_set_entry_ptr->val_signal.nbr_msg_recevu++;
	}*/
	
	/* If this was already processed TC, we need */
	/* to check if it is received from SYM NBR   */
	if ((do_not_process == OPC_TRUE) && 
		((nbr_set_entry_ptr == OPC_NIL) ||
		(nbr_set_entry_ptr->status != OLSRC_SYM_STATUS)))
		{
		/* Discard this packet as the sender is not 1-hop sym nbr */
		if (op_prg_odb_ltrace_active ("trace_tc"))
			op_prg_odb_print_minor ("TC not recvd by 1-hop SYM nbr, Discarding TC while forwarding\n", OPC_NIL);
		
		/* No further processing of this TC message	*/
		op_pk_destroy (pkptr);
		
		/* Free the memory occupied by these addresses in the ICI */
		inet_address_destroy_dynamic (inet_local_intf_addr_ptr);
		inet_address_destroy_dynamic (inet_ip_src_addr_ptr);
			
		/* Exit the function */
		FOUT;
		}
		
	/* Check if this TC was already forwarded */
	if ((dup_set_entry_ptr != OPC_NIL) && 
		(dup_set_entry_ptr->rexmitted == OPC_TRUE))
		{
		/* This TC has already been considered for forwarding */
		if (op_prg_odb_ltrace_active ("trace_tc"))
			op_prg_odb_print_minor ("This TC has already been considered for forwarding, Discarding TC \n", OPC_NIL);
					
		/* Discard the packet */
		op_pk_destroy (pkptr);
		
		/* Free the memory occupied by these addresses in the ICI */
		inet_address_destroy_dynamic (inet_local_intf_addr_ptr);
		inet_address_destroy_dynamic (inet_ip_src_addr_ptr);
		
		/* Exit the function */
		FOUT;
		}
	else
		{
		/* Either no duplicate entry exists or this TC was not fwded*/
		/* Candidate for forwarding, check if the condition matches */
		/* Check if the source address is in my MPR selector list 	*/

		/* Packet forwarding will require a change to the structure (ttl--) */
		/* Thus we need to re-obtain an olsr message field which is modifiable  */
		OlsrT_Message*	mod_olsr_message_ptr;
		op_pk_nfd_access (pkptr, "Message", &mod_olsr_message_ptr);
		/* Update the const message ptr too */
		olsr_message_ptr = mod_olsr_message_ptr;
		
		if (olsr_rte_forward_packet (mod_olsr_message_ptr, ip_src_addr) == OPC_TRUE)
			{
			if (op_prg_odb_ltrace_active ("trace_tc"))
					op_prg_odb_print_minor ("Forwarding (Re-broadcasting) this TC message \n", OPC_NIL);
			
			/* Add entry in dup table set */
			olsr_rte_duplicate_set_entry_add 
				(olsr_message_ptr->originator_addr,olsr_message_ptr->message_seq_num, OPC_TRUE);
	
			/* Update the number of TC messages forwarded statistic	*/
			op_stat_write (local_stat_handles.total_tc_forwarded_shandle, 1.0);
			op_stat_write (global_stat_handles.total_tc_forwarded_global_shandle, 1.0);
				
			/* Update the tc traffic sent in bits per second	*/
			op_stat_write (global_stat_handles.tc_traffic_sent_bps_global_handle, op_pk_total_size_get (pkptr));
			op_stat_write (global_stat_handles.tc_traffic_sent_bps_global_handle, 0.0);
				
			/* Forward this TC Message */
			olsr_rte_pkt_send (pkptr, (is_ipv6_enabled? InetI_Ipv6_All_Nodes_LL_Mcast_Addr: InetI_Broadcast_v4_Addr), OPC_TRUE);
			
			/* Free the memory occupied by these addresses in the ICI */
			inet_address_destroy_dynamic (inet_local_intf_addr_ptr);
			inet_address_destroy_dynamic (inet_ip_src_addr_ptr);
			}
		else
			{
			/* Forwarding conditions did not match */
			if (op_prg_odb_ltrace_active ("trace_tc"))
				op_prg_odb_print_minor ("The node is not an MPR to forward this TC, Discarding TC \n", OPC_NIL);
				
			/* Update the duplicate set entry for this TC */
			olsr_rte_duplicate_set_entry_add (olsr_message_ptr->originator_addr,
													olsr_message_ptr->message_seq_num, OPC_FALSE);
			op_pk_destroy (pkptr);
			
			/* Free the memory occupied by these addresses in the ICI */
			inet_address_destroy_dynamic (inet_local_intf_addr_ptr);
			inet_address_destroy_dynamic (inet_ip_src_addr_ptr);
			}
		}
	
	

		//olsr_rte_tc_set_print_to_string ();	
	//olsr_rte_routing_table_print_to_string();///////////////////////////routing
			

	FOUT;
	}


/****************************************/
/***** Packet Process Functions *********/
/****************************************/
static void
olsr_hello_processing_expiry_handle (void)
	{
	OlsrT_Rte_Deferred_Hello_Info * info_ptr;
	
	/* process all pending hello packets */
	FIN (olsr_hello_processing_expiry_handle);

	/* decouple current list of pending hellos from the chain */
	info_ptr = hello_processing_deferred_head_ptr;
	hello_processing_deferred_head_ptr = hello_processing_deferred_tail_ptr = NULL;
	while (info_ptr)
		{
		OlsrT_Rte_Deferred_Hello_Info * ref_ptr = info_ptr;
		olsr_rte_process_hello_pk (info_ptr->pkptr, info_ptr->olsr_message_ptr,
			info_ptr->inet_local_intf_addr_ptr, info_ptr->inet_ip_src_addr_ptr);
		info_ptr = info_ptr->next_ptr;
		op_prg_mem_free (ref_ptr);
		}
	
	/* Check if either neighborhood or topology has changed (after processing all hellos) */
	olsr_rte_neighborhood_topology_check_hello ();
	
	FOUT;
	}

static void
olsr_rte_process_hello_pk (Packet * pkptr, const OlsrT_Message * olsr_message_ptr,
	InetT_Address * inet_local_intf_addr_ptr, InetT_Address * inet_ip_src_addr_ptr)
	{
	int				local_intf_addr, ip_src_addr;
	InetT_Address	inet_local_intf_addr;
	InetT_Address	inet_ip_src_addr;
	IpT_Addr_Status	is_local_ip_duplicate; 
	IpT_Addr_Status	is_remote_ip_duplicate;
	
	/* Validate & process single hello packet */
	/* Also dealocate all memory associated with that request */
	FIN (olsr_rte_process_hello_pk);

	inet_local_intf_addr = *inet_local_intf_addr_ptr;
	inet_ip_src_addr = *inet_ip_src_addr_ptr;
	
	/* Convert this InetT_Address to NATO index */
    local_intf_addr = inet_rtab_unique_addr_convert (inet_local_intf_addr, &is_local_ip_duplicate);
    ip_src_addr = inet_rtab_unique_addr_convert (inet_ip_src_addr, &is_remote_ip_duplicate);
	
	/* If this Hello packet has the source or destination IP as duplicate */
	/* addresses, do not process the packet. It will be discarded.  By    */
	/* ignoring such hello packets, we are preventing link set entries    */
	/* with duplicate addresses from entering OLSR. This is not specified */
	/* by the RFC, it is part of this OLSR implementation protection      */
	/* against misconfiguration. 										  */
	if ((is_local_ip_duplicate == IPC_ADDR_STATUS_DUPLICATE) || 
		(is_remote_ip_duplicate == IPC_ADDR_STATUS_DUPLICATE))
		{
		op_pk_destroy (pkptr);
		
		/* Free the memory occupied by these addresses in the ICI */
		inet_address_destroy_dynamic (inet_local_intf_addr_ptr);
		inet_address_destroy_dynamic (inet_ip_src_addr_ptr);
		
		if ((LTRACE_ACTIVE)||
			(op_prg_odb_ltrace_active ("trace_hello")== OPC_TRUE) ||
			(op_prg_odb_ltrace_active ("trace_tc")== OPC_TRUE))
			{
			op_prg_odb_print_minor ("Check network for duplicate IP addresses. Destroying the packet\n", OPC_NIL);
			}
		
		FOUT;
		}
	
	if (LTRACE_ACTIVE ||(op_prg_odb_ltrace_active ("trace_hello")== OPC_TRUE))
		{
		char	tmp_str [256];
		
		inet_address_print (tmp_str, inet_ip_src_addr);
		printf ("Processing HELLO received from: %s ", tmp_str);
		inet_address_to_hname (inet_ip_src_addr, tmp_str);
		printf ("(%s)\n", tmp_str);
		}
				
	/* Process the Hello Message	*/
	olsr_rte_process_hello (olsr_message_ptr, ip_src_addr, local_intf_addr);
	
	/* Free the memory occupied by these addresses in the ICI */
	inet_address_destroy_dynamic (inet_local_intf_addr_ptr);
	inet_address_destroy_dynamic (inet_ip_src_addr_ptr);

	/* Hello message is not considered for forwarding */
	/* Hence, destroy the message after processing 	  */
	op_pk_destroy (pkptr);
	
	FOUT;
	}

		
static void
olsr_rte_process_hello (const OlsrT_Message* olsr_message_ptr, int ip_src_addr, int local_intf_addr)
	{
	/* Processes hello message received */
	/* Updates link set, neigbor set, 	*/
	/* 2hop neighbor set, mpr set etc.	*/
	int									originator_addr;
	int									message_size, ttl, hop_count, message_seq_num;
	int									vtime, htime, willingness;
	OlsrT_Hello_Message*				hello_msg_ptr;
	PrgT_Vector*						hello_msg_data_vptr;
	OlsrT_Link_Set_Entry*				link_set_entry_ptr;

	OlsrT_Neighbor_Set_Entry*			ara;
//	int									max;
//int                                 i;
	int					                nbr_msg_recevu;
	int neighbor_rec_energy ;
	FIN (olsr_rte_process_hello (OlsrT_Message*, int, int));

	/* Get information from the olsr message header */
	originator_addr = olsr_message_ptr->originator_addr;
	message_size = olsr_message_ptr->message_size;
	message_seq_num = olsr_message_ptr->message_seq_num;
	vtime = olsr_message_ptr->vtime;
	ttl = olsr_message_ptr->ttl;
	hop_count = olsr_message_ptr->hop_count;
	
	/* Get the hello message from olsr_msg */
	hello_msg_ptr = (OlsrT_Hello_Message*) olsr_message_ptr->message;
	
	/* Get information from hello message */
	htime = hello_msg_ptr->htime;

	willingness = hello_msg_ptr->willingness;
	
	//////////*recupirer l'energie du noued voisin a parrtir le message hello *////////////////	
	
	neighbor_rec_energy =hello_msg_ptr->res_energy;
	energy_voisin = neighbor_rec_energy ;
	
	
	//printf("lenergy recu du voision est  =  %d", energy_voisin);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	
	/* Get the list of hello msg data with different linkcodes */
	hello_msg_data_vptr = (PrgT_Vector*) hello_msg_ptr->hello_msg_vptr;
	
	/* First update link set and neigbor set from the	*/
	/* ip_src_addr and originator addr info	in this		*/
	/* hello message									*/
	/* Note: ip_src_addr can be different from 			*/
	/* originitor address, as hello is sent per 		*/
	/* interface										*/
	
	if ((link_set_entry_ptr = olsr_rte_link_set_entry_get (ip_src_addr, local_intf_addr)) == OPC_NIL)
		{
		OlsrT_Neighbor_Set_Entry*			neighbor_set_entry_ptr;
		
		/* New link, no entry exist in routing table	*/
		/* Create a new entry							*/
		link_set_entry_ptr = olsr_rte_link_set_entry_create (local_intf_addr, ip_src_addr,
			op_sim_time() -1, op_sim_time() + vtime, op_sim_time() + vtime);
		
		if ((op_prg_odb_ltrace_active ("trace_hello") == OPC_TRUE))
			{
			InetT_Address	inet_tmp_addr;
			char			tmp_str [256], node_name [256];
			
			inet_tmp_addr = inet_rtab_index_to_addr_convert (ip_src_addr);
			inet_address_print (tmp_str, inet_tmp_addr);
			inet_address_to_hname (inet_tmp_addr, node_name);
			printf ("Adding %s (%s) as new link entry\n", tmp_str, node_name);
			}
		
		/* Add neighbor if the originator_addr is not 	*/
		/* listed as one of the neigbor in nbr table	*/
		if ((neighbor_set_entry_ptr = (OlsrT_Neighbor_Set_Entry*) 
			olsr_rte_neighbor_set_entry_get (originator_addr)) == OPC_NIL)
			{
			if ((op_prg_odb_ltrace_active ("trace_hello") == OPC_TRUE))
				{
				InetT_Address	inet_tmp_addr;
				char			tmp_str [256], node_name [256];
				
				inet_tmp_addr = inet_rtab_index_to_addr_convert (originator_addr);
				inet_address_print (tmp_str, inet_tmp_addr);
				inet_address_to_hname (inet_tmp_addr, node_name);
				printf ("Adding %s (%s) as new neighbor\n", tmp_str, node_name);
				}
			
			/* New neighbor, create an entry */
			neighbor_set_entry_ptr = olsr_rte_neighbor_set_entry_create 
				(originator_addr, OLSRC_NOT_SYM_STATUS, willingness,energy_voisin);   /*new entry*/
			
			}
	
		
		/* In either case, added new neigbhor or neighbor already existed */
		/* increament the link_entries for this neighbor as its a new link */
		neighbor_set_entry_ptr->link_entry_count++;
		
		neighbor_set_entry_ptr->energie=neighbor_rec_energy;  /////  add the energie to the setentry...
		
		/* Add the neighbor_entry_ptr to the link set entry */
		link_set_entry_ptr->nbr_entry_ptr = neighbor_set_entry_ptr;
		}
	else 
		{
		/* This link entry already exists. Update the ASYM_time */
		link_set_entry_ptr->ASYM_time = op_sim_time () + vtime;
		
		/* expiry_time = max (expiry_time, ASYM_time) */
		if (link_set_entry_ptr->expiry_time < link_set_entry_ptr->ASYM_time)
			link_set_entry_ptr->expiry_time = link_set_entry_ptr->ASYM_time;
		}
	
	
	
	/* Now check if there are any hello message data in this hello mesg */
	/* hello_msg_data_vptr contains the list of hello msg data listed 	*/
	/* by linkcode. Each hello msg data has list of interfaces with 	*/
	/* corresponding linkcode. It is possible that hello message is 	*/
	/* empty and there is no interface address information present		*/
	if (hello_msg_data_vptr != OPC_NIL)
		{
		int							found_myself_linkcode;
		int							hello_msg_data_num;
		OlsrT_Neighbor_Set_Entry*	neighbor_set_entry_ptr;
		
		/* There are hello message data in this hello message 	*/
		/* Get the number of these hello msg data 				*/
		hello_msg_data_num = prg_vector_size (hello_msg_data_vptr);
		
		/* If i find my own address in the list of intf addresses in hello mesg */
		/* function will return the linkcode, else it will return -99			*/
		found_myself_linkcode = olsr_rte_find_myself_in_hello_msg (hello_msg_data_vptr, local_intf_addr);

		/* Update the SYM_time and expiry_time for link set  	*/
		/* and Neighbor Status in Nbr Set depending upon the	*/
		/* condition if we find ourself in the list of addresses*/
		/* in hello msg											*/
		if (found_myself_linkcode != OLSRC_ADDR_NOT_FOUND)
			{
			int				link_type, nbr_type;
			
			/* We found our address in the hello msg, Get the 	*/
			/* link type and nbr_type from this linkcode 		*/
			olsr_rte_breakup_linkcode (found_myself_linkcode, &link_type, &nbr_type);
			
			if ((op_prg_odb_ltrace_active ("trace_hello") == OPC_TRUE))
				{
				printf ("Found my interface address in this hello message\n");
				}
			
			switch (link_type)
				{
				case (OLSRC_LOST_LINK):
					{
					/* If this link was symmetric and we have just lost it */
					if (link_set_entry_ptr->SYM_time > op_sim_time ())
						{
						/* Cancel the previosuly scheduled interrupt for this entry */
						op_ev_cancel_if_pending (link_set_entry_ptr->sym_time_expiry_evhandle);
					
						/* Call olsr_rte_symmetric_link_expiry_handle */
						olsr_rte_symmetric_link_expiry_handle (link_set_entry_ptr, OLSRC_CONN_LOSS_TIMER);
						}
					
					/* This link is advertised as broken, make it ASYM */
					link_set_entry_ptr->SYM_time = op_sim_time () - 1;
					
					break;
					}
				case (OLSRC_SYMMETRIC_LINK):
				case (OLSRC_ASYMMETRIC_LINK):
					{
					/* First check if this link was already symmetric or not */
					if (link_set_entry_ptr->SYM_time < op_sim_time ())
						{
						/* This link was asymmetric, now it is going to become symmetric*/
						/* We would have handled the interrupt when this expired		*/
						/* We should schedule a fresh interrupt for this entry 			*/
						
						/* Increament the sym_link_entry_count */
						neighbor_set_entry_ptr = (OlsrT_Neighbor_Set_Entry*) link_set_entry_ptr->nbr_entry_ptr;
						neighbor_set_entry_ptr->sym_link_entry_count++;
						}
					else
						{
						/* This link was already symmetric, we are just refreshing it 	*/
						/* Cancel the previously scheduled event if its pending	and   	*/
						/* schedule a new interrupt for the new time.					*/
						op_ev_cancel_if_pending (link_set_entry_ptr->sym_time_expiry_evhandle);
						}
								
					/* Update the SYM time */
					link_set_entry_ptr->SYM_time = op_sim_time () + vtime;
					link_set_entry_ptr->expiry_time = link_set_entry_ptr->SYM_time + neighbor_hold_time;
					
					/* Schedule the interrupt for sym link expiry */
					link_set_entry_ptr->sym_time_expiry_evhandle = op_intrpt_schedule_call (link_set_entry_ptr->SYM_time, 
						OLSRC_SYM_LINK_EXPIRY,	olsr_rte_symmetric_link_expiry_handle, link_set_entry_ptr);
										
					break;
					}
				default:
					break;
				} /*end switch*/
			
			/* Check if i have been selected as MPR, If yes, 	*/
			/* add the source of Hello msg in my selector set 	*/
			if (nbr_type == OLSRC_MPR_NEIGHBOR)
				{
				if ((op_prg_odb_ltrace_active ("trace_hello") == OPC_TRUE))
					{
					InetT_Address	inet_tmp_addr;
					char			tmp_str [256], node_name [256];
					
					inet_tmp_addr = inet_rtab_index_to_addr_convert (originator_addr);
					inet_address_print (tmp_str, inet_tmp_addr);
					inet_address_to_hname (inet_tmp_addr, node_name);
					printf ("MPR Selector entry added for %s (%s)-", tmp_str, node_name);
					}
				olsr_rte_mpr_selector_set_entry_create (originator_addr, vtime);
				}
			}
		
		/* expiry_time = max (expiry_time, ASYM_time) */
		if (link_set_entry_ptr->expiry_time < link_set_entry_ptr->ASYM_time)
			link_set_entry_ptr->expiry_time = link_set_entry_ptr->ASYM_time;
		
		/* Check all the interfaces of this neighbor, if any of them */
		/* has SYM_time > current_time, set neighbor status as SYM */
		neighbor_set_entry_ptr = olsr_rte_set_neighbor_status (originator_addr, link_set_entry_ptr);
		
		/* Now we will parse through each interface address */
		/* listed in hello msg and update the 2hop_nbr set 	*/
		
		/* Process only, if this hello was received from a symmetric neighbor */
		if ((neighbor_set_entry_ptr->status == OLSRC_SYM_STATUS))
			{
			int		i;
			
			for (i=0; i < hello_msg_data_num; i++)
				{
				int				j;
				int				linkcode;
				int				link_type, nbr_type;
				int				intf_addr_num;
				PrgT_Vector*	intf_addr_vptr;
				PrgT_Vector*	intf_SDN_vptr;
				
				//int				intf_SDN_num;
				
				/* For each hello msg data, Get hello msg data */
				OlsrT_Hello_Message_Data	*hello_msg_data_ptr =
					(OlsrT_Hello_Message_Data*) prg_vector_access (hello_msg_data_vptr, i);
		
				/* Get the linkcode for this hello msg data */
				linkcode = hello_msg_data_ptr->linkcode;
				
				/* Get link_type and nbr_type */
				olsr_rte_breakup_linkcode (linkcode, &link_type, &nbr_type);
						
				/* Get list of interface address in the data */
				intf_addr_vptr = (PrgT_Vector*) hello_msg_data_ptr->nbr_intf_addr_vptr;
				intf_SDN_vptr  = (PrgT_Vector*) hello_msg_data_ptr->nbr_intf_SDN_vptr;
		
				/* Get the number of interface address */
				intf_addr_num = prg_vector_size (intf_addr_vptr);
				
				
				
				/*
				intf_SDN_num = prg_vector_size (intf_addr_vptr);
				
				olsr_rte_neighbor_set_print_to_string();
				printf("\n\n\nSoltan,number @=%d and nimber of SDN= %d",intf_addr_num,intf_SDN_num);
				print_addr(own_main_address);
				print_addr(neighbor_set_entry_ptr->nbr_addr);
				
				
				
				
				for (j=0; j < intf_SDN_num; j++)
				
{				double * intf_SDN_ptr=(double*) prg_vector_access (intf_SDN_vptr, j);
				int * intf_addr_ptr = (int*) prg_vector_access (intf_addr_vptr, j);
				int	two_hop_nbr_addr = olsr_support_main_addr_get (*intf_addr_ptr);	
				
				printf("\n %g    ",*intf_SDN_ptr);
					print_addr(two_hop_nbr_addr);
					
					}
				*/
		
				for (j=0; j < intf_addr_num; j++)
					{
					
					//OlsrT_Two_Hop_Neighbor_Set_Entry *	ar;
					
					/* For each of the interface address listed in this hello msg data */
					int * intf_addr_ptr = (int*) prg_vector_access (intf_addr_vptr, j);
					
					double * intf_SDN_ptr=(double*) prg_vector_access (intf_SDN_vptr, j);/******************************************/
					
					/* Get the main addr of this interface */
					int	two_hop_nbr_addr = olsr_support_main_addr_get (*intf_addr_ptr);
					double intf_SDN=*intf_SDN_ptr;
					//printf("\n\n\n\n intf_sdn == %g",intf_SDN);
					
					
				
					
					/* Update 2-hop neighbor set */
					if ((nbr_type == OLSRC_SYM_NEIGHBOR) || (nbr_type == OLSRC_MPR_NEIGHBOR))
						{
						/* Do not add to two hop nbr if the interface addr belongs to	*/
						/* me i.e. my main addr = neighbor main addr. 					*/
						if (own_main_address != two_hop_nbr_addr)
							{
							/* Not my interface, Create a 2hop_set entry */
							olsr_rte_two_hop_nbr_set_entry_create (two_hop_nbr_addr, originator_addr,intf_SDN, vtime);
								
		
							 
							
							
								/* Get the entry for this nbr_addr	
								ar = (OlsrT_Two_Hop_Neighbor_Set_Entry*) 
										prg_bin_hash_table_item_get (two_hop_nbr_set_table, &(two_hop_nbr_addr));
		
								
	if (ar != OPC_NIL)
		{OlsrT_Nbr_Addr_Two_Hop_Entry*   n;
		
		n = (OlsrT_Nbr_Addr_Two_Hop_Entry*)
			prg_bin_hash_table_item_get (ar->neighbor_hash_ptr, &originator_addr);

		if (n)
			
			//nbr_addr_entry_ptr->SDN=SDN;
	printf("\n ben ara souti %g",n->SDN);else{printf("\nKanb");}
		}
	else{printf("\n ara souti second");}*/
							}
						}

					if (nbr_type == OLSRC_NOT_NEIGHBOR)
						{
						/* This two hop neighbor cannot be reached through  	*/
						/* given orig addr anymore, update two hop neighbor set */
						olsr_rte_two_hop_nbr_set_entry_match_n_delete (two_hop_nbr_addr, originator_addr);
						
						}
					}
				}
			} /* end this hello msg was recvd from sym nbr */
		} /* close if-else: (hello_msg_ptr != OPC_NIL)*/
	
/*	ara=(OlsrT_Neighbor_Set_Entry*) olsr_rte_neighbor_set_entry_get (originator_addr);
	
	printf("\n\n\n\n****************************\n\n")	;
	printf("The Neighbor %d recevu %d Message(s) Hello",ara,ara->val_signal.nbr_msg_recevu++);
	
	
	max=((ara->val_signal.nbr_msg_recevu>=50)?ara->val_signal.nbr_msg_recevu%50:ara->val_signal.nbr_msg_recevu);

	printf("\nN		Valeur");	
	for(i=0;i<max;i++)
	{
	printf("\n%d        %g",i,ara->val_signal.val_signal[max]);
	}
	
	ara->val_signal.val_signal[max]=rcvd_power;
//	printf("\non this case je recevu  %f et %g",ara->val_signal.val_signal[max],rcvd_power);
	ara->val_signal.nbr_msg_recevu++;
	//	printf("\n\n\n\n****************************\n\n")	;
*/

// ara->val_signal.val_signal[max]=rcvd_power;
   ara=(OlsrT_Neighbor_Set_Entry*) olsr_rte_neighbor_set_entry_get (originator_addr);
   nbr_msg_recevu=1;

  
   ara->val_signal.val_signal[ara->val_signal.nbr_msg_recevu]=rcvd_power;
	printf("\n Indice %d val_signal %g ",ara->val_signal.nbr_msg_recevu,(ara->val_signal.val_signal[ara->val_signal.nbr_msg_recevu]));
    //ara->val_signal.temps1 = op_sim_time();
	ara->val_signal.temps2 = op_sim_time();
	
   ara->val_signal.nbr_msg_recevu++;
	Olsr_calculer_stablilte(originator_addr,rcvd_power);
	FOUT;
		
	}

static Boolean
olsr_rte_process_TC (const OlsrT_Message* olsr_message_ptr, int ip_src_addr) /*********************************tc process***************************/
	{
	/* Process the received TC message 		*/
	/* Returns TRUE if this tc message is 	*/
	/* out of order and should be discarded	*/
	/* Else, returns FALSE					*/
			
	OlsrT_TC_Message*			tc_msg_ptr = OPC_NIL;
	int							rcvd_seq_num, message_size, message_seq_num;
	int							vtime, ttl, hop_count;
	void*						old_contents_ptr;
	OlsrT_TC_Set_Entry*			tc_set_entry_ptr = OPC_NIL;
	OlsrT_TC_Dest_Addr_Entry*	dest_addr_entry_ptr = OPC_NIL;
	void*						state_ptr = OPC_NIL;
	int							num_mpr_selectors;
	Boolean						entry_found = OPC_FALSE;
	char						tmp_str [256], node_name [256];
	InetT_Address				inet_tmp_addr;
	Boolean						tmp_var;
	int							originator_addr;
	OlsrT_Neighbor_Set_Entry*	nbr_set_entry_ptr = OPC_NIL;
	PrgT_Vector*                intf_SDN_vptr;
	int                         intf_addr_num;
	PrgT_Vector*                intf_addr_vptr;
	
	
	int               addr_num,j;	

	FIN ( olsr_rte_process_TC (OlsrT_Message*, int));

	/* Get information from the olsr message header */
	originator_addr = olsr_message_ptr->originator_addr;
	message_size = olsr_message_ptr->message_size;
	message_seq_num = olsr_message_ptr->message_seq_num;
	vtime = olsr_message_ptr->vtime;
	ttl = olsr_message_ptr->ttl;
	hop_count = olsr_message_ptr->hop_count;
	
	/* Lazy method: Delete expired entries from TC table */
	olsr_rte_expired_tc_entries_remove ();

	/* Check if this TC packet was received from a symmetric 1 hop nbr */
	addr_num = olsr_support_main_addr_get (ip_src_addr);
	nbr_set_entry_ptr = (OlsrT_Neighbor_Set_Entry*) 
		prg_bin_hash_table_item_get (neighbor_set_table, &addr_num);
	
	if ((nbr_set_entry_ptr == OPC_NIL) ||
		(nbr_set_entry_ptr->status != OLSRC_SYM_STATUS))
		{
		/* Discard this packet as the sender is not 1-hop sym nbr 	*/
		/* Return OPC_TRUE, so that it is destroyed. 				*/
		/* No further processing of this TC message					*/
		if (op_prg_odb_ltrace_active ("trace_tc"))
			{
			printf ("Discarding TC not recvd by SYM 1 hop nbr\n");
			}
		
		/* Add this in duplicate set, so that this msg is not 		*/
		/* considered for processing or forwarding again.			*/
		olsr_rte_duplicate_set_entry_add
				(olsr_message_ptr->originator_addr, olsr_message_ptr->message_seq_num, OPC_TRUE);
					
		FRET (OPC_TRUE);
		}
	
	/* Get the tc message from olsr_msg */
	tc_msg_ptr = (OlsrT_TC_Message*) olsr_message_ptr->message;
	rcvd_seq_num = tc_msg_ptr->tc_seq_num;
	//////////////////////////////////////////////////////////////////////////////////////////////
	  
	   intf_addr_vptr = (PrgT_Vector*) tc_msg_ptr->mpr_nodes_vptr;
	   intf_SDN_vptr  = (PrgT_Vector*) tc_msg_ptr->mpr_nodes_SDN_vptr;
		
				/* Get the number of interface address */
				intf_addr_num = prg_vector_size (intf_addr_vptr);
				for (j=0; j < intf_addr_num; j++)
					{
					
		
					
					double * intf_SDN_ptr=(double*) prg_vector_access (intf_SDN_vptr, j);
					
					/* Get the SDN  of this interface */
					
					double intf_SDN=*intf_SDN_ptr;
					
					//printf("\n\n\n\n la fonction de stabilite est %g",intf_SDN);
					
	
	
					}
	
	
	
	///////////////////////////////////////////////////////////////////////////////////////////////
	
	/* Originator address is the last_addr field in TC table 	*/
	/* TC entries are indexed with last_addr field				*/
	if ((tc_set_entry_ptr = (OlsrT_TC_Set_Entry*) 
		prg_bin_hash_table_item_get (tc_set_table, &originator_addr)) != OPC_NIL)
		{
		/* An entry for this originator address exists in TC msg 		*/
		/* We are going to compare current seq num with rcvd seq num	*/
		
		if (op_prg_odb_ltrace_active ("trace_tc"))
			{
			inet_tmp_addr = inet_rtab_index_to_addr_convert (originator_addr);
			inet_address_print (tmp_str, inet_tmp_addr);
			inet_address_to_hname (inet_tmp_addr, node_name);
			printf ("Entry for last_addr: %s (%s) found in TC table\n", tmp_str, node_name);
			}
		
	
		/* Check for out-of-order TC */
		if (tc_set_entry_ptr->tc_seq_num > rcvd_seq_num)
			{
			if (op_prg_odb_ltrace_active ("trace_tc"))
				{
				printf ("Discarding OUT OF ORDER TC, Curr Seq No:%d, TC seq no:%d\n",
								tc_set_entry_ptr->tc_seq_num , rcvd_seq_num);
				}
			
			/* This is an out of order TC message, discard this TC  */
			/* Return OPC_TRUE, so that it is destroyed. 			*/
			/* No further processing of this TC message				*/
			
			/* Add the entry in duplicate set table. We don't want	*/
			/* to process it again nor consider for it for fwding 	*/
			olsr_rte_duplicate_set_entry_add
				(olsr_message_ptr->originator_addr, olsr_message_ptr->message_seq_num, OPC_TRUE);
			
			FRET (OPC_TRUE);
			}
		
		if (tc_set_entry_ptr->tc_seq_num < rcvd_seq_num)
			{
			/* Delete old entries that have Seq number smaller than the recevied TC */
			
			if (op_prg_odb_ltrace_active ("trace_tc"))
				{
				printf ("Deleting elements with smaller Seq Num: Old Seq No:%d, TC Seq No:%d\n",
					tc_set_entry_ptr->tc_seq_num ,rcvd_seq_num);
				}
	

			olsr_rte_graph_tc_delete (tc_set_entry_ptr);

			/* Remove this entry from common TC Table */
			tmp_var = oms_topo_table_item_remove (topo_table_hndl, 
				originator_addr, tc_set_entry_ptr->tc_seq_num);
			
			/* Reset the state_ptr */
			tc_set_entry_ptr->state_ptr = OPC_NIL;
			
			/* Set topology set changed */
			topology_changed = OPC_TRUE;
			}
	
		/* Get the list of MPR addresses listed in the TC message */
		num_mpr_selectors = prg_vector_size (tc_msg_ptr->mpr_nodes_vptr);
		
		/* There are no addresses in this TC message 		*/
		/* Since we found the entry for this originator		*/
		/* address, the entry for old seq number must have	*/
		/* been removed from  common TC Table. Remove the 	*/
		/* hash table entry from local tc set table also 	*/
		if (num_mpr_selectors == 0)
			{
			if (op_prg_odb_ltrace_active ("trace_tc"))
				{
				printf ("No MPR selector addresses in this TC mesg, deleting the hash table entry\n");
				}
			/* Delete the hash table entry */
			prg_bin_hash_table_item_remove (tc_set_table, &originator_addr);
			op_prg_mem_free (tc_set_entry_ptr);
			}
		else
			{
			/* There are addresses in TC message */
			/* Check if seq numbers are same for this existing entry */
			if (tc_set_entry_ptr->tc_seq_num == rcvd_seq_num)
				{
				if (op_prg_odb_ltrace_active ("trace_tc"))
					{
					printf ("Found last_addr/seq_num entry. Updating expiry time\n");
					}
				/* Entry for last addr and dest addr exists */
				/* Update the expiry time */
				tc_set_entry_ptr->tc_time = op_sim_time () + vtime;
				entry_found = OPC_TRUE;
				}
			
			if (entry_found == OPC_FALSE)
				{
				/* No entry for this seq num though entry for orig addr exists 	*/
				/* Add it to this entry 										*/
				tc_set_entry_ptr->last_addr = originator_addr;
				tc_set_entry_ptr->tc_seq_num = rcvd_seq_num;
				tc_set_entry_ptr->tc_time = op_sim_time () + vtime;
				
				/* Check if such entry exists in common TC table */
				if (oms_topo_table_item_exists (topo_table_hndl, originator_addr, rcvd_seq_num, &state_ptr) == OPC_TRUE)
					{
					/* An entry to TC exists in common TC table 		*/
					/* State_ptr will have the refrence to that entry 	*/
					tc_set_entry_ptr->state_ptr = (OlsrT_TC_Dest_Addr_Entry*) state_ptr;
					oms_topo_table_item_insert (topo_table_hndl, originator_addr, rcvd_seq_num, state_ptr);
					}
				else
					{
					if (op_prg_odb_ltrace_active ("trace_tc"))
						{
						printf ("Creating new entry in OLSR TC Table \n");
						}
					
					/* Create a  new entry  */
					dest_addr_entry_ptr = olsr_rte_tc_dest_addr_entry_create (tc_msg_ptr->mpr_nodes_vptr, rcvd_seq_num,tc_msg_ptr->mpr_nodes_SDN_vptr);
					
					/* Add it to the common TC table */
					oms_topo_table_item_insert (topo_table_hndl, originator_addr, rcvd_seq_num, (void*) dest_addr_entry_ptr);
					
					tc_set_entry_ptr->state_ptr = dest_addr_entry_ptr;
					}
		
				olsr_rte_graph_tc_add (tc_set_entry_ptr);
		
				/* Set topology set changed */
				topology_changed = OPC_TRUE;
				
				} /* end if entry_found == OPC_FALSE*/
			
			}/*end else-if num_mpr_selectors == 0*/
				
		}/*end if*/
	else
		{
		/* Entry for this orginiator addr = last_addr 	*/
		/* is not found in TC table 					*/
		/* Before creating an entry first check if 		*/
		/* there are any addresses in the TC mesg 		*/
		/* If not, do not create a new TC entry 		*/
		num_mpr_selectors = prg_vector_size (tc_msg_ptr->mpr_nodes_vptr);
		
		if (num_mpr_selectors != 0)
			{
			/* MPR addresses are there in this TC msg */
			
			/* Create a new entry in TC table */
			tc_set_entry_ptr = (OlsrT_TC_Set_Entry*) op_prg_pmo_alloc (tc_set_pmh);
			
			/* New information */
			/* Add it to this entry */
			tc_set_entry_ptr->last_addr = originator_addr;
			tc_set_entry_ptr->tc_seq_num = rcvd_seq_num;
			tc_set_entry_ptr->tc_time = op_sim_time () + vtime;
		
			if (op_prg_odb_ltrace_active ("trace_tc"))
				{
				inet_tmp_addr = inet_rtab_index_to_addr_convert (originator_addr);
				inet_address_print (tmp_str, inet_tmp_addr);
				inet_address_to_hname (inet_tmp_addr, node_name);
				printf ("Creating New TC Entry: last_addr: %s (%s) and seq no:%d \n", tmp_str, node_name, rcvd_seq_num);
				}
		
			/* Check if such entry exists in common TC table */
			if (oms_topo_table_item_exists (topo_table_hndl, originator_addr, rcvd_seq_num, &state_ptr) == OPC_TRUE)
				{
				if (op_prg_odb_ltrace_active ("trace_tc"))
					{
					printf ("Entry already exists in OLSR TC Table\n");
					}
					
				/* State_ptr will have the refrence to that entry */
				tc_set_entry_ptr->state_ptr = (OlsrT_TC_Dest_Addr_Entry*) state_ptr;
				oms_topo_table_item_insert (topo_table_hndl, originator_addr, rcvd_seq_num, state_ptr);
				
				}
			else
				{
				if (op_prg_odb_ltrace_active ("trace_tc"))
					{
					printf ("Creating a new entry in OLSR TC Table\n");
					}
				
				/* Create a  new one */
				dest_addr_entry_ptr = olsr_rte_tc_dest_addr_entry_create (tc_msg_ptr->mpr_nodes_vptr, rcvd_seq_num,tc_msg_ptr->mpr_nodes_SDN_vptr);//////////////////////////Ajouter SDN a la liste de destnation////////////
					
				/* Add it to the common TC table */
				oms_topo_table_item_insert (topo_table_hndl, originator_addr, rcvd_seq_num, (void*) dest_addr_entry_ptr);
					
				tc_set_entry_ptr->state_ptr = dest_addr_entry_ptr;
				}
			
			prg_bin_hash_table_item_insert (tc_set_table, &originator_addr, tc_set_entry_ptr, &old_contents_ptr);
			
			/* Set topology set changed */
			topology_changed = OPC_TRUE;

			olsr_rte_graph_tc_add (tc_set_entry_ptr);
			
			}
		}
	
	
	
	/*
					
					inet_tmp_addr = inet_rtab_index_to_addr_convert (own_main_address);
					inet_address_print (tmp_str, inet_tmp_addr);
	
/*printf("the vertix node %s \n",tmp_str);*/
	//olsr_rte_neighbor_set_print_to_string();
	//printf("\n I am the noeud %d",own_main_address);
	//print_addr(own_main_address);
//olsr_rte_tc_set_print_to_string(); /* afficher table de topologie*/
	
	/* Return false, so that this TC msg */
	/* can be considered for forwarding  */
	FRET (OPC_FALSE);
	
	}
		
		

/*************************************/
/***** Packet Send Functions *********/
/*************************************/

static void
olsr_rte_send_hello (Boolean send_jittered)
	{
	OlsrT_Hello_Message*		hello_msg_ptr;
	int							olsr_hello_message_size;
	int							originator_addr;
	OlsrT_Message*				olsr_msg_ptr;
	Packet*						olsr_pkptr;
	/*************************************/
	/*int                         send_energy;
	/*************************************/
	FIN (olsr_rte_send_hello (Boolean));
  
	if(get_energy()< 1000   )   { FOUT ;} 


	/*******************************************************************************************************/
	
    update_energy();
	/*printf("Energy in SEND of HELLO = %d \n",get_energy());
	

	
	/*******************************************************************************************************/
	
	
	
	
	/* Lazy Method: Remove expired link set entries */
	olsr_rte_expired_link_set_entries_remove ();
	
	/* Allocate memory for OlsrT_Hello_Message */
	hello_msg_ptr = (OlsrT_Hello_Message*) op_prg_pmo_alloc (hello_msg_pmh);
	
	/* Model the size of the fields in OlsrT_Hello_Message 	 */
	/* Reserved (16) + Htime (8) + Willingness (8) + energie (32)= 64	bits */
	olsr_hello_message_size = 64;
	
	originator_addr = own_main_address;

	/* see if link set is not empty */
	if (link_set_chain_head_ptr)
		{
		PrgT_Vector*				nbr_intf_addr_vptr;
		PrgT_Vector*				hello_msg_vptr;
		
		PrgT_Vector*				nbr_intf_SDN_vptr;
		
		
		OlsrT_Link_Set_Entry*		link_set_entry_ptr;
		int							prev_linkcode = 15; /* not possible */
		
		/* Since the set is not zero, we will send a hello message 	*/
		/* with atleast one set linkcode with corresponding list 	*/
		/* of intf address list										*/
		
		/* Create vector (list) to hold all hello msg data (i.e. list of linkcodes) */
		hello_msg_vptr = prg_vector_create (1, OPC_NIL, OPC_NIL);
		
		/* Model the size of the fields in OlsrT_Hello_Message_Data	  */
		/* Linkcode (8) + Reserved (8) + Link Msg Size (16) = 32 bits */
		olsr_hello_message_size += 32;

		/* Go through each entry of the link set	*/
		/* and add the interface info in hello msg 	*/
		for (link_set_entry_ptr = link_set_chain_head_ptr;
			 link_set_entry_ptr;
			 link_set_entry_ptr = link_set_entry_ptr->next_link_set_entry_ptr)
			{
			int 						link_type, neighbor_type;
			int							nbr_intf_addr;
			int							neighbor_main_addr;
			int							linkcode;
			
			
			OlsrT_Hello_Message_Data*	prev_hello_msg_data_ptr;
			
			if (link_set_entry_ptr->SYM_time > op_sim_time())
				{
				/* This link is still symmetric */
				link_type = OLSRC_SYMMETRIC_LINK;
				}
			else if (link_set_entry_ptr->ASYM_time > op_sim_time())
				{
				/* Link type is assymetric */
				link_type = OLSRC_ASYMMETRIC_LINK;
				}
			else if ((link_set_entry_ptr->ASYM_time < op_sim_time()) &&
					(link_set_entry_ptr->SYM_time < op_sim_time()))
				{
				/* This link is lost */
				link_type = OLSRC_LOST_LINK;
				}
		
			/* Check this same neighbor's status in neighbor table 	*/
			/* Note: intf address are used only for link sensing	*/
			/* For all other tables, main address of node is used	*/
			
			/* Get the nbr_intf_address */
			nbr_intf_addr = link_set_entry_ptr->key.nbr_intf_addr;
			
			/* Get the neighbor main addr for this interface addr, use MID table	*/
			neighbor_main_addr = olsr_support_main_addr_get (nbr_intf_addr);
			
			/* If this neighbor is found in MPR set */
			if (olsr_rte_mpr_set_entry_get (neighbor_main_addr) != OPC_NIL)
				{
				neighbor_type = OLSRC_MPR_NEIGHBOR;
				}
			else
				{
				/* Find the entry in neigbor table */
				OlsrT_Neighbor_Set_Entry* neighbor_set_entry_ptr =
					olsr_rte_neighbor_set_entry_get (neighbor_main_addr);
		
				if (neighbor_set_entry_ptr->status == OLSRC_SYM_STATUS)
					{
					neighbor_type = OLSRC_SYM_NEIGHBOR;
					}
				else if (neighbor_set_entry_ptr->status == OLSRC_NOT_SYM_STATUS)
					{
					neighbor_type = OLSRC_NOT_NEIGHBOR;
					}
				}
		
			/* Left shift link_type 2 bit places */
			link_type <<=2;
		
			/* OR it with neighbor_type to obtain linkcode */
			/* Set linkcode in hello_message_data */
			linkcode = link_type | neighbor_type;
			
			prev_hello_msg_data_ptr = olsr_rte_hello_msg_data_linkcode_exists 
														(hello_msg_vptr, linkcode);
			
			if ((linkcode != prev_linkcode) && (prev_hello_msg_data_ptr == OPC_NIL))
				{
				int*						nbr_intf_addr_ptr;
				double*						nbr_intf_SDN_ptr;
//				void*						ara;
				OlsrT_Neighbor_Set_Entry* 	ptr = OPC_NIL;
				
				
				/* Different linkcode than previous one & no such linkcode created previously */
	
				/* Create a new hello msg data for this */
				/* new linkcode type list of interfaces */
				OlsrT_Hello_Message_Data	*hello_msg_data_ptr =
					(OlsrT_Hello_Message_Data*) op_prg_pmo_alloc (hello_data_pmh);
				
				/* Model the size of the fields in OlsrT_Hello_Message_Data	  */
				/* Linkcode (8) + Reserved (8) + Link Msg Size (16) = 32 bits */
				olsr_hello_message_size += 32; 
							
				nbr_intf_addr_vptr = prg_vector_create (1, OPC_NIL, OPC_NIL);
				nbr_intf_SDN_vptr= prg_vector_create (1, OPC_NIL, OPC_NIL);/**********************************************/
				
				hello_msg_data_ptr->nbr_intf_addr_vptr = nbr_intf_addr_vptr;
				
				
				
				hello_msg_data_ptr->nbr_intf_SDN_vptr = nbr_intf_SDN_vptr;/*********************************************/
			
				/* Create inet address pointer to insert in the vector */
				nbr_intf_addr_ptr = olsr_rte_address_create (nbr_intf_addr);
				nbr_intf_SDN_ptr=get_SDN( nbr_intf_addr);
				
				
		
		
	
			
	


/*			prg_bin_hash_table_item_get (neighbor_set_table, &nbr_intf_addr);
				if(ptr==OPC_NIL)printf("\n  rah neel");

		
printf("\n%g the valeur ",ptr->stabilite.SDN);
				
				nbr_intf_SDN_ptr=olsr_rte_sdn_create( ptr->stabilite.SDN);
				
				
				//nbr_intf_SDN_ptr= get_SDN(neighbor_main_addr);
				printf("\n the intf_SDN_vptr=%g",*nbr_intf_SDN_ptr);
				if(own_main_address==4)
					{
				
				//nbr_intf_SDN_ptr= get_SDN(nbr_intf_addr);
				print_addr(own_main_address);
				print_addr(neighbor_main_addr);
				
								
				
				//nbr_intf_SDN_ptr= get_SDN(neighbor_main_addr);
				
				olsr_rte_neighbor_set_print_to_string();
				}
				
				/* Add to the exisiting intf vector (list) */
				prg_vector_insert (hello_msg_data_ptr->nbr_intf_addr_vptr,nbr_intf_addr_ptr, PRGC_VECTOR_INSERT_POS_TAIL);
				
				
				prg_vector_insert (hello_msg_data_ptr->nbr_intf_SDN_vptr,/***************************************************/ 
					nbr_intf_SDN_ptr, PRGC_VECTOR_INSERT_POS_TAIL);
					
			
					
					
				
				/* Model the size of the Interface Address inserted in Hello Msg */
				/* Neighbor Interface Address (32) = 32	bits for IPv4 OLSR.	     */
				/* Neighbor Interface Address (128) = 128 bits for IPv6 OLSR	 */
				olsr_hello_message_size += (is_ipv6_enabled? 128:32); 
				
				
				
				olsr_hello_message_size +=64;/***************************************************/					
										
				
				hello_msg_data_ptr->linkcode = linkcode;
				hello_msg_data_ptr->reserved = 8;
				hello_msg_data_ptr->link_msg_size = prg_vector_size (nbr_intf_addr_vptr);
				
				/* Add this msg data to the vector (list) of 	*/
				/* hello msgs that hello_msg_vptr will hold 	*/
				prg_vector_insert (hello_msg_vptr, hello_msg_data_ptr, PRGC_VECTOR_INSERT_POS_TAIL);
				}
			else
				{
				int*						nbr_intf_addr_ptr;
				double*						nbr_intf_SDN_ptr;/***************************************************/
				
				/* Either of conditions is true:				*/
				/* (1) same linkcode as previous one OR			*/
				/* (2) similar linkcode was created earlier 	*/
				/* Either of the case, we will have 		 	*/
				/* hello_msg_data_ptr != OPC_NIL				*/
									
				/* Add this nbr_intf_addr in earlier created hello msg data */
				/* hello_msg_data was created earlier for this linkcode 	*/
				OlsrT_Hello_Message_Data	*hello_msg_data_ptr = prev_hello_msg_data_ptr;
			
				/* Create inet address pointer to insert in the vector */
				nbr_intf_addr_ptr = olsr_rte_address_create (nbr_intf_addr);
				nbr_intf_SDN_ptr=get_SDN( nbr_intf_addr);
				
				
	//			printf("\n%g DreamWAver ",nbr_intf_SDN_ptr);
	//			printf("\n%f DreamWAver ",nbr_intf_SDN_ptr);
		//		printf("\n%g DreamWAver ",*nbr_intf_SDN_ptr);
	///			printf("\n%g DreamWAver ",&nbr_intf_SDN_ptr);
//				nbr_intf_SDN_ptr= get_SDN(neighbor_main_addr);/***************************************************/
		
				/* Add to the exisiting intf vector (list) */
				prg_vector_insert (hello_msg_data_ptr->nbr_intf_addr_vptr, 
					nbr_intf_addr_ptr, PRGC_VECTOR_INSERT_POS_TAIL);
				
				prg_vector_insert (hello_msg_data_ptr->nbr_intf_SDN_vptr, 
					nbr_intf_SDN_ptr, PRGC_VECTOR_INSERT_POS_TAIL);/***************************************************/
				
				
			
				hello_msg_data_ptr->link_msg_size = prg_vector_size (nbr_intf_addr_vptr);
			
				/* Model the size of the Interface Address inserted in Hello Msg */
				/* Neighbor Interface Address (32) = 32	bits for IPv4 OLSR.	     */
				/* Neighbor Interface Address (128) = 128 bits for IPv6 OLSR	 */
				olsr_hello_message_size += (is_ipv6_enabled? 128:32); 
				olsr_hello_message_size +=64;/***************************************************/
				olsr_hello_message_size +=32;  /*set energie  --Lyes*/
				
				}
	
			prev_linkcode = linkcode;
			} /* end for */

		/* Add the hello message header information and	*/
		/* complete the hello message creation 			*/
		hello_msg_ptr->reserved = 16;
		hello_msg_ptr->htime = OLSRC_HELLO_EMISSION_INTERVAL;
		hello_msg_ptr->willingness = node_willingness;
		hello_msg_ptr->hello_msg_vptr = hello_msg_vptr;
		
		
		
		
		/////////////////////////////**************************************************
		
		hello_msg_ptr->res_energy = get_energy();
		
		
		//////////////////////

		/* Add this hello message in OLSR Message */
		olsr_msg_ptr = olsr_pkt_support_olsr_message_create (hello_msg_ptr, originator_addr, 
			olsr_hello_message_size , msg_seq_num++, OLSRC_HELLO_MESSAGE, neighbor_hold_time, 1, 0, 
			is_ipv6_enabled);
	
		} /* end if (link table not empty) */

	else
		{
		/* Create an OLSR Message wtih msg_type equal to HELLO_MESSAGE 	*/
		/* and message_size = 0. Currently there is no link or NBR		*/
		/* there will be no actual hello message with interface info 	*/
		/* in this OLSR control packet (hello message)					*/
		
		/* Add the hello message header information and	*/
		/* complete the hello message creation 			*/
		hello_msg_ptr->reserved = 16;
		hello_msg_ptr->htime = OLSRC_HELLO_EMISSION_INTERVAL;
		hello_msg_ptr->willingness = node_willingness;
		hello_msg_ptr->hello_msg_vptr = OPC_NIL; /* No hello msg data */
		
		
		hello_msg_ptr->res_energy = get_energy();		
		
		/* Create OLSR message */
		olsr_msg_ptr = olsr_pkt_support_olsr_message_create (hello_msg_ptr, originator_addr, 
			olsr_hello_message_size, msg_seq_num++, OLSRC_HELLO_MESSAGE, neighbor_hold_time, 1, 0, 
			is_ipv6_enabled);
		}
		
	if (LTRACE_ACTIVE)
		{
		op_prg_odb_print_major (pid_string, "Broadcasting HELLO message \n", OPC_NIL);
		/* To print the Hello Message which is going out, uncomment the following line 	*/
		/* olsr_rte_olsr_message_print ((void*) olsr_msg_ptr, OPC_NIL);					*/
		}

		
	/* Create olsr pkt by adding pkt_len and pkt_seq_num to this olsr_msg */
	olsr_pkptr = olsr_pkt_support_pkt_create (olsr_msg_ptr, pkt_seq_num++);
		
	/* Update the hello traffic sent in bits per second	*/
	op_stat_write (global_stat_handles.hello_traffic_sent_bps_global_handle, op_pk_total_size_get (olsr_pkptr));
	op_stat_write (global_stat_handles.hello_traffic_sent_bps_global_handle, 0.0);
	
	/* Update the number of hello messages sent statistic	*/
	op_stat_write (local_stat_handles.total_hello_sent_shandle, 1.0);
	op_stat_write (global_stat_handles.total_hello_sent_global_shandle, 1.0);
	
	/* Send olsr pkt to udp */
	olsr_rte_pkt_send (olsr_pkptr, (is_ipv6_enabled? InetI_Ipv6_All_Nodes_LL_Mcast_Addr: InetI_Broadcast_v4_Addr), send_jittered);
	
	FOUT;
	}

static OlsrT_Hello_Message_Data*
olsr_rte_hello_msg_data_linkcode_exists (PrgT_Vector* hello_msg_vptr, int linkcode)
	{
	/* This function checks if there already exists a similar linkcode 			*/
	/* If yes, returns the handle to that hello_msg_data else returns OPC_NIL	*/
	
	OlsrT_Hello_Message_Data* 	hello_msg_data_ptr = OPC_NIL;
	int 						hello_msg_data_num, i;
	OlsrT_Hello_Message_Data*	prev_hello_msg_data_ptr = OPC_NIL;
	
	FIN (olsr_rte_hello_msg_data_linkcode_exists (<args>));
	
	hello_msg_data_num = prg_vector_size (hello_msg_vptr);
	
	/* Go through each msg_data from the HEAD */
	for (i= 0; i <= hello_msg_data_num -1; i++)
		{
		hello_msg_data_ptr = (OlsrT_Hello_Message_Data*) prg_vector_access (hello_msg_vptr, i);
		
		if (hello_msg_data_ptr->linkcode == linkcode)
			{
			prev_hello_msg_data_ptr = hello_msg_data_ptr;
			}
		}
	
	FRET (prev_hello_msg_data_ptr);
	}

static void
olsr_rte_send_TC (Boolean send_jittered)
	{
	/* Sends TC message periodically 		*/
	/* TC message is sent by MPR nodes only */
	/* Note: We are not fragmenting TC msg	*/
	/* according to MTU size as suggested	*/
	/* in RFC. Fragmentation will be taken 	*/
	/* care of in IP layer					*/
	
	Packet*							olsr_pkptr = OPC_NIL;
	OlsrT_MPR_Selector_Set_Entry*	mpr_selector_entry_ptr = OPC_NIL;
	OlsrT_Message*					olsr_msg_ptr = OPC_NIL;
	OlsrT_TC_Message*				tc_msg_ptr = OPC_NIL;
	int								i, num_mpr_selectors;
	List*							keys_lptr;
	int*							mprs_addr_ptr;
	int								olsr_tc_message_size = 0;
	double*                         mpr_nodes_SDN_ptr;///////////////////////////////////////////////////////////////////////////
	
	
	FIN (olsr_rte_send_TC (Boolean));
	if(get_energy()< 1000    )   { FOUT ;}
	
	
	
	update_energy();

	
	
	
	/* Remove the expired mpr_selector entries, lazy method */
	olsr_rte_expired_mpr_selector_set_entries_remove ();
	
	/* If MPR selector list is non-empty. I have been selected MPR 	*/
	/* Get all the addresses in the mpr selector set 				*/
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (mpr_selector_set_table);
	num_mpr_selectors = prg_list_size (keys_lptr);
	
	/* Set the stats for mpr_status of this node 	*/
	/* This statistics will periodically check with	*/
	/* each TC transmission, if this node is an 	*/
	/* MPR. If yes, then write 1 else write 0		*/
	if (num_mpr_selectors > 0)
		op_stat_write (local_stat_handles.mpr_status_shandle, 1.0);	
	else
		op_stat_write (local_stat_handles.mpr_status_shandle, 0.0);	
	
	if ((num_mpr_selectors >0) || (send_empty_tc_time > op_sim_time ()))
		{
		/*Create a new TC message */
		tc_msg_ptr = olsr_pkt_support_tc_message_create ();
				
		/* Model the size of OlsrT_TC_Message 	*/
		/* ANSN (16) + Reserved (16) = 32 bits 	*/
		olsr_tc_message_size = 32;
		
		/* Increament ANSN seq num if MPR Selector Set Has been changed */
		if (selectorset_changed == OPC_TRUE)
			{
			ANSN++;
			selectorset_changed = OPC_FALSE;
			}
		
		/* Fill the fields */
		tc_msg_ptr->tc_seq_num = ANSN;
		tc_msg_ptr->reserved = 8;
		
		for (i=0; i<num_mpr_selectors; i++)
			{
			/* Add each mpr selector address in this new TC message */
			mpr_selector_entry_ptr = (OlsrT_MPR_Selector_Set_Entry*) prg_list_access (keys_lptr, i);
			
			mprs_addr_ptr = olsr_rte_address_create (mpr_selector_entry_ptr->mpr_selector_ptr->nbr_addr);

			mpr_nodes_SDN_ptr=get_SDN(mpr_selector_entry_ptr->mpr_selector_ptr->nbr_addr);/////////////////////////////add to each mprs selector the SDN in a new list////////////////////////////////////////////////////
			
			prg_vector_insert (tc_msg_ptr->mpr_nodes_vptr, mprs_addr_ptr, PRGC_VECTOR_INSERT_POS_TAIL);
			prg_vector_insert (tc_msg_ptr->mpr_nodes_SDN_vptr, mpr_nodes_SDN_ptr, PRGC_VECTOR_INSERT_POS_TAIL);
			
			/* Model the size of the Interface Address inserted in Hello Msg */
			/* Advertised Neighbor Main Address (32) = 32 bits for Ipv4		 */
			/* Advertised Neighbor Main Address (128) = 128 bits for Ipv6	 */
			olsr_tc_message_size += (is_ipv6_enabled? 128:32);
			olsr_tc_message_size += 64;         /////////allocate memory for SDN /////////
			
			}
		
		/* Add this tc message in OLSR Message */
		olsr_msg_ptr = olsr_pkt_support_olsr_message_create (tc_msg_ptr, own_main_address, 
			olsr_tc_message_size , msg_seq_num++, OLSRC_TC_MESSAGE, tc_hold_time, 255, 0, 
			is_ipv6_enabled);
				
		/* Create olsr pkt by adding pkt_len and pkt_seq_num to this olsr_msg */
		olsr_pkptr = olsr_pkt_support_pkt_create (olsr_msg_ptr, pkt_seq_num++);
		
		if ((LTRACE_ACTIVE) || (op_prg_odb_ltrace_active ("adesai")))
			{
			op_prg_odb_print_major (pid_string, "Broadcasting new TC message \n", OPC_NIL);
;			/* To print the TC Message which is going out, uncomment the following line 	*/
			olsr_rte_olsr_message_print ((void*) olsr_msg_ptr, OPC_NIL);	
			}
	
		/* Update the send_empty_tc_time for emptry TC mesg transmission check 	*/
		/* Update send_empty_tc_time only while sending non-empty TCs			*/
		if (num_mpr_selectors >0) 
			{
			send_empty_tc_time = op_sim_time () + tc_hold_time;
			}
		
		/* Update the tc traffic sent in bits per second	*/
		op_stat_write (global_stat_handles.tc_traffic_sent_bps_global_handle, op_pk_total_size_get (olsr_pkptr));
		op_stat_write (global_stat_handles.tc_traffic_sent_bps_global_handle, 0.0);
		
		/* Update the number of TC messages sent statistic	*/
		op_stat_write (local_stat_handles.total_tc_sent_shandle, 1.0);
		op_stat_write (global_stat_handles.total_tc_sent_global_shandle, 1.0);

		/* Send olsr pkt to udp */
		olsr_rte_pkt_send (olsr_pkptr, (is_ipv6_enabled? InetI_Ipv6_All_Nodes_LL_Mcast_Addr: InetI_Broadcast_v4_Addr), send_jittered);
		}
	
	prg_list_destroy (keys_lptr, OPC_FALSE);
	
	FOUT;	
	}


static void
olsr_rte_pkt_send (Packet* pkptr, InetT_Address PRG_ARG_UNUSED (dest_addr), Boolean forward)
	{
	/* Sends the OLSR packet to UDP */
	double 			delay;
	
	FIN (olsr_rte_pkt_send (<args>));
	if(get_energy()< 1000   )   { update_energy() ; FOUT ;}/*************************************************************************************/

	/* Update the statistics for the routing traffic sent	*/
	olsr_support_routing_traffic_sent_stats_update (&local_stat_handles, &global_stat_handles, pkptr);
	
	/* Set the connection class to class 1.	*/
	op_ici_install (command_ici_ptr);
	
	if (forward)
		{
		/* While forwarding the packet, delay is higher */
		/* to avoid, collisions							*/
		delay = op_dist_uniform (0.5);
		op_pk_send_delayed (pkptr, output_strm, delay);
		}
	else
		{
		/* While transmitting the packet for the first 		*/
		/* time, we have alreayd jittered the periodicity	*/
		/* of packet transmission, so no delay			*/
		op_pk_send_forced (pkptr, output_strm);
		}
	
	/* Uninstall the ICI */
	op_ici_install (OPC_NIL);

	FOUT;
	}

static Boolean
olsr_rte_forward_packet (OlsrT_Message* olsr_message_ptr, int ip_src_addr)
	{
	/* Returns OPC_TRUE if this packet will be forwarded 			*/
	/* Else returns OPC_FALSE and packet should be destroyed 		*/
	/* Checks if the sender of the this message is in the node's	*/
	/* MPR selector list 											*/
	
	int 							nbr_main_addr;
	OlsrT_MPR_Selector_Set_Entry*	mprs_entry_ptr = OPC_NIL;
		
	FIN (olsr_rte_forward_packet (OlsrT_Message*, int));

	
	/* Get the main address of this nbr from which we received this TC */
	nbr_main_addr = olsr_support_main_addr_get (ip_src_addr);
	
	/* Check if this node is in my MPR selector list */
	if ((mprs_entry_ptr = (OlsrT_MPR_Selector_Set_Entry*) prg_bin_hash_table_item_get
		(mpr_selector_set_table, &nbr_main_addr)) != OPC_NIL)
		{
		/* Packet is eligible for forwarding */
		
		/* Decreament the ttl */
		olsr_message_ptr->ttl--;
		
		if (olsr_message_ptr->ttl == 0)
			{
			/* TTL has reached zero, do not forward */
			FRET (OPC_FALSE);
			}
		
		/* Increament the hop count */
		olsr_message_ptr->hop_count++;
		
		FRET (OPC_TRUE);
		}
	
	FRET (OPC_FALSE);
	}

	
static void
olsr_rte_neighborhood_topology_check (void)
	{
	/* Checks the status of the static varaibles 		*/
	/* "neighborhood_changed" and "topology_changed" 	*/
	/* and updates the required tables					*/
	InetT_Address		inet_tmp_addr;
	char				tmp_str [256], node_name [256];

	FIN (olsr_rte_neighborhood_topology_check (void));

	if (neighborhood_changed == OPC_TRUE) 
		{
		/* Update the OLSR Performance. Neighborhood Change statistics */
		op_stat_write (global_stat_handles.nbrhood_change_global_shandle, 1.0);
			
		if (LTRACE_ACTIVE)
			{
			inet_tmp_addr = inet_rtab_index_to_addr_convert (own_main_address);
			inet_address_print (tmp_str, inet_tmp_addr);
			inet_address_to_hname (inet_tmp_addr, node_name);
			printf ("Neighborhood Changed at node %s (%s) \n", tmp_str, node_name);
			printf ("Re-calculating MPR set and Routing Table \n");
			}
		
		/* Calculate or update MPR set */
		olsr_rte_calculate_mpr_set();
		}
	
	if (topology_changed == OPC_TRUE)
		{
		/* Update the OLSR Performance. Topology Change statistics */
		op_stat_write (global_stat_handles.topology_change_global_shandle, 1.0);
			
		if (LTRACE_ACTIVE)
			{
			inet_tmp_addr = inet_rtab_index_to_addr_convert (own_main_address);
			inet_address_print (tmp_str, inet_tmp_addr);
			inet_address_to_hname (inet_tmp_addr, node_name);
			printf ("Topology Changed at node %s (%s) \n", tmp_str, node_name);
			printf ("Re-calculating Routing Table \n");
			}
		} 
	
	if ((neighborhood_changed) || (topology_changed))
		{
		/* Either neighborhood or topology has changed, */
		/* perform rte table calculation.				*/
		
		/* If DJK quantum is greater than 0, align your computation to the nearest instant	*/
		if (djk_processing_time_quantum > 0)
			{
			if (!rte_calc_already_scheduled)
				{
				op_intrpt_schedule_self (ceil (op_sim_time ()/djk_processing_time_quantum) * djk_processing_time_quantum, 
					OLSRC_RTE_CALC_TIMER_EXPIRY);
				rte_calc_already_scheduled = OPC_TRUE;
				}
			}
		/* Otherwise proceed to calculation immediately				*/
		else
			{
			/* Perform route table calc */
			olsr_rte_djk_rte_table_calculate ();
			last_rte_calc_time = op_sim_time ();
			}
				
		/* Reset the flags */
		neighborhood_changed = topology_changed = OPC_FALSE;
		}
		
	FOUT;
	}

/* DUPLICATE SET*/

static void
olsr_rte_duplicate_set_entry_add (int orig_addr, int seq_num, Boolean rexmitted)
	{
	/* Adds an entry in duplicate set table */
	
	OlsrT_Duplicate_Set_Entry*	dup_entry_ptr;
	OlsrT_Dup_Set_Key			key;
	
	FIN (olsr_rte_duplicate_set_entry_add (int, int));
	
	key.originator_addr = orig_addr;
	key.message_seq_num = seq_num;
	
	if ((dup_entry_ptr = (OlsrT_Duplicate_Set_Entry*) 
		prg_bin_hash_table_item_get (duplicate_set_table, &key)) != OPC_NIL)
		{
		/* Entry already exists */		
		/* Cancel the previously scheduled event	*/
		op_ev_cancel_if_pending (dup_entry_ptr->entry_expiry_evhandle);
		
		/* Scehdule a fresh interrupt for expiry */
		dup_entry_ptr->dup_expiry_time = op_sim_time () + dup_hold_time;
		if (rexmitted)
			dup_entry_ptr->rexmitted = rexmitted;

		dup_entry_ptr->entry_expiry_evhandle = op_intrpt_schedule_call (dup_entry_ptr->dup_expiry_time,
			OLSRC_DUP_ENTRY_EXPIRY,	olsr_rte_duplicate_entry_delete, dup_entry_ptr);	
		}
	else
		{
		/* Create a new entry */
		dup_entry_ptr = (OlsrT_Duplicate_Set_Entry*) op_prg_pmo_alloc (dup_entry_pmh);
		dup_entry_ptr->dup_expiry_time = op_sim_time () + dup_hold_time;
		dup_entry_ptr->rexmitted = rexmitted;
		dup_entry_ptr->key = key;
		
		/* Schedule a procedure interrupt to remove the entry when expired */
		dup_entry_ptr->entry_expiry_evhandle = op_intrpt_schedule_call (dup_entry_ptr->dup_expiry_time,
			OLSRC_DUP_ENTRY_EXPIRY,	olsr_rte_duplicate_entry_delete, dup_entry_ptr);	
	
		/* Inset entry in duplicate set table */
		prg_bin_hash_table_item_insert 
			(duplicate_set_table, &key, dup_entry_ptr, OPC_NIL);
		}
	
	FOUT;
	}
	
/*****************************************************/
/********* Timer Expiry Handle Functions *************/
/*****************************************************/

static void
olsr_rte_hello_expiry_handle (void)
	{
	/* Handles hello timer expiry and */
	/* Sends periodic hello messeages */
	
	FIN (olsr_rte_hello_expiry_handle (void));
	
	/* Calls function to create and send hello message */
	olsr_rte_send_hello (OPC_FALSE);
	
	/* Schedule the next check to send hello messages	*/
	/* Jitter Hello msg with op_dist_uniform (0.5)		*/
	if (op_dist_uniform (2.0) > 1.0)
		{
		hello_timer_evhandle = op_intrpt_schedule_self (op_sim_time () + hello_interval -  op_dist_uniform (0.5), OLSRC_HELLO_TIMER_EXPIRY);
		}
	else
		{
		hello_timer_evhandle = op_intrpt_schedule_self (op_sim_time () + hello_interval +  op_dist_uniform (0.5), OLSRC_HELLO_TIMER_EXPIRY);
		}
	
	
	FOUT;
	}

static void
olsr_rte_tc_expiry_handle (void)
	{
	/* Handles TC timer expiry and */
	/* Sends periodic TC messeages */
	
	FIN (olsr_rte_tc_expiry_handle (void));
	
	/* Calls function to create and send hello message */
	olsr_rte_send_TC (OPC_FALSE);
	
	if ((tc_entry_expiry_time + 20.0) < op_sim_time ())
		{
		/* TC table has not been updated in last 20 seconds 	*/
		/* This node may have been isolated, remove expired 	*/
		/* entries and schedule the next check after 50 seconds */
		olsr_rte_expired_tc_entries_remove ();
		tc_entry_expiry_time = op_sim_time () + 10* tc_interval;
		}
	
	/* Schedule the next check to send tc message		*/
	/* Jitter the TC message with op_dist_uniform (0.5)	*/
	if (op_dist_uniform (2.0) > 1.0)
		{
		tc_timer_evhandle = op_intrpt_schedule_self (op_sim_time () + tc_interval -  op_dist_uniform (0.5), OLSRC_TC_TIMER_EXPIRY);
		}
	else
		{
		tc_timer_evhandle = op_intrpt_schedule_self (op_sim_time () + tc_interval +  op_dist_uniform (0.5), OLSRC_TC_TIMER_EXPIRY);
		}
	
		
	FOUT;
	}



	
/********************************************************/
/********* Table Entry Access/Create Functions **********/
/********************************************************/

/******************************/
/*** ROUTE TABLE: FUNCTIONS ***/
/******************************/

static void
olsr_rte_table_calc_expiry_handle (void)
	{
	/* Function to perform route table calculation 	*/
	/* after timer expiry. Timer is started with 	*/
	/* first nbrhood or topology change detection.	*/
	
	FIN (olsr_rte_table_calc_expiry_handle (void));
	
	/* Call calculate route table function */

	olsr_rte_djk_rte_table_calculate ();
	
	rte_calc_already_scheduled = OPC_FALSE;
	last_rte_calc_time = op_sim_time ();
	
	FOUT;
	}


static void
olsr_rte_routing_table_entry_add (int dest_addr,int next_addr, int hops, int local_iface_addr, IpT_Dest_Prefix dest_prefix)
	{
	OlsrT_Routing_Table_Entry*		rt_entry_ptr = OPC_NIL;
	void*							old_contents_ptr;
	
	/* Add an entry to the OLSR routing table. Besides specifying the destination address, */
	/* the next hop to reach the destination address, the number of hops to reach the      */
	/* destination address, the local interface to reach the next hop, the new route table */
	/* entry will also contain the destination prefix that was used to insert the address  */
	/* in the IP Fwd table. The destination prefix needs to be retained by OLSR because    */
	/* OLSR is responsible for destroying this destination prefix, when it withdraws this  */
	/* route from IP Fwd and from OLSR's routing table. The OLSR retains the destination   */
	/* prefix by setting it into the OLSR routing table entry that is added via this func- */
	/* tion. As a corrolary, it follows that for every route OLSR inserts into IP, there   */
	/* should be a corresponding entry in the OLSR routing table, in which entry OLSR keeps*/
	/* the destination prefix OLSR gives to IP. In particular, the OLSR table should hold  */
	/* entries to the directly connected routes that OLSR inserts into IP (after flushing  */
	/* all the IP entries during a calc) - that OLSR keeps directly connected routes in its*/
	/* table is purely an implementation detail, it does not reflect OLSR operational logic*/
	
	
	FIN (olsr_rte_routing_table_entry_add(<args>));
	
	/* Allocate the routing table entry from the pooled memory	*/
	rt_entry_ptr = (OlsrT_Routing_Table_Entry*) op_prg_pmo_alloc (rt_entry_pmh);
	
	rt_entry_ptr->dest_addr = dest_addr;
	rt_entry_ptr->next_addr = next_addr;
	rt_entry_ptr->hops = hops;
	rt_entry_ptr->local_iface_addr = local_iface_addr;
	rt_entry_ptr->dest_prefix = dest_prefix; 
	
	prg_bin_hash_table_item_insert (olsr_routing_table, &dest_addr, rt_entry_ptr, &old_contents_ptr);
	
	FOUT;
	}


/****************************/
/*** MPR SET : FUNCTIONS ****/
/****************************/

static void
olsr_rte_calculate_mpr_set (void)
	{
	/* Calculates MPRs for this node  */
	/* and fills up the MPR set table */
	int 	num_strict_two_hops = 0;
	int				num_keys, i, willingness, degree, reachability,top_Energie;
	double			fs;
	int			Conf,nombre_2_saut;
	OlsrT_Neighbor_Set_Entry*	mpr_candidate_ptr = OPC_NIL;
	OlsrT_Neighbor_Set_Entry*	nbr_set_entry_ptr = OPC_NIL;
	List*						keys_lptr = OPC_NIL;

	FIN (olsr_rte_calculate_mpr_set (void));
	
	/* Update the OLSR Performance. MPR Calcs statistics */
	op_stat_write (global_stat_handles.mpr_calcs_global_shandle, 1.0);
				
	/* For each entry in neighbor table, neighbor with */
	/* willingness WILL_ALWAYS should be marked as MPR */
	
	//olsr_rte_mpr_will_always_nbr_add ();
	
	/* Make a list of strict 2 hop neighbors as the two hop	*/
	/* nbr table can have neighbor and 2 hop neighbors		*/
	num_strict_two_hops = olsr_rte_strict_two_hop_set_create ();
	nombre_2_saut=num_strict_two_hops;
	/* 1-) Commencer par un ensemle de MPR vide*/

	/* 2-) Calculer le degree D(y) pour chaque entree dans le voisinage */
	olsr_rte_calculate_degree ();

	/* 3-)Calculer la fidlit F(y) de chaque nud dans N(x).f(y) est le nombre de jetons*/
	olsr_rte_calculate_FdN();
	

	/* Find all two hop nbrs that are reachable through */
	/* only one neighbor. Mark that neighbor as MPR 	*/
	
	/* 4-) Choisir les nuds de l'ensemble des voisins N(x) qui sont les seuls
	ayant un lien avec un voisin du second niveau. Ajouter ces nuds slectionns 
	de N(x)	 l'ensemble MPRset (x), et liminer tous les
	nuds du second niveau couverts par ces derniers de l'ensemble N2(x).*/
	olsr_rte_mpr_with_nbr_count_one_add (&num_strict_two_hops);
	
	
	
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (neighbor_set_table);
	num_keys = op_prg_list_size (keys_lptr); 

	/* 5-) Tantque N2(x) n'est pas vide refire:*/
	while (num_strict_two_hops > 0)
		{		
	
		
	/* 5.a-) Calculer rechabilit R(y) pour chaque entree dans le voisinage*/
		olsr_rte_calculate_reachability (keys_lptr);
		/* Initialize the values for the key attributes */
		top_Energie=-1;
		Conf=-1;
		willingness = -1;
		reachability = -20;
		degree = -1;
		fs=2.1987;
		mpr_candidate_ptr = OPC_NIL;
			
//		
		
/*	if(own_main_address==3)
		{
		printf("\nAlgorithme de Selection des MPR de neoud N%d qui a %d/%d voisins de 2 saut:",own_main_address,num_strict_two_hops,nombre_2_saut);
		print_addr(own_main_address);
		printf("\n===================================================================================================");
		printf("\n Neighbor    Willingness      Reachability     Degree     Stabilite          Fidlit		Energie");
		printf("\n===================================================================================================");
	//printf("\n Default         %d               %d            %d          %g	          %d	   %d",willingness,reachability,degree,fs,Conf,lyasEnergie);
		//printf("\n___________________________________________________________________________________________________");
		}
		
*/		for (i=0; i< num_keys; i++)
			{
			/* For each entry value in neighbor table	*/
			nbr_set_entry_ptr = (OlsrT_Neighbor_Set_Entry*) op_prg_list_access (keys_lptr, i);
			
			if ((nbr_set_entry_ptr->status == OLSRC_NOT_SYM_STATUS) ||
				(nbr_set_entry_ptr->willingness == OLSRC_WILL_NEVER) ||
				(nbr_set_entry_ptr->reachability == OLSRC_VALUE_MPR))
				{
				/* Either its not a SYM NBR or the 		*/
				/* willingness is WILL_NEVER 			*/
				/* or its already selected as MPR		*/
				/* Do nothing,go to next neighbor entry	*/
				continue;
				}

/*			if(own_main_address==3)
				{
			printf("\n");
			print_addr(nbr_set_entry_ptr->nbr_addr);
			
			printf("      %2d                %2d           %2d            %g	    %d/%d",nbr_set_entry_ptr->willingness,nbr_set_entry_ptr->reachability,nbr_set_entry_ptr->degree,nbr_set_entry_ptr->stabilite.SDN,nbr_set_entry_ptr->conf,nbr_set_entry_ptr->degree);
			printf("\n___________________________________________________________________________________________________");
			}
/*
	/* 5-b) Ajouter le nud (y) de N(x), ayant F(y) maximal  l'ensemble des MPRset (x),
		Si les valeurs sont les mmes prend le nud qui  le plus grand degr de reachability R(y).
		Si ces derniers sont gaux on prend alors le nud avec le plus grand degr D(y).*/
			
			
			if (nbr_set_entry_ptr->willingness > willingness)
				{   
						mpr_candidate_ptr = nbr_set_entry_ptr;  //tit 
						willingness 	  = nbr_set_entry_ptr->willingness;
						Conf			  = nbr_set_entry_ptr->conf;
						reachability	  = nbr_set_entry_ptr->reachability;
						degree 			  = nbr_set_entry_ptr->degree;
						fs				  = nbr_set_entry_ptr->stabilite.SDN;
						top_Energie		  = nbr_set_entry_ptr->energie ;

				}
			else if ( (nbr_set_entry_ptr->willingness == willingness) &&
					  (nbr_set_entry_ptr->conf		   > 		Conf))
					{
						mpr_candidate_ptr = nbr_set_entry_ptr;
						top_Energie		  =	nbr_set_entry_ptr->energie;
						Conf			  =	nbr_set_entry_ptr->conf;
						reachability 	  =	nbr_set_entry_ptr->reachability;
						degree 			  =	nbr_set_entry_ptr->degree;
						fs				  =	nbr_set_entry_ptr->stabilite.SDN;
					}
			
			else if ( (nbr_set_entry_ptr->willingness == willingness) &&
				      (nbr_set_entry_ptr->conf == Conf)&&
					  (nbr_set_entry_ptr->energie		   > 		top_Energie))
					{
						mpr_candidate_ptr = nbr_set_entry_ptr;
						Conf			  =	nbr_set_entry_ptr->conf;
						reachability 	  =	nbr_set_entry_ptr->reachability;
						degree 			  =	nbr_set_entry_ptr->degree;
						fs				  =	nbr_set_entry_ptr->stabilite.SDN;
					}
			
			else if ( (nbr_set_entry_ptr->willingness == willingness ) &&
					 (nbr_set_entry_ptr->energie == top_Energie)&&
                    (nbr_set_entry_ptr->conf 	 == Conf		 ) &&
					  (nbr_set_entry_ptr->reachability > reachability))
					{
						mpr_candidate_ptr = nbr_set_entry_ptr;
						reachability	  = nbr_set_entry_ptr->reachability;
						degree 			  = nbr_set_entry_ptr->degree;
						fs				  = nbr_set_entry_ptr->stabilite.SDN;
					}
			
			else if ( (nbr_set_entry_ptr->willingness == willingness ) &&
					  (nbr_set_entry_ptr->energie == top_Energie)&&
				      (nbr_set_entry_ptr->conf 	 	  == Conf		 ) &&
					  (nbr_set_entry_ptr->reachability == reachability) &&
					  (nbr_set_entry_ptr->degree	   > degree		 ))
				   {
				   	   mpr_candidate_ptr = nbr_set_entry_ptr;
					   degree			 = nbr_set_entry_ptr->degree;
					   fs				 = nbr_set_entry_ptr->stabilite.SDN;

				   }
			}
		
		/* We are not performing NIL ptr check 	*/
		/* for mpr_candidate since, we always	*/
		/* expect to find MPR to cover all the	*/
		/* nodes in strict two hop nbr list		*/
		
		/* Mark this best candiate for MPR */
		
		
		
//		printf("\n%    d             %d             %d           %d",mpr_candidate_ptr->nbr_addr,mpr_candidate_ptr->willingness,mpr_candidate_ptr->reachability,mpr_candidate_ptr->degree);
		
		mpr_candidate_ptr->reachability = OLSRC_VALUE_MPR;
//		printf("\nnouvelle entree      %d             %d           %d            %g	%d",mpr_candidate_ptr->willingness,mpr_candidate_ptr->reachability,mpr_candidate_ptr->degree,mpr_candidate_ptr->stabilite.SDN,mpr_candidate_ptr->conf);			
//			print_addr(mpr_candidate_ptr->nbr_addr);
					
		
		/* Delete all those two hop nodes which are covered by */
		/* this MPR from the strict two hop list */
		

		/* Enlever tous les nuds du second niveau couverts par ce nud de lensemble N2(x).*/
		olsr_rte_update_strict_two_hop_set (&num_strict_two_hops, mpr_candidate_ptr);
		} /*Fin Tantque*/

	
	prg_list_destroy (keys_lptr, OPC_FALSE);
	
	/* Optimization of MPR set should happen here 	*/
	/* Not required if all the nodes in the network	*/
	/* have same Willingness. MPR calculation 		*/
	/* itself gives optimized set, more optimization*/
	/* will only be helpful when nodes in network	*/
	/* have different level of WILLINGNESS			*/
	/* Extra optimization currently not implemented.*/
	
	/*Ajouter ce noeud au mpr liste*/
	olsr_rte_build_new_mpr_set ();
	
	/* Note: Here we are not doing an explicit check */
	/* if the new MPR set is different from the 	*/
	/* previous one. RFC says, if different send 	*/
	/* out an Hello message to notify the changes. 	*/
	/* We will wait for next scheduled hello rather	*/
	/* than explicit hello message. Lazy method. 	*/
	
/*	if(own_main_address==3)
	{
	olsr_rte_mpr_set_print_to_stringara();
	olsr_rte_neighbor_set_print_to_string();
    olsr_rte_two_hop_neighbor_set_print_to_string ();
	}*/
	
	FOUT;
	}

static void olsr_rte_calculate_degree (void)
	{
	List*			keys_lptr;
	PrgT_List_Cell	* key_cell_ptr;

	/* This function calculates the degree for all the neighbor nodes */
	/* and populates the degree field of each nbr 	*/
	/* Degree means: Number of strict two hop nbrs 	*/
	/* that this node can reach 					*/
	FIN (olsr_rte_calculate_degree (void));
		
	/* Get all entry values from the neighbor table */
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (neighbor_set_table);
	for (key_cell_ptr = prg_list_head_cell_get (keys_lptr);
		 key_cell_ptr;
		 key_cell_ptr = prg_list_cell_next_get (key_cell_ptr))
		{
		PrgT_List_Cell * list_cell_ptr;
		
		/* For each entry value in neighbor table	*/
		OlsrT_Neighbor_Set_Entry * nbr_set_entry_ptr =
			(OlsrT_Neighbor_Set_Entry*) prg_list_cell_data_get (key_cell_ptr);
		
		/* Clear the degree field */
		nbr_set_entry_ptr->degree  = OLSRC_VALUE_CLEAR;
		nbr_set_entry_ptr->reachability = OLSRC_VALUE_CLEAR;
			
		/* Get the list of 2 hop neighbors */
		for (list_cell_ptr = prg_list_head_cell_get (&nbr_set_entry_ptr->two_hop_nbr_list); list_cell_ptr; 
			list_cell_ptr = prg_list_cell_next_get (list_cell_ptr))
			{
			/* Get neighbor address */
			OlsrT_Two_Hop_Neighbor_Set_Entry * two_hop_addr_ptr =
				(OlsrT_Two_Hop_Neighbor_Set_Entry*) prg_list_cell_data_get (list_cell_ptr);
			
			if (two_hop_addr_ptr->strict_two_hop == OPC_TRUE || (nbr_set_entry_ptr->status != OLSRC_SYM_STATUS))
			    {
			    nbr_set_entry_ptr->degree++;			
			    }
			}
	//	printf("\nAra:Degree of this noeud %d is %d",nbr_set_entry_ptr->nbr_addr,nbr_set_entry_ptr->degree);
		}
	
	/* Destory the list, but do not free the values */
	prg_list_destroy (keys_lptr, OPC_FALSE);
	
	
	
	FOUT;
	
	}

static void
olsr_rte_build_new_mpr_set (void)
	{
	/* First deletes all entries from the MPR set */
	/* then inserts new ones */
	List*								keys_lptr = OPC_NIL;
	List*								m_keys_lptr = OPC_NIL;
	int 								i, num_keys;
/*	Boolean								MPR_SET_CHANGED = OPC_FALSE;*/
	OlsrT_Neighbor_Set_Entry*			nbr_set_entry_ptr = OPC_NIL;
	OlsrT_MPR_Set_Entry*				mpr_entry_ptr = OPC_NIL;
	
	FIN (olsr_rte_build_new_mpr_set (void));
	
	/* Delete all entries from the mpr set */
	m_keys_lptr = (List*) prg_bin_hash_table_item_list_get (mpr_set_table);
	num_keys = op_prg_list_size (m_keys_lptr);
	
	for (i=0; i< num_keys; i++)
		{
		/* For each entry in mpr set table	*/
		mpr_entry_ptr = (OlsrT_MPR_Set_Entry*) op_prg_list_access (m_keys_lptr, i);
		prg_bin_hash_table_item_remove (mpr_set_table, &(mpr_entry_ptr->mpr_addr));
		op_prg_mem_free (mpr_entry_ptr);
		}
	
	prg_list_destroy (m_keys_lptr, OPC_FALSE);
	
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (neighbor_set_table);
	num_keys = op_prg_list_size (keys_lptr);
	
	for (i=0; i< num_keys; i++)
		{
		/* For each entry in two hop neighbor table	*/
		nbr_set_entry_ptr = (OlsrT_Neighbor_Set_Entry*) op_prg_list_access (keys_lptr, i);
					
		if (nbr_set_entry_ptr->reachability == OLSRC_VALUE_MPR)
			{
			/* This nbr is selected as MPR, 		*/
			/* Check if it already exists in the	*/
			/* previous list of MPRs. If not add	*/
			/* this nbr in MPR list and mark 		*/
			/* MPR_SET_CHANGED = OPC_TRUE 			*/
			
			/* Add this neighbor to MPR set */
			olsr_rte_mpr_set_entry_create (nbr_set_entry_ptr->nbr_addr);
			
			}
		}
	
	prg_list_destroy (keys_lptr, OPC_FALSE);
	
	FOUT;
	}


static OlsrT_MPR_Set_Entry*
olsr_rte_mpr_set_entry_create (int mpr_addr)
	{
	OlsrT_MPR_Set_Entry* 		mpr_set_entry_ptr = OPC_NIL;
	void*						old_contents_ptr;
	
	FIN (olsr_rte_mpr_set_entry_create (int));
	
	/* Create a new netry for MPR set	*/
	mpr_set_entry_ptr = (OlsrT_MPR_Set_Entry*) op_prg_pmo_alloc (mpr_set_entry_pmh);
	mpr_set_entry_ptr->mpr_addr = mpr_addr;

	/* Set the mpr set entry for this interface 	*/
	/* address in the mpr set table					*/
	prg_bin_hash_table_item_insert 
		(mpr_set_table, &mpr_addr, mpr_set_entry_ptr, &old_contents_ptr);

	FRET (mpr_set_entry_ptr);
	
	}

static int
olsr_rte_strict_two_hop_set_create (void)
	{
	/* Returns number of strict two hop addresses by 	*/
	/* iterating through the 2 hop nbr table 			*/
	OlsrT_Two_Hop_Neighbor_Set_Entry*	two_hop_nbr_entry_ptr;
	OlsrT_Neighbor_Set_Entry*			nbr_entry_ptr;
	List*								keys_lptr;
	int									i, num_keys;
	int									j, num_one_hop_nbrs;
	OlsrT_Nbr_Addr_Two_Hop_Entry*		two_hop_nbr_addr_ptr = OPC_NIL;
	int num_strict_two_hops = 0;
	
	FIN (olsr_rte_strict_two_hop_set_create (void));
		
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (two_hop_nbr_set_table);
	num_keys = op_prg_list_size (keys_lptr);
	
	/* For each entry in two hop neighbor table	*/
	for (i=0; i< num_keys; i++)
		{
		/* Get the two-hop-nbr entry ptr */
		two_hop_nbr_entry_ptr = (OlsrT_Two_Hop_Neighbor_Set_Entry*) op_prg_list_access (keys_lptr, i);
		
		/* Strict two hop nbr set as per section 1.1 */
		/* 2 hop nbr that is    					 */
		/*  - Not node itself 			 			 */
		/*  - Not a SYM nbr 						 */
		/*  - Can be reached through a nbr with      */
		/*    willingness other than WILL_NEVER      */

		/* Checking if 2 hop nbr not the node itself */
		if (two_hop_nbr_entry_ptr->two_hop_addr == own_main_address)
			{
			continue;
			}
		
		/* Initializing nbr ptr */
		nbr_entry_ptr = OPC_NIL;
		
		/* Checking if this 2-hop-nbr is a SYM NBR */
		nbr_entry_ptr = (OlsrT_Neighbor_Set_Entry*) 
			prg_bin_hash_table_item_get (neighbor_set_table, &(two_hop_nbr_entry_ptr->two_hop_addr));
		
		/* Check the SYM-nbr condition */
		if ((nbr_entry_ptr != OPC_NIL) &&
			(nbr_entry_ptr->status == OLSRC_SYM_STATUS))
			{
			/* This 2-hop nbr is my SYM nbr */
			/* Skip this 2-hop nbr			*/
			continue;
			}
		
		/* Checking if this 2 hop nbr is reachable through 	*/
		/* a willing NBR (i.e. a nbr with willingness other	*/
		/* than WILL_NEVER)					*/

		/* Get the number of one-hop-nbr to reach this 2-hop-nbr */
		num_one_hop_nbrs = op_prg_list_size (&two_hop_nbr_entry_ptr->neighbor_list);
		
		for (j=0; j< num_one_hop_nbrs; j++)
			{
			/* For each one hop nbr addr */
			two_hop_nbr_addr_ptr = (OlsrT_Nbr_Addr_Two_Hop_Entry*)
				op_prg_list_access (&two_hop_nbr_entry_ptr->neighbor_list, j);

			/* Get the neighbor entry ptr */
			nbr_entry_ptr = two_hop_nbr_addr_ptr->nbr_ptr;

			/* Check the willingness of this nbr */
			if (nbr_entry_ptr->willingness != OLSRC_WILL_NEVER)
				{
				/* Marking two hop neighbor as strict two hop */
				two_hop_nbr_entry_ptr->strict_two_hop = OPC_TRUE;
				++num_strict_two_hops;
				break;
				
				}
			}
		
		}/*end for*/
		
	prg_list_destroy (keys_lptr, OPC_FALSE);
	
	FRET (num_strict_two_hops);
	}

static void
olsr_rte_mpr_with_nbr_count_one_add (int *num_strict_two_hops)
	{
	/* This function goes through each node in strict hop nbr list 	*/
	/* and checks if any of these two hop nodes can be reached only */
	/* by one neighbor. Then that neighbor is marked as an MPR 		*/
	
	OlsrT_Two_Hop_Neighbor_Set_Entry* 	two_hop_nbr_entry_ptr = OPC_NIL;
	OlsrT_Nbr_Addr_Two_Hop_Entry*		two_hop_nbr_addr_ptr = OPC_NIL;
	OlsrT_Neighbor_Set_Entry*			nbr_set_entry_ptr = OPC_NIL;
	List*								keys_lptr = OPC_NIL;
	int									num_keys, i;
	
	FIN (olsr_rte_mpr_with_nbr_count_one_add (<args>));
	
	/* Get all the keys from the strict two hop neighbor list */
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (two_hop_nbr_set_table);
	num_keys = op_prg_list_size (keys_lptr);
	
	for (i=0; i< num_keys; i++)
		{
		/* For each address in strict two hop list 				*/
		/* Find the corresponding entry in 2 hop neighbor table */
		two_hop_nbr_entry_ptr = (OlsrT_Two_Hop_Neighbor_Set_Entry*) prg_list_access (keys_lptr, i);
		if (two_hop_nbr_entry_ptr->strict_two_hop == OPC_FALSE)
		         continue;
		
		if (1==2)  //(two_hop_nbr_entry_ptr->neighbor_list.size == 1)
			{
			/* This two hop nbr can only be reached through		*/
			/* one SYM nbr, mark that neighbor as MPR 			*/
			
			/* Get the neighbor address */
			two_hop_nbr_addr_ptr = (OlsrT_Nbr_Addr_Two_Hop_Entry*)
				op_prg_list_access (&two_hop_nbr_entry_ptr->neighbor_list, 0);
			
			/* Get the neighbor entry */
			nbr_set_entry_ptr = two_hop_nbr_addr_ptr->nbr_ptr;
						
			if ((nbr_set_entry_ptr->status == OLSRC_SYM_STATUS) &&
				(nbr_set_entry_ptr->reachability != OLSRC_VALUE_MPR) &&
				(nbr_set_entry_ptr->willingness != OLSRC_WILL_NEVER) &&
				((*num_strict_two_hops) > 0))
				{
				/* This neighbor is not yet chosen as MPR */
				/* and its willingness in not will_never  */
				/* and there are more than one strict 	  */
				/* 2-hop nbrs to be covered 			  */
				
				/* Mark this neighbor as MPR */
				nbr_set_entry_ptr->reachability = OLSRC_VALUE_MPR;
				
				/* Since this neighbor has become MPR,  */
				/* delete all the two hop addresses 	*/
				/* reachable through it from the strict */
				/* two hop addr list.				  	*/
				olsr_rte_update_strict_two_hop_set (num_strict_two_hops, nbr_set_entry_ptr);
				
				}
			
			if ((*num_strict_two_hops) == 0)
				break;
			
			}/*end if (two_hop_nbr_entry_ptr->neighbor_list.size == 1)*/
		}/*end for*/
	
	prg_list_destroy (keys_lptr, OPC_FALSE);

	FOUT;
	}

static void
olsr_rte_update_strict_two_hop_set (int *num_strict_two_hops, OlsrT_Neighbor_Set_Entry* mpr_candidate_ptr)
	{
	/* This function removes all two hop neighbor addresses  */
	/* which are covered by a given neighbor from the strict */
	/* two hop set											 */
	int							i, two_hop_size;
	OlsrT_Two_Hop_Neighbor_Set_Entry*			two_hop_addr_ptr;
	
	FIN (olsr_rte_update_strict_two_hop_set (<args>));
	
	/* Get the list of two hop neighbors that this mpr can reach */
	two_hop_size = op_prg_list_size (&mpr_candidate_ptr->two_hop_nbr_list);
	
	for (i=0; i < two_hop_size; i++)
		{
		/* For each two hop reachable node, if this address  */
		/* exists in strict two hop set, remove it 			 */
		two_hop_addr_ptr = (OlsrT_Two_Hop_Neighbor_Set_Entry*) op_prg_list_access (&mpr_candidate_ptr->two_hop_nbr_list, i);
		
		if (two_hop_addr_ptr->strict_two_hop == OPC_TRUE)
			{
			/* This address is a strict two hop, unmark it */
			two_hop_addr_ptr->strict_two_hop = OPC_FALSE;
			(*num_strict_two_hops)--;
			}
		}
	
	FOUT;
	
	}

static void
olsr_rte_calculate_reachability (PrgT_List * keys_lptr)
	{
	/* Calculates and populates the reachability field in NBR table */
	PrgT_List_Cell * key_cell_ptr;
	
	FIN (olsr_rte_calculate_reachability (List*));
	
	/* Get all entry values from the neighbor table */
	for (key_cell_ptr = prg_list_head_cell_get (keys_lptr);
		 key_cell_ptr;
		 key_cell_ptr = prg_list_cell_next_get (key_cell_ptr))
		{
		/* For each entry value in neighbor table	*/
		OlsrT_Neighbor_Set_Entry * nbr_set_entry_ptr =
			(OlsrT_Neighbor_Set_Entry*) prg_list_cell_data_get (key_cell_ptr);
		
		/* If this neighbor has not been chosen as MPR yet,  */
		/* then only consider it for reahability computation */
		if (nbr_set_entry_ptr->reachability != OLSRC_VALUE_MPR)
			{
			PrgT_List_Cell* list_cell_ptr;
			
			/* Clear the reachability field */
			nbr_set_entry_ptr->reachability  = OLSRC_VALUE_CLEAR;
							
			/* for each 2 hop neighbor address */
			for (list_cell_ptr = prg_list_head_cell_get (&nbr_set_entry_ptr->two_hop_nbr_list); list_cell_ptr; 
				list_cell_ptr = prg_list_cell_next_get (list_cell_ptr))
				{
				/* Get neighbor address */
				OlsrT_Two_Hop_Neighbor_Set_Entry * two_hop_addr_ptr =
					(OlsrT_Two_Hop_Neighbor_Set_Entry*) prg_list_cell_data_get (list_cell_ptr);
						
				/* check if it is there in two_hop_lptr list */
				if (two_hop_addr_ptr->strict_two_hop == OPC_TRUE)
					nbr_set_entry_ptr->reachability++;
			
				}
			}
		}
		
	FOUT;
	}

static OlsrT_MPR_Set_Entry* 
olsr_rte_mpr_set_entry_get (int nbr_addr)
	{
	/* Returns the MPR set entry */
	OlsrT_MPR_Set_Entry* 	mpr_set_entry_ptr = OPC_NIL;
	
	FIN (olsr_rte_mpr_set_entry_get (int));
	
	mpr_set_entry_ptr = (OlsrT_MPR_Set_Entry*) 
		prg_bin_hash_table_item_get (mpr_set_table, &nbr_addr);
	
	FRET (mpr_set_entry_ptr);
	}


/****************************/
/*** LINK SET : FUNCTIONS ***/
/****************************/

static OlsrT_Link_Set_Entry*
olsr_rte_link_set_entry_get (int nbr_addr, int local_intf_addr)
	{
	OlsrT_Link_Set_Key				key;
	OlsrT_Link_Set_Entry*			link_set_entry_ptr;
		
	/** Determines whether an entry exists	**/
	/** in the link set for this intf_addr		**/
	FIN (olsr_rte_link_set_entry_get (<args>));

	key.nbr_intf_addr = nbr_addr;
	key.local_intf_addr = local_intf_addr;
	
	/* Get the entry for this intf_addr	*/
	link_set_entry_ptr = (OlsrT_Link_Set_Entry*) 
		prg_bin_hash_table_item_get (link_set_table, &key);
	
	FRET (link_set_entry_ptr);
	}


static OlsrT_Link_Set_Entry*
olsr_rte_link_set_entry_create (int local_intf_addr, int  nbr_intf_addr, 
								double sym_time, double asym_time, double time)
	{
	/* Adds an entry to the link set */
	OlsrT_Link_Set_Entry* 		link_set_entry_ptr;
	
	FIN (olsr_rte_link_set_entry_create (<args>));

	/* Allocate memory for the link set entry	*/
	link_set_entry_ptr = (OlsrT_Link_Set_Entry*) op_prg_pmo_alloc (link_set_entry_pmh);
	
	link_set_entry_ptr->key.local_intf_addr = local_intf_addr;
	link_set_entry_ptr->key.nbr_intf_addr = nbr_intf_addr;
	link_set_entry_ptr->SYM_time = sym_time;
	link_set_entry_ptr->ASYM_time = asym_time;
	link_set_entry_ptr->expiry_time = time;
	link_set_entry_ptr->nbr_entry_ptr = OPC_NIL;

	/* chain link set entries together */
	link_set_entry_ptr->next_link_set_entry_ptr = link_set_chain_head_ptr;
	link_set_chain_head_ptr = link_set_entry_ptr;
	
	/* Set the link set entry for this local interface 	*/
	/* address in the link set table					*/
	prg_bin_hash_table_item_insert 
		(link_set_table, &link_set_entry_ptr->key, link_set_entry_ptr, OPC_NIL);

	FRET (link_set_entry_ptr);
	}

static void
olsr_rte_symmetric_link_expiry_handle (void* v_link_set_entry_ptr, int code)	
	{
	/* Handles the expiry of a symmetric link */
	OlsrT_Link_Set_Entry* 			link_set_entry_ptr = (OlsrT_Link_Set_Entry*) v_link_set_entry_ptr;
	OlsrT_Neighbor_Set_Entry*		nbr_set_entry_ptr;

	FIN (olsr_rte_symmetric_link_expiry_handle (<args>));
	
	/* This link has become ASYMMETRIC 				*/
	/* Check the number of links to this neighbor	*/
	/* This is considered as neighbor loss if this	*/
	/* was the only link to this neighbor. 	If 		*/
	/* there is another symmetric link to this 		*/
	/* neighbor, do nothing.						*/
		
	/* Make sym_time less than current time */
	link_set_entry_ptr->SYM_time = op_sim_time () -1;
		
	/* Get the corresponding neighbor entry 	*/
	nbr_set_entry_ptr = (OlsrT_Neighbor_Set_Entry*) link_set_entry_ptr->nbr_entry_ptr;
		
	olsr_rte_graph_nbr_delete (nbr_set_entry_ptr);
	
	/* Sanity check, if no sym links, return */
	if (nbr_set_entry_ptr->sym_link_entry_count == 0)
		{
		FOUT;
		}
		
	/* Decreament the link_entry_count 		*/
	/* link_entry_count maintains the no.	*/
	/* of symmetric links for this neighbor */
	nbr_set_entry_ptr->sym_link_entry_count--;
		
	if (nbr_set_entry_ptr->sym_link_entry_count == 0)
		{
		Boolean					send_tc_flag = OPC_FALSE;
		int						j;
		int						nbr_addr;
		OlsrT_MPR_Set_Entry*	mpr_entry_ptr;
		OlsrT_MPR_Selector_Set_Entry*	mpr_selector_entry_ptr;
		
		/* This was the last symmetric link to this nbr	*/
		/* This will be considered as neighbor loss		*/
		/* Remove all two hop tuples through this nbr	*/
		/* Update MPR selector set						*/
		/* Re-calculate MPR set							*/
		/* Send additional Hello message 				*/
			
		/* For this link,get the main address			*/
		nbr_addr = olsr_support_main_addr_get (link_set_entry_ptr->key.nbr_intf_addr);
				
		/* Check how many 2 hop nodes were reachable through this nbr */				
		for (j = op_prg_list_size (&nbr_set_entry_ptr->two_hop_nbr_list)-1;j>=0;j--)
			{
			/* For each two hop address reached through this nbr */
			OlsrT_Two_Hop_Neighbor_Set_Entry *two_hop_addr_ptr =
				(OlsrT_Two_Hop_Neighbor_Set_Entry*) op_prg_list_remove (&nbr_set_entry_ptr->two_hop_nbr_list, j);
					
			/* Remove yourself from the nbr list maintained in this two hop addr entry */
			olsr_rte_remove_nbr_from_two_hop_entry (nbr_addr, two_hop_addr_ptr);
			}
				
		/* Do not free the two_hop_nbr_list list of nbr table 	*/
		/* As this nbr can become symmetric again before 		*/
		/* being removed from the nbr table and add two hop nbrs*/
				
		/* If this neighbor was in my MPR set, remove it */
		mpr_entry_ptr = (OlsrT_MPR_Set_Entry*) 
			prg_bin_hash_table_item_remove (mpr_set_table, &nbr_addr);
				
		if (mpr_entry_ptr)
			{
			op_prg_mem_free (mpr_entry_ptr);
			}
				
		/* If this neighbor was in my MPR Selector set, remove it */
		mpr_selector_entry_ptr = (OlsrT_MPR_Selector_Set_Entry*) 
			prg_bin_hash_table_item_remove (mpr_selector_set_table, &nbr_addr);
				
		if (mpr_selector_entry_ptr != OPC_NIL)
			{
			if ((op_prg_odb_ltrace_active ("mpr_trace") == OPC_TRUE))
				{
				char			tmp_str [256], node_name [256];
				InetT_Address	inet_tmp_addr = inet_rtab_index_to_addr_convert (nbr_addr);
				inet_address_print (tmp_str, inet_tmp_addr);
				inet_address_to_hname (inet_tmp_addr, node_name);
				printf ("Expired link set entry: Deleting MPR Selector %s (%s) \n", tmp_str, node_name);
				}
									
			mpr_selector_entry_ptr->mpr_selector_ptr->mpr_selector = OPC_FALSE;
			op_prg_mem_free (mpr_selector_entry_ptr);
				
			/* Check if number of mpr selectors have become zero */
			/* If yes, update the global mpr count statistics 	 */
			if (prg_bin_hash_table_num_items_get (mpr_selector_set_table) == 0)
				olsr_rte_update_global_mpr_count (OPC_FALSE);
				
			/* Mark the state variable to reflect that selector set has changed */
			selectorset_changed = OPC_TRUE;
			send_tc_flag = OPC_TRUE;
			}
					
		/* Mark the status of this neighbor as ASYMMETRIC */
		nbr_set_entry_ptr->status = OLSRC_NOT_SYM_STATUS;	
		neighborhood_changed = OPC_TRUE;
			
		/* Update the OLSR Performance. 1-hop Nbr delete statistics */
		//op_stat_write (global_stat_handles.nbr_delete_global_shandle, 1.0);
			
		/* If this function was called while processing LOST_LINK 	*/
		/* information in hello, do not perform nbrhood_topology	*/
		/* check. It will be done after processing hello anyway.	*/
		if (code != OLSRC_CONN_LOSS_TIMER)
			olsr_rte_neighborhood_topology_check ();
			
		/* send_jittered = (code == OLSRC_CONN_LOSS_TIMER) ? OPC_TRUE : OPC_FALSE; */
		/* Send an immediate Hello message here to notify this 	*/
		/* neighbor loss. OPTIONAL in RFC, not implemented here	*/
			
		/* olsr_rte_send_hello (send_jittered);					*/
			
		/* Send TC if MPR selector set has changed. Its OPTIONAL */ 
		/* in RFC. Uncomment the code to send TC immediately 	 */
		/* if (send_tc_flag)									 */
		/*	olsr_rte_send_TC (send_jittered);					 */
			
		} /*end if (nbr_set_entry_ptr->link_entry_count == 0)*/
		
	
	FOUT;
	}

static void
olsr_rte_expired_link_set_entries_remove (void)
	{
	/* Lazy method of removing all the expired link set entries */
	/* Note: The link entires which are already asymmetric are	*/
	/* kept for neighbor_hold_time. If they are not refreshed	*/
	/* by then, they are deleted.								*/	
	OlsrT_Link_Set_Entry*			link_set_entry_ptr;
	OlsrT_Link_Set_Entry*			prev_link_set_entry_ptr = OPC_NIL;
	
	FIN (olsr_rte_expired_link_set_entries_remove(void));

	/* scan thru all link set entries */
	link_set_entry_ptr = link_set_chain_head_ptr;
	while (link_set_entry_ptr)
		{
		OlsrT_Link_Set_Entry*			next_entry_ptr = link_set_entry_ptr->next_link_set_entry_ptr;
		
		/* For each entry in link set */
		if (link_set_entry_ptr->expiry_time < op_sim_time ())
			{
			/* This entry is expired 						*/
			/* First, get the corresponding neighbor entry 	*/
			OlsrT_Neighbor_Set_Entry *nbr_set_entry_ptr = (OlsrT_Neighbor_Set_Entry*)
				link_set_entry_ptr->nbr_entry_ptr;
			
			/* Decreament the link_entry_count */
			nbr_set_entry_ptr->link_entry_count--;
			
			if (nbr_set_entry_ptr->link_entry_count == 0)
				{
				/* This was the last link for this neighbor */
				/* Delete the neighbor from neighbor table  */
				/* For this get the main address, find the 	*/
				/* entry in nbr table and remove it 		*/
				int	nbr_addr = olsr_support_main_addr_get (link_set_entry_ptr->key.nbr_intf_addr);

				/* SA: Should we remove the two hop nbr entries from the two hop nbr bin hash? */
				/* Free the two_hop_nbr_list list of nbr table */
				op_prg_list_free (&nbr_set_entry_ptr->two_hop_nbr_list);
			
				/* Remove the nbr set entry from nbr set table */
				prg_bin_hash_table_item_remove (neighbor_set_table, &nbr_addr);
				op_prg_mem_free (nbr_set_entry_ptr);
				
				if (LTRACE_ACTIVE)
					{
					InetT_Address	inet_tmp_addr;
					char			tmp_str [256], node_name [256];
					
					inet_tmp_addr = inet_rtab_index_to_addr_convert (nbr_addr);
					inet_address_print (tmp_str, inet_tmp_addr);
					inet_address_to_hname (inet_tmp_addr, node_name);
					printf ("Expired link set entry: Deleting Neighbor %s (%s) \n", tmp_str, node_name);
					}
								
				} /*end if (nbr_set_entry_ptr->link_entry_count == 0)*/
			
			/* Delete the link set entry */
			prg_bin_hash_table_item_remove (link_set_table, &link_set_entry_ptr->key);
			if (prev_link_set_entry_ptr)
				{
				prev_link_set_entry_ptr->next_link_set_entry_ptr = next_entry_ptr;
				}
			else
				{
				link_set_chain_head_ptr = next_entry_ptr;
				}
			op_prg_mem_free (link_set_entry_ptr);
			}
		else
			{
			prev_link_set_entry_ptr = link_set_entry_ptr;
			}

		/* move on */
		link_set_entry_ptr = next_entry_ptr;
		}
	
	FOUT;
	}

static int
olsr_rte_link_set_sym_time_check (int intf_addr)
	{
	OlsrT_Link_Set_Entry*	link_set_entry_ptr;
	
	/* Checks the SYM_time for this interface in link set		*/
	FIN (olsr_rte_link_set_sym_time_check (int));
		
	/* Scan through the values in link set table and match the nbr_intf_addr */
	for (link_set_entry_ptr = link_set_chain_head_ptr;
		 link_set_entry_ptr;
		 link_set_entry_ptr = link_set_entry_ptr->next_link_set_entry_ptr)
		{
		/* Check if the entry is for this interface */
		if ((link_set_entry_ptr->key.nbr_intf_addr == intf_addr) &&
			(link_set_entry_ptr->SYM_time > op_sim_time ()))
			{
			FRET (OLSRC_SYM_STATUS);
			}
		}
		
	FRET (OLSRC_NOT_SYM_STATUS);
	}


/**********************************/
/** MPR SELECTOR SET : FUNCTIONS **/
/**********************************/

static void
olsr_rte_mpr_selector_set_entry_create (int nbr_addr, int vtime)
	{
	/* If entry already does not exists 	*/
	/* Adds an entry in mpr selector set 	*/
	/* else updates the expiry time			*/
	
	OlsrT_MPR_Selector_Set_Entry*	mpr_selector_set_entry_ptr = OPC_NIL;
	void*							old_contents_ptr;
	int								num_mpr_selectors = 0;
		
	FIN (olsr_rte_mpr_selector_set_entry_create (int, int));

	mpr_selector_set_entry_ptr = (OlsrT_MPR_Selector_Set_Entry*) 
		prg_bin_hash_table_item_get (mpr_selector_set_table, &nbr_addr);
	
	if (mpr_selector_set_entry_ptr != OPC_NIL)
		{
		/* Update expiry time for this entry */
		mpr_selector_set_entry_ptr->expiry_time = op_sim_time () + vtime;
		}
	else
		{
		
		/* Create new entry */
		/* Allocate memory for the mpr selector set entry	*/
		mpr_selector_set_entry_ptr = (OlsrT_MPR_Selector_Set_Entry*) op_prg_pmo_alloc (mpr_selector_set_entry_pmh);
		mpr_selector_set_entry_ptr->mpr_selector_ptr = (OlsrT_Neighbor_Set_Entry*) prg_bin_hash_table_item_get (neighbor_set_table, &nbr_addr);
		mpr_selector_set_entry_ptr->mpr_selector_ptr->mpr_selector = OPC_TRUE;
		mpr_selector_set_entry_ptr->expiry_time = op_sim_time () + vtime;
		
		num_mpr_selectors = prg_bin_hash_table_num_items_get (mpr_selector_set_table);
	
		if (num_mpr_selectors == 0)
			{
			/* This will be the first mpr selector set for this node */
			/* i.e. this node has just chosen as MPR , update global */
			/* counter for mprs										 */
			olsr_rte_update_global_mpr_count (OPC_TRUE);
			}
		
		/* Set the mpr set entry for this nbr			*/
		/* address in the mpr selector set table		*/
		prg_bin_hash_table_item_insert (mpr_selector_set_table, &nbr_addr,
			mpr_selector_set_entry_ptr, &old_contents_ptr);

		/* Mark the state variable to reflect that selector set has changed */
		selectorset_changed = OPC_TRUE;
		
		}

	FOUT;
	}

static void
olsr_rte_update_global_mpr_count (Boolean increament_mpr_count)
	{
	/* This function updates the global statistics MPR Count, 	*/
	/* which tells the number of MPRs in the network at a 		*/
	/* given time.												*/
	
	static int 			global_mpr_count = 0;
	
	FIN (olsr_rte_update_global_mpr_count (Boolean));
	
	if (increament_mpr_count)
		global_mpr_count++;
	else
		global_mpr_count--;
	
	/* Write to the global statistics */
	op_stat_write (global_stat_handles.mpr_count_global_shandle, global_mpr_count);
	
	FOUT;
	}

static void
olsr_rte_expired_mpr_selector_set_entries_remove (void)
	{
	/* Deletes the expired entries from mpr_selector_set */
	
	OlsrT_MPR_Selector_Set_Entry*		mpr_selector_entry_ptr = OPC_NIL;
	List*								keys_lptr = OPC_NIL;
	int									i, num_keys, remaining_entries;
	char								tmp_str [256], node_name [256];
	InetT_Address						inet_tmp_addr;
	
	FIN (olsr_rte_expired_mpr_selector_set_entries_remove (void));
	
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (mpr_selector_set_table);
	num_keys = op_prg_list_size (keys_lptr);
	remaining_entries = num_keys;

	for (i=0; i<num_keys; i++)
		{
		/* For each entry */
		mpr_selector_entry_ptr = (OlsrT_MPR_Selector_Set_Entry*) prg_list_access (keys_lptr, i);
		
		if (mpr_selector_entry_ptr->expiry_time < op_sim_time ())
			{
			
			if ((op_prg_odb_ltrace_active ("mpr_trace") == OPC_TRUE))
				{
				inet_tmp_addr = inet_rtab_index_to_addr_convert 
					(mpr_selector_entry_ptr->mpr_selector_ptr->nbr_addr);
				
				inet_address_print (tmp_str, inet_tmp_addr);
				inet_address_to_hname (inet_tmp_addr, node_name);
				printf ("Expired MPR Selector entry %s (%s) \n", tmp_str, node_name);
				}
			
			/* remove this entry */
			prg_bin_hash_table_item_remove (mpr_selector_set_table, &(mpr_selector_entry_ptr->mpr_selector_ptr->nbr_addr));
			mpr_selector_entry_ptr->mpr_selector_ptr->mpr_selector = OPC_FALSE;
			op_prg_mem_free (mpr_selector_entry_ptr);
			
			/* Mark the state variable to reflect that selector set has changed */
			selectorset_changed = OPC_TRUE;
			
			remaining_entries--;
			
			if (remaining_entries == 0)
				{
				/* Node's MPR status has just changed 	*/
				/* This node is not MPR anymore 		*/
				/* Update the global mpr count 			*/
				olsr_rte_update_global_mpr_count (OPC_FALSE);
				}
			}
		}
	
	/* Free keys */
	prg_list_destroy (keys_lptr, OPC_FALSE);
	
	FOUT;
	
	}
	
/******************************/
/** NEIGHBOR SET : FUNCTIONS **/
/******************************/
/** MS: DJK **/
/** For DJK support, link_set_entry_ptr is added in the function argument **/
static OlsrT_Neighbor_Set_Entry*
olsr_rte_set_neighbor_status (int nbr_addr, OlsrT_Link_Set_Entry* link_set_entry_ptr)
	{
	
	OlsrT_Neighbor_Set_Entry*	nbr_set_entry_ptr = OPC_NIL;
	int 						i;
	PrgT_Bin_Hash_Table*		intf_set_table_ptr = OPC_NIL;
	OlsrT_Interface_Set_Entry*	intf_set_entry_ptr = OPC_NIL;
	int							orig_status, two_hop_addr_num, ret_status;
	OlsrT_Two_Hop_Neighbor_Set_Entry*			two_hop_addr_ptr;
	
	/* Checks all the link entries for this nbr   	*/
	/* and set neighbor status as SYM if any of the */
	/* links is SYM, else sets this nbr as ASYM		*/
	
	FIN (olsr_rte_set_neighbor_status (int));
	
	/* Get the neighbor set entry */
	nbr_set_entry_ptr = (OlsrT_Neighbor_Set_Entry*)
		prg_bin_hash_table_item_get (neighbor_set_table, &nbr_addr);
	
	/* Get the original status */
	orig_status = nbr_set_entry_ptr->status;
		
	/* Initialize the status */
	nbr_set_entry_ptr->status = OLSRC_NOT_SYM_STATUS;
	
	/* Go through each entry in Interface table */
	/* If the main address matches the neigbor, */
	/* Check the status of that link 			*/
	/* Get the handle for interface set table	*/
	
	intf_set_table_ptr = olsr_support_interface_table_ptr_get();
	
	/* Get the interface table entry for this nbr node */
	intf_set_entry_ptr = (OlsrT_Interface_Set_Entry*) 
		prg_bin_hash_table_item_get (intf_set_table_ptr, &nbr_addr);
	
	if (intf_set_entry_ptr->type == 2)
		{
		PrgT_List_Cell * cell_ptr;
		
		/* This nbr has more than one interface */
		for (cell_ptr = prg_list_head_cell_get (intf_set_entry_ptr->intf_addr_lptr);
			 cell_ptr;
			 cell_ptr = prg_list_cell_next_get (cell_ptr))
			{
			/* For each interace of this nbr node	*/
			int * nbr_intf_addr_ptr = (int*) prg_list_cell_data_get (cell_ptr);
			
			ret_status = olsr_rte_link_set_sym_time_check (*nbr_intf_addr_ptr);
			
			if (ret_status == OLSRC_SYM_STATUS)
				{
				nbr_set_entry_ptr->status = OLSRC_SYM_STATUS;
				}
			}
		}
	else
		{
		/* type = 1, there is only one active interface for this node */
		ret_status = olsr_rte_link_set_sym_time_check (nbr_addr);
		nbr_set_entry_ptr->status = ret_status;
		}
			
	/* Now check for Neighbor loss or appearance */
	if ((orig_status == OLSRC_NOT_SYM_STATUS) &&
		(nbr_set_entry_ptr->status == OLSRC_SYM_STATUS))			
		{
		/* It is considered as neighbor appearance */
		neighborhood_changed = OPC_TRUE;

		olsr_rte_graph_nbr_add (nbr_set_entry_ptr, link_set_entry_ptr);
		
		/* Update the OLSR Performance. 1-hop Nbr add statistics */
		op_stat_write (global_stat_handles.nbr_add_global_shandle, 1.0);
		}
		
	/* If the status has changed from SYM to NOT_SYM 	*/
	/* remove nbr address from all two hop nbr entries 	*/
	if ((orig_status == OLSRC_SYM_STATUS) && 
		(nbr_set_entry_ptr->status == OLSRC_NOT_SYM_STATUS ))
		{
		/* It is considered as neighbor loss */
		neighborhood_changed = OPC_TRUE;
				
		olsr_rte_graph_nbr_delete (nbr_set_entry_ptr);

		/* Update the OLSR Performance. 1-hop Nbr delete statistics */
		//op_stat_write (global_stat_handles.nbr_delete_global_shandle, 1.0);
				
		two_hop_addr_num = op_prg_list_size (&nbr_set_entry_ptr->two_hop_nbr_list);
			
		for (i= two_hop_addr_num -1; i >=0; i--)
			{
			/* For each two hop address */
			two_hop_addr_ptr = (OlsrT_Two_Hop_Neighbor_Set_Entry*) op_prg_list_remove 
				(&nbr_set_entry_ptr->two_hop_nbr_list, i);
				
			/* Remove this nbr address from the two hop entry */
			olsr_rte_remove_nbr_from_two_hop_entry (nbr_addr, two_hop_addr_ptr);
				
			/* We are not going to remove the two_hop_nbr_vptr 	*/
			/* as this nbr may again become SYM and add 		*/
			/* two hop addrs to its two_hop_nbr_vptr			*/
			}
		}
	
	FRET (nbr_set_entry_ptr);
	
	}


static OlsrT_Neighbor_Set_Entry*
olsr_rte_neighbor_set_entry_get (int nbr_addr)
	{
	
	OlsrT_Neighbor_Set_Entry* 	nbr_set_entry_ptr = OPC_NIL;
	
	FIN (olsr_rte_neighbor_set_entry_get (int));
	
	/** Determines whether an entry exists			**/
	/** in the neighbor set for this nbr_addr		**/
	
	/* Create the neighbor address string	*/
			
	/* Get the entry for this intf_addr	*/
	nbr_set_entry_ptr = (OlsrT_Neighbor_Set_Entry*) 
		prg_bin_hash_table_item_get (neighbor_set_table, &nbr_addr);
	
	FRET (nbr_set_entry_ptr);
	}

static OlsrT_Neighbor_Set_Entry*
olsr_rte_neighbor_set_entry_create (int nbr_addr, int status, int will, int energ)
	{
	/* Adds an entry to the link set */
	OlsrT_Neighbor_Set_Entry* 		nbr_set_entry_ptr = OPC_NIL;
	void*							old_contents_ptr;
		
	FIN (olsr_rte_neighbor_set_entry_create (<args>));

	/* Create the local interface address string	*/
	
	/* Allocate memory for the link set entry	*/
	nbr_set_entry_ptr = (OlsrT_Neighbor_Set_Entry*) op_prg_pmo_alloc (nbr_set_entry_pmh);
	
	nbr_set_entry_ptr->nbr_addr = nbr_addr;
	nbr_set_entry_ptr->status = status;
	nbr_set_entry_ptr->willingness = will;
	nbr_set_entry_ptr->link_entry_count = 0;
	nbr_set_entry_ptr->sym_link_entry_count = 0;
	nbr_set_entry_ptr->reachability = OLSRC_VALUE_CLEAR;
	nbr_set_entry_ptr->mpr_selector = OPC_FALSE;
	
/**************************************************************/
	nbr_set_entry_ptr->stabilite.SDN=0.0;
	nbr_set_entry_ptr->val_signal.nbr_msg_recevu=0;
	nbr_set_entry_ptr->conf=0;
	nbr_set_entry_ptr->val_signal.temps1=op_sim_time();
    nbr_set_entry_ptr->val_signal.temps2=op_sim_time();
	
	
	
/**************************************************************/
	nbr_set_entry_ptr->energie=energ;
	/**/
	
	/* Set the link set entry for this local interface 	*/
	/* address in the link set table					*/
	prg_bin_hash_table_item_insert
		(neighbor_set_table, &nbr_addr, nbr_set_entry_ptr,&old_contents_ptr);
	
	FRET (nbr_set_entry_ptr);
	}

static void
olsr_rte_update_neighbor_set_table (int two_hop_addr, OlsrT_Neighbor_Set_Entry* nbr_set_entry_ptr)
	{
	/* This function is called to remove two_hop_addr from the 	*/
	/* nbr table entry of neighbor_addr. It updates the neighbor*/
	/* table by deleting the entry for two hop addr from its 	*/
	/* list of two hop reachable addresses 						*/
	int 						j, two_hop_num;
	OlsrT_Two_Hop_Neighbor_Set_Entry*		two_hop_ptr;
	
	FIN (olsr_rte_update_neighbor_set_table (<args>));
				
	if (nbr_set_entry_ptr != OPC_NIL)
		{
		/* Find my two hop address there */
		two_hop_num = op_prg_list_size (&nbr_set_entry_ptr->two_hop_nbr_list);
		
		for (j=two_hop_num -1; j>=0;j--)
			{
			two_hop_ptr = (OlsrT_Two_Hop_Neighbor_Set_Entry*) op_prg_list_access 
				(&nbr_set_entry_ptr->two_hop_nbr_list, j);
			
			if (two_hop_addr == two_hop_ptr->two_hop_addr)
				{
				/* found my two hop address in the list */
				op_prg_list_remove (&nbr_set_entry_ptr->two_hop_nbr_list, j);
				}
			}
		}
	
	FOUT;
	
	}

/**************************************/
/** TWO HOP NEIGHBOR SET : FUNCTIONS **/
/*************************************/

static void
olsr_rte_two_hop_nbr_set_entry_create (int two_hop_addr, int nbr_addr,double SDN ,int vtime)
	{
	/* This function first checks if an entry already exisits,	*/
	/* if yes, then changes the expiry time, else creates a new	*/
	/* entry to the two hop neighbor set 						*/
	
	OlsrT_Two_Hop_Neighbor_Set_Entry* 	two_hop_entry_ptr;
	Boolean								olsrc_created_new = OPC_FALSE;
	OlsrT_Neighbor_Set_Entry*			nbr_set_entry_ptr;
	OlsrT_Nbr_Addr_Two_Hop_Entry*		nbr_addr_entry_ptr;
	
	FIN (olsr_rte_two_hop_nbr_set_entry_create (int, int, int));
		
	
	
	
	
	/* Get the entry for this nbr_addr	*/
	two_hop_entry_ptr = (OlsrT_Two_Hop_Neighbor_Set_Entry*) 
		prg_bin_hash_table_item_get (two_hop_nbr_set_table, &(two_hop_addr));
		
	/* Neighbor addr and 2 hop address both should match,	*/
	/* else new entry is created 							*/
	if (two_hop_entry_ptr != OPC_NIL)
		{
		/* Find neighbor */
		nbr_addr_entry_ptr = (OlsrT_Nbr_Addr_Two_Hop_Entry*)
			prg_bin_hash_table_item_get (two_hop_entry_ptr->neighbor_hash_ptr, &nbr_addr);

		if (nbr_addr_entry_ptr)
			{				
			/* This neighbor is already there in the list 	*/
			/* Update the expiry time and RETURN			*/
			op_ev_cancel_if_pending (nbr_addr_entry_ptr->two_hop_expiry_evhandle);
						
			/* Schedule the interrupt for sym link expiry */
			nbr_addr_entry_ptr->two_hop_expiry_evhandle = op_intrpt_schedule_call (op_sim_time () + vtime, 
				OLSRC_TWO_HOP_EXPIRY, olsr_rte_two_hop_expiry_handle, nbr_addr_entry_ptr);
			
			
			nbr_addr_entry_ptr->SDN=SDN;
//		printf("\ntwo ops SDN %g",nbr_addr_entry_ptr->SDN);
			
			/* return, no two hop neighborhood change */
			FOUT;
			}
		}
	else
		{
		/* Create new entry. Allocate memory for the two hop nbr set entry	*/
		two_hop_entry_ptr = (OlsrT_Two_Hop_Neighbor_Set_Entry*) op_prg_pmo_alloc (two_nbr_set_entry_pmh);
		two_hop_entry_ptr->two_hop_addr = two_hop_addr;
		two_hop_entry_ptr->SDN=SDN;
		two_hop_entry_ptr->neighbor_hash_ptr = prg_bin_hash_table_create (4, 4);
		
		olsrc_created_new = OPC_TRUE;
						
		if ((op_prg_odb_ltrace_active ("trace_hello") == OPC_TRUE))
			{
			char				tmp_str [256], node_name [256];
			InetT_Address		inet_tmp_addr;
			
			inet_tmp_addr = inet_rtab_index_to_addr_convert (two_hop_addr);
			inet_address_print (tmp_str, inet_tmp_addr);
			inet_address_to_hname (inet_tmp_addr, node_name);
			printf ("2 hop neighbor entry added for %s (%s) \n", tmp_str, node_name);
			}
		
		/* Set the neighbor set entry for this nbr_addr 	*/
		/* address in the neighbor set table				*/
		prg_bin_hash_table_item_insert 
			(two_hop_nbr_set_table, &two_hop_addr, two_hop_entry_ptr, OPC_NIL);

		olsr_rte_graph_two_hop_nbr_add (nbr_addr, two_hop_entry_ptr);
		}
	
	/* Reached here means:					*/
	/* (1) Either two hop nbr entry existed */
	/* and nbr_addr not present in 			*/
	/* neighbor_lptr of two hop entry OR	*/
	/* (2) New entry created				*/
	
	/* Add the neighbor in neighbor_lptr 	*/
	/* with correct expiry time. Also add 	*/
	/* this two hop nbr	to the nbr's two 	*/
	/* hop nbr list in the nbr table entry 	*/

	nbr_set_entry_ptr = olsr_rte_neighbor_set_entry_get (nbr_addr);
	nbr_addr_entry_ptr = (OlsrT_Nbr_Addr_Two_Hop_Entry*) op_prg_pmo_alloc (nbr_addr_set_entry_pmh);
	
	nbr_addr_entry_ptr->nbr_ptr = nbr_set_entry_ptr;
	nbr_addr_entry_ptr->two_hop_addr = two_hop_addr;
	nbr_addr_entry_ptr->SDN=SDN;

	/* Schedule the expiry interrupt for this two hop entry */
	nbr_addr_entry_ptr->two_hop_expiry_evhandle = op_intrpt_schedule_call (op_sim_time () + vtime,
		OLSRC_TWO_HOP_EXPIRY, olsr_rte_two_hop_expiry_handle, nbr_addr_entry_ptr);
	
	/* Add this Nbr info into neighbor_list of two hop entry */
	op_prg_list_insert (&two_hop_entry_ptr->neighbor_list, nbr_addr_entry_ptr, PRGC_LISTPOS_TAIL);
	/* put a reference to hashed neighbor set too */
	prg_bin_hash_table_item_insert (two_hop_entry_ptr->neighbor_hash_ptr,
		&nbr_addr, nbr_addr_entry_ptr, OPC_NIL);
			
	op_prg_list_insert (&nbr_set_entry_ptr->two_hop_nbr_list, two_hop_entry_ptr, PRGC_LISTPOS_TAIL);
	
	/* Mark change in neighborhood only when this was a strict two hop nbr 	*/
	/* Check if this two hop nbr addr is present in nbr table 				*/
	if ((nbr_set_entry_ptr = olsr_rte_neighbor_set_entry_get (two_hop_addr)) == OPC_NIL)
		{
		neighborhood_changed = OPC_TRUE;
		
		if (olsrc_created_new)
			{
			/* Update the OLSR Performance. Two Hop Nbr Add statistics */
			op_stat_write (global_stat_handles.two_hop_add_global_shandle, 1.0);
			}
		else
			{
			/* Update the OLSR Performance. Two Hop Nbr reachability changed statistics */
			op_stat_write (global_stat_handles.two_hop_reachability_add_global_shandle, 1.0);
			}					
			
		}

	FOUT;
	}

static void
olsr_rte_remove_nbr_from_two_hop_entry (int nbr_addr, OlsrT_Two_Hop_Neighbor_Set_Entry* two_hop_set_entry_ptr)
	{
	/* Removes the nbr_addr from two hop addr entry	*/
	/* Given nbr_addr is either is no more neighbor,*/
	/* or its status has become NOT_SYM.  		 	*/	
	FIN (olsr_rte_remove_nbr_from_two_hop_entry (int, OlsrT_Two_Hop_Neighbor_Set_Entry*));
	
	if (op_prg_odb_ltrace_active ("olsr_crash"))
		{
		InetT_Address		inet_two_hop_addr;
		InetT_Address 		remove_nbr_address;
		char				two_hop_str [256];
		char				remove_nbr_str [256];
		
		inet_two_hop_addr = inet_rtab_index_to_addr_convert (two_hop_set_entry_ptr->two_hop_addr);
		inet_address_print (two_hop_str, inet_two_hop_addr);
		
		remove_nbr_address = inet_rtab_index_to_addr_convert (nbr_addr);
		inet_address_print (remove_nbr_str, remove_nbr_address);
		
		printf ("\nProblematic two hop address: %s, removing neighbor %s", two_hop_str, remove_nbr_str);
		}
	
	/* Get the two hop nbr set entry */
	if (two_hop_set_entry_ptr != OPC_NIL)
		{
		/* Two hop entry exists 	*/
		/* Remove yourself from the	*/
		/* nbr list maintained in 	*/
		/* this two hop entry 		*/
		OlsrT_Nbr_Addr_Two_Hop_Entry* nbr_addr_entry_ptr = (OlsrT_Nbr_Addr_Two_Hop_Entry *)
			prg_bin_hash_table_item_remove (two_hop_set_entry_ptr->neighbor_hash_ptr, &nbr_addr);

		if (nbr_addr_entry_ptr)
			{
			PrgT_List_Cell * cell_ptr;
			
			/* remove myself from the list*/

			/* First cancel the pending intrpt */
			op_ev_cancel_if_pending (nbr_addr_entry_ptr->two_hop_expiry_evhandle);

			/* Remove and free this entry from the list */
			/* The nbr ptr inside nbr_addr_entry_ptr will still be valid */
			/* It can still be referenced through the bin_hash neighbor_set_table */
			/* Delete this neighbor entry from two hop addr list */
			for (cell_ptr = prg_list_head_cell_get (&two_hop_set_entry_ptr->neighbor_list);
				 cell_ptr;
				 cell_ptr = prg_list_cell_next_get (cell_ptr))
				{
				if (prg_list_cell_data_get (cell_ptr) == nbr_addr_entry_ptr)
					{
					prg_list_cell_remove (&two_hop_set_entry_ptr->neighbor_list, cell_ptr);
					break;
					}
				}
			op_prg_mem_free (nbr_addr_entry_ptr);

			/* see if neighbor list became empty */
			if (1==2) //(two_hop_set_entry_ptr->neighbor_list.size == 0)
				{
				/* No element in this vector i.e. this 	*/
				/* 2 hop neighbor cannot be reached 	*/
				/* anymore, delete two hop entry 		*/
			
				/* Not adding towards 2-hop nbr delete stats, since  */
				/* 1-hop nbr delete is the reason for nbrhood change */
				prg_bin_hash_table_destroy (two_hop_set_entry_ptr->neighbor_hash_ptr, OPC_NIL);
				prg_bin_hash_table_item_remove (two_hop_nbr_set_table, &(two_hop_set_entry_ptr->two_hop_addr));
				op_prg_mem_free (two_hop_set_entry_ptr);
				}
			}
		}/*end if two_hop_entry != OPC_NIL*/
	
	FOUT;
	}
		
static void
olsr_rte_two_hop_expiry_handle (void* ptr1, int PRG_ARG_UNUSED (code))
	{
	OlsrT_Nbr_Addr_Two_Hop_Entry*		nbr_addr_entry_ptr = (OlsrT_Nbr_Addr_Two_Hop_Entry *) ptr1;
	OlsrT_Two_Hop_Neighbor_Set_Entry*	two_hop_entry_ptr;
	PrgT_List_Cell *					cell_ptr;
	
	FIN (olsr_rte_two_hop_expiry_handle (<args>));
		
	/* Get two hop entry */
	two_hop_entry_ptr = (OlsrT_Two_Hop_Neighbor_Set_Entry*) 
		prg_bin_hash_table_item_get (two_hop_nbr_set_table, &(nbr_addr_entry_ptr->two_hop_addr));
		
	/* Expired 2 hop-neighbor relationship 	*/
	/* This 2 hop is not reachable through 	*/
	/* this neigbhor anymore			 	*/	
	olsr_rte_graph_two_hop_nbr_delete (nbr_addr_entry_ptr->nbr_ptr->nbr_addr, two_hop_entry_ptr->two_hop_addr);
				
	/* Remove this two hop from the neighbor table */
	olsr_rte_update_neighbor_set_table 
		(two_hop_entry_ptr->two_hop_addr, nbr_addr_entry_ptr->nbr_ptr);
				
	/* Delete this neighbor entry from two hop addr list & two hop neighbors hash */
	prg_bin_hash_table_item_remove (two_hop_entry_ptr->neighbor_hash_ptr, &nbr_addr_entry_ptr->nbr_ptr->nbr_addr);
	
	for (cell_ptr = prg_list_head_cell_get (&two_hop_entry_ptr->neighbor_list);
		 cell_ptr;
		 cell_ptr = prg_list_cell_next_get (cell_ptr))
		{
		if (prg_list_cell_data_get (cell_ptr) == nbr_addr_entry_ptr)
			{
			prg_list_cell_remove (&two_hop_entry_ptr->neighbor_list, cell_ptr);
			break;
			}
		}
				
	op_prg_mem_free (nbr_addr_entry_ptr);
				
	if (LTRACE_ACTIVE)
		{
		InetT_Address	inet_tmp_addr;
		char			tmp_str [256], node_name [256];
		
		inet_tmp_addr = inet_rtab_index_to_addr_convert (two_hop_entry_ptr->two_hop_addr);
		inet_address_print (tmp_str, inet_tmp_addr);
		inet_address_to_hname (inet_tmp_addr, node_name);
		printf ("One of the NBR expired to reach this TWO-HOP-NBR %s (%s) \n", tmp_str, node_name);
		}
				
	/* If this change was in a strict 2-hop nbr, mark neighborhood change */
	if (prg_bin_hash_table_item_get (neighbor_set_table, &(two_hop_entry_ptr->two_hop_addr)) == OPC_NIL)
		{
		neighborhood_changed = OPC_TRUE;
		
		/* Update the OLSR Performance. Two Hop Nbr reachability changed statistics */
		op_stat_write (global_stat_handles.two_hop_reachability_del_global_shandle, 1.0);
		}
							
	/* Before moving on to next entry, check if this entry is still valid */
	if (1==2)//(two_hop_entry_ptr->neighbor_list.size == 0)
		{
		if (LTRACE_ACTIVE)
			{
			InetT_Address	inet_tmp_addr;
			char			tmp_str [256], node_name [256];
			
			inet_tmp_addr = inet_rtab_index_to_addr_convert (two_hop_entry_ptr->two_hop_addr);
			inet_address_print (tmp_str, inet_tmp_addr);
			inet_address_to_hname (inet_tmp_addr, node_name);
			printf ("Deleting 2 hop neighbor entry for %s (%s) \n", tmp_str, node_name);
			}
			
		/* Not updating 2-hop nbr delete since 1-hop nbr */
		/* loss is the main reason for nbrhood change.	 */
		prg_bin_hash_table_item_remove (two_hop_nbr_set_table, &(two_hop_entry_ptr->two_hop_addr));
		prg_bin_hash_table_destroy (two_hop_entry_ptr->neighbor_hash_ptr, OPC_NIL);
		op_prg_mem_free (two_hop_entry_ptr);
		}
		
	FOUT;	
	}

static void
olsr_rte_two_hop_nbr_set_entry_match_n_delete (int two_hop_addr, int nbr_addr)
	{
	/* Deletes all the entires that have matching nbr_addr */
	OlsrT_Two_Hop_Neighbor_Set_Entry* 	two_hop_entry_ptr;
	
	FIN (olsr_rte_two_hop_nbr_set_entry_match_n_delete( int, int));
		
	/* Get the two hop addr entry */
	two_hop_entry_ptr = (OlsrT_Two_Hop_Neighbor_Set_Entry*) 
		prg_bin_hash_table_item_get (two_hop_nbr_set_table, &two_hop_addr);
	
	/* Neighbor addr and 2 hop address both should match,	*/
	if(two_hop_entry_ptr != OPC_NIL)
		{
		OlsrT_Nbr_Addr_Two_Hop_Entry* addr_ptr = (OlsrT_Nbr_Addr_Two_Hop_Entry*)
			prg_bin_hash_table_item_remove (two_hop_entry_ptr->neighbor_hash_ptr, &nbr_addr);
		
		if (addr_ptr)
			{
			PrgT_List_Cell *					cell_ptr;
			
			/* This neighbor is there in the list 		*/
			/* delete this entry from the neighbor_lptr */
			olsr_rte_graph_two_hop_nbr_delete (nbr_addr, two_hop_entry_ptr->two_hop_addr);

			/* First cancel the pending intrp */
			op_ev_cancel_if_pending (addr_ptr->two_hop_expiry_evhandle);
		
			/* Remove this entry from the list */
			for (cell_ptr = prg_list_head_cell_get (&two_hop_entry_ptr->neighbor_list);
				 cell_ptr;
				 cell_ptr = prg_list_cell_next_get (cell_ptr))
				{
				if (prg_list_cell_data_get (cell_ptr) == addr_ptr)
					{
					prg_list_cell_remove (&two_hop_entry_ptr->neighbor_list, cell_ptr);
					break;
					}
				}
				
			olsr_rte_update_neighbor_set_table (two_hop_addr, addr_ptr->nbr_ptr);
				
			/* Destroy this neighbor from two hop table entry */
			op_prg_mem_free (addr_ptr);
				
			/* If this change was in a strict 2-hop nbr, mark neighborhood change */
			if (prg_bin_hash_table_item_get (neighbor_set_table, &two_hop_addr) == OPC_NIL)
				{
				neighborhood_changed = OPC_TRUE;
					
				/* Update the OLSR Performance. Two Hop Nbr reachability changed statistics */
				op_stat_write (global_stat_handles.two_hop_reachability_del_global_shandle, 1.0);
				}
			
			if (1==2)//(two_hop_entry_ptr->neighbor_list.size == 0)
				{
				if ((op_prg_odb_ltrace_active ("trace_hello") == OPC_TRUE))
					{
					char			tmp_str [256], node_name [256];
					InetT_Address	inet_tmp_addr;
				
					inet_tmp_addr = inet_rtab_index_to_addr_convert (two_hop_addr);
					inet_address_print (tmp_str, inet_tmp_addr);
					inet_address_to_hname (inet_tmp_addr, node_name);
					printf ("2 hop neighbor entry deleted for %s (%s) \n", tmp_str, node_name);
					}
			
				/* Not updating 2-hop nbr delete since 1-hop nbr */
				/* loss is the main reason for nbrhood change.	 */
			
				prg_bin_hash_table_item_remove (two_hop_nbr_set_table, &two_hop_addr);
				prg_bin_hash_table_destroy (two_hop_entry_ptr->neighbor_hash_ptr, OPC_NIL);
				op_prg_mem_free (two_hop_entry_ptr);			
				}
			}
		}
		
	FOUT;
	}

	
/*********************************/
/******* TC SET : FUNCTIONS ******/
/*********************************/
	
static OlsrT_TC_Dest_Addr_Entry*
olsr_rte_tc_dest_addr_entry_create (PrgT_Vector* mprs_addr_vptr, int rcvd_seq_num, PrgT_Vector* SDN_vptr)///////////////// add the vector of SDN to the toplogy /////////////////////////////
	{
	/* Creates TC Addr Entry */
	OlsrT_TC_Dest_Addr_Entry*		dest_addr_entry_ptr;
	int								i, num_size;
	int*							dest_addr_ptr;
	int*							mprs_addr_ptr;
	double*                         SDN_ptr;
		
	FIN (olsr_rte_tc_dest_addr_entry_create (<args>));
		
	/* Allocate the tc entry from the pooled memory	*/
	dest_addr_entry_ptr = (OlsrT_TC_Dest_Addr_Entry*) op_prg_pmo_alloc (dest_entry_pmh);
		
	/* Insert all the addresses from mprs_addr_vptr*/
	num_size = prg_vector_size (mprs_addr_vptr);
	
	for (i=0; i< num_size; i++)
		{
		
		
		mprs_addr_ptr = (int*) prg_vector_access (mprs_addr_vptr, i);
		SDN_ptr=  (double *) prg_vector_access (SDN_vptr, i);
		
		dest_addr_ptr = olsr_rte_address_create (*mprs_addr_ptr);
		op_prg_list_insert (&dest_addr_entry_ptr->dest_addr_list,dest_addr_ptr, PRGC_LISTPOS_TAIL);
		op_prg_list_insert (&dest_addr_entry_ptr->SDN_list,SDN_ptr, PRGC_LISTPOS_TAIL);/////////////////////////////////////////////
		}
	
	dest_addr_entry_ptr->tc_seq_num = rcvd_seq_num;
	
	FRET (dest_addr_entry_ptr);
	}


static void 
olsr_rte_tc_dest_addr_entry_destroy (void* entry)
	{
	/* Function to free the memory allocated for TC_Dest_Addr_Entry */
	
	OlsrT_TC_Dest_Addr_Entry*		dest_addr_entry_ptr;
	
	FIN (olsr_rte_tc_dest_addr_entry_destroy (void));
	
	/* Go through each element of the list and destroy the dest_addr */
	dest_addr_entry_ptr = (OlsrT_TC_Dest_Addr_Entry*) entry;
	op_prg_list_free (&dest_addr_entry_ptr->dest_addr_list);
	op_prg_list_free (&dest_addr_entry_ptr->SDN_list);   //////////////////// destroy the list of SDN ///////////////////////////////////
	op_prg_mem_free (dest_addr_entry_ptr);
	
	FOUT;
	}

static void
olsr_rte_expired_tc_entries_remove (void)
	{
	/* Deletes expired entries from TC table */
	/* Each vector in each entry is a sorted List */
	
	OlsrT_TC_Set_Entry*			tc_entry_ptr = OPC_NIL;
	List*						keys_lptr = OPC_NIL;
	int							num_keys, i;
	double						expiry_time;
	Boolean						tmp_var;
	InetT_Address				inet_tmp_addr;
	char						tmp_str [256], node_name [256];
		
	FIN (olsr_rte_expired_tc_entries_remove (void));
	
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (tc_set_table);
	num_keys = op_prg_list_size (keys_lptr);
	
	expiry_time = OLSRC_INFINITE_VALUE;
		
	for (i=0; i<num_keys; i++)
		{
		/* For each entry (last addr) in tc set table */
		tc_entry_ptr = (OlsrT_TC_Set_Entry*) op_prg_list_access (keys_lptr, i);
		
		if (tc_entry_ptr->tc_time < op_sim_time())
			{
			if (LTRACE_ACTIVE)
				{
				inet_tmp_addr = inet_rtab_index_to_addr_convert (tc_entry_ptr->last_addr);
				inet_address_print (tmp_str, inet_tmp_addr);
				inet_address_to_hname (inet_tmp_addr, node_name);
				printf ("Expired TC entry %s (%s) \n", tmp_str, node_name);
				}

			olsr_rte_graph_tc_delete (tc_entry_ptr);

			tmp_var = oms_topo_table_item_remove (topo_table_hndl, tc_entry_ptr->last_addr, tc_entry_ptr->tc_seq_num);

			prg_bin_hash_table_item_remove (tc_set_table, &(tc_entry_ptr->last_addr));
			op_prg_mem_free (tc_entry_ptr);
			
			/* Topology set has changed, set the flag */
			topology_changed = OPC_TRUE;
			}
		else
			{
			/* Update for the minimum expiry time in tc set */
			if (expiry_time > tc_entry_ptr->tc_time)
				{
				expiry_time = tc_entry_ptr->tc_time;
				tc_entry_expiry_time = tc_entry_ptr->tc_time;
				}
			}
			
		}/*end for*/

	/* Free the list memory without destroying values */
	prg_list_destroy (keys_lptr, OPC_FALSE);
	
	FOUT;
	}


/****************************/
/********** OTHERS **********/
/****************************/

static void
olsr_rte_breakup_linkcode (int linkcode, int* link, int* nbr)
	{
	/* Returns the Link Type and Neighbor Type 	*/
	/* for the given Linkcode value				*/
	
	int 	mask_link=12;
	int 	mask_nbr=3;
		
	FIN (olsr_rte_breakup_linkcode (int, int*, int* ));
	
	*link = linkcode & mask_link;
	*link >>=2;
	*nbr = linkcode & mask_nbr;
	
	FOUT;
	
	}

static int
olsr_rte_find_myself_in_hello_msg (PrgT_Vector* hello_msg_data_vptr, int addr)
	{
	/* Parses through the list of interface addresses	*/
	/* in the hello msg and check if "addr" is listed	*/
	/* in it. If yes, returns the corresponding 		*/
	/* linkcode, else returns OLSRC_ADDR_NOT_FOUND = -99*/
	
	OlsrT_Hello_Message_Data*	hello_msg_data = OPC_NIL;
	PrgT_Vector*				intf_addr_vptr = OPC_NIL;
	int 						i,j,linkcode = OLSRC_ADDR_NOT_FOUND;
	int							intf_addr_num = 0;
	int							hello_msg_data_num = 0;
	int*						intf_addr_ptr;
	
	FIN (olsr_rte_find_myself_in_hello_msg (PrgT_Vector* , int ));
	
	/* Get the number of hello_msg_data */
	hello_msg_data_num = prg_vector_size (hello_msg_data_vptr);
	
	/* For each hello_msg_data */
	for (i=0; i < hello_msg_data_num; i++)
		{
		/* Get hello msg data */
		hello_msg_data = (OlsrT_Hello_Message_Data*) 
			prg_vector_access (hello_msg_data_vptr, i);
		
		/* Get list of interface address in the data */
		intf_addr_vptr = (PrgT_Vector*) hello_msg_data->nbr_intf_addr_vptr;
		
		/* Get the number of interface address */
		intf_addr_num = prg_vector_size (intf_addr_vptr);
		
		/* For each of the interface addresses */
		for (j=0; j < intf_addr_num; j++)
			{
			intf_addr_ptr = (int*) prg_vector_access (intf_addr_vptr, j);
			
			/* If "addr" is found */
			if (addr == *intf_addr_ptr)
				{
				/* Get the linkcode for this hello msg data */
				linkcode = hello_msg_data->linkcode;
				
				FRET (linkcode);
				}
			}
		}
		
	FRET (linkcode);
	}


/************************************************/
/********* Packet Support functions *************/
/************************************************/

static OlsrT_TC_Message*
olsr_pkt_support_tc_message_create (void)
	{
	OlsrT_TC_Message*		tc_msg_ptr;
	
	/** Allocates pooled memory for the tc_msg **/
	FIN (olsr_pkt_support_tc_message_create (void));
		
	/* Allocate the tc message from the pooled memory	*/
	tc_msg_ptr = (OlsrT_TC_Message*) op_prg_pmo_alloc (tc_msg_pmh);
	
	/* Create an empty vector for the mpr selector addresses */
	/* to be carried by this TC message */
	tc_msg_ptr->mpr_nodes_vptr = prg_vector_create (1, OPC_NIL, OPC_NIL);
	tc_msg_ptr->mpr_nodes_SDN_vptr = prg_vector_create (1, OPC_NIL, OPC_NIL);//////////////////// Create an empty vector for the SDN ///////////////////////////
		 
	FRET (tc_msg_ptr);
	}


static Packet*
olsr_pkt_support_pkt_create (OlsrT_Message* olsr_message_ptr, int seq_num)
	{
	Packet*			olsr_pkptr;
	int				packet_length =0;
	
	/** Creates OLSR packet by taking list of 	 **/
	/** OLSR messages and adding olsr pkt header **/
		
	FIN (olsr_pkt_support_pkt_create (<args>));
	
	/* Get the size of the message */
	packet_length = olsr_message_ptr->message_size;
	
	/* Add the size of packet header : OlsrT_Message = 96 bits for  */
	/* IPv4 or 192 bits for IPv6. 									*/
	/* OlsrT_Message: msg_type (8) + Vtime (8) + Msg_size (16) + 	*/
	/* Orig_addr (32 or 128, if IPv4 or IPv6 respectively) +TTL (8) */
	/* + Hop_count (8) + Msg_Seq_Num (16)							*/
	packet_length += (is_ipv6_enabled? 192:96);
	
	/* Create the OLSR packet	*/
	olsr_pkptr = op_pk_create_fmt ("olsr");
	
	/* Set the options in the packet	*/
	op_pk_nfd_set_ptr (olsr_pkptr, "Message", olsr_message_ptr, 
		olsr_rte_olsr_message_copy, olsr_rte_olsr_message_destroy, sizeof (OlsrT_Message));
	
	/* Set the packet length */
	op_pk_nfd_set_int32 (olsr_pkptr, "Packet Length", packet_length);
	op_pk_nfd_set_int32 (olsr_pkptr, "Packet Sequence Number", seq_num);
	
	/* Model the size of this packet */
	op_pk_bulk_size_set (olsr_pkptr, packet_length);
	
	FRET (olsr_pkptr);
	}

static OlsrT_Message*
olsr_pkt_support_olsr_message_create (void* olsr_msg_data_ptr, int originator_addr, 
	int msg_size, int seq_num, int msg_type, double vtime, int ttl, int hop_count, Boolean is_ipv6)
	{
	OlsrT_Message*	olsr_message_ptr;
	/** Creates an OLSR message by taking the OLSR message			 	**/
	/** data (can be Hello, TC, MID) and adding OLSR message header		**/	
	FIN (olsr_pkt_support_olsr_message_create (<args>));
	
	/* Allocate memory for the hello message header	**/
	olsr_message_ptr = (OlsrT_Message*) op_prg_pmo_alloc (olsr_msg_pmh);
		
	olsr_message_ptr->message_type 			= msg_type;
	olsr_message_ptr->message_size 			= msg_size;
	olsr_message_ptr->ttl 					= ttl;
	olsr_message_ptr->hop_count 			= hop_count;
	olsr_message_ptr->originator_addr 		= originator_addr;
	olsr_message_ptr->message_seq_num 		= seq_num;
	olsr_message_ptr->vtime 				= vtime;
	olsr_message_ptr->message 				= olsr_msg_data_ptr;
	olsr_message_ptr->is_ipv6 				= is_ipv6; 
	
	FRET (olsr_message_ptr);	
	}

static void*
olsr_rte_olsr_message_copy (void* message_ptr, size_t PRG_ARG_UNUSED (size))
    {
	OlsrT_Message* 				olsr_message_ptr = (OlsrT_Message*) message_ptr;
	OlsrT_Hello_Message*		hello_message_ptr;
	OlsrT_Message* 				copy_olsr_message_ptr;
	
	/* Makes a copy of the OlsrT Message */
	FIN (olsr_rte_olsr_message_copy (<args>));
 
	hello_message_ptr = (OlsrT_Hello_Message*) olsr_message_ptr->message;
	
	/* Each Message (Hello, MID, TC) has ref_count fields first	*/
	/* which indicated how many other process is referencing	*/
	/* this same packet 										*/
	prg_mt_spinlock_acquire (&hello_message_ptr->ref_count_lock);
	hello_message_ptr->ref_count++;
	prg_mt_spinlock_release (&hello_message_ptr->ref_count_lock);
	
	/* Just make the copy of the OlsrT_Message */
	copy_olsr_message_ptr = olsr_pkt_support_olsr_message_create (olsr_message_ptr->message, 
							olsr_message_ptr->originator_addr, olsr_message_ptr->message_size,
							olsr_message_ptr->message_seq_num, olsr_message_ptr->message_type,
							olsr_message_ptr->vtime, olsr_message_ptr->ttl, olsr_message_ptr->hop_count, 
							olsr_message_ptr->is_ipv6);
	
	FRET ((void*) copy_olsr_message_ptr);
	
	}


static void
olsr_rte_olsr_message_destroy (void* message_ptr)
    {
	
	/* Destroys the Olsr Message depeding upon the message type */
	OlsrT_Message* 				olsr_message_ptr = (OlsrT_Message*) message_ptr;
	OlsrT_Hello_Message*		hello_msg_ptr;
	OlsrT_MID_Message*			mid_msg_ptr;
	PrgT_Vector*				hello_msg_data_vptr;	
	OlsrT_Hello_Message_Data*	hello_msg_data_ptr;
	OlsrT_TC_Message*			tc_msg_ptr;
	int 						hello_msg_data_num;
	PrgT_Vector*				intf_addr_vptr;
	PrgT_Vector*				intf_SDN_vptr;/*******************************************/
	int							intf_addr_num;
	int*						intf_addr_ptr;
	double*						intf_SDN_ptr;
	int							i,j;
			
    /*  Deallocate the packet structure memory.     */
    FIN (olsr_rte_olsr_message_destroy (olsr_message_ptr));
		
	/* Each Message (Hello, MID, TC) has ref_count fields first	*/
	hello_msg_ptr = (OlsrT_Hello_Message*) olsr_message_ptr->message;
	prg_mt_spinlock_acquire (&hello_msg_ptr->ref_count_lock);
	if (hello_msg_ptr->ref_count-- > 0)
		{
		op_prg_mem_free (olsr_message_ptr);
		prg_mt_spinlock_release (&hello_msg_ptr->ref_count_lock);
		}
	else
		{
		/* No other process is referencing this memory, so free it */
		
		/* Check what kind of message is there */
		switch (olsr_message_ptr->message_type)
			{			
			case (OLSRC_HELLO_MESSAGE):
				{
				hello_msg_ptr = (OlsrT_Hello_Message*) olsr_message_ptr->message;
				if (hello_msg_ptr != OPC_NIL)
					{
					hello_msg_data_vptr = (PrgT_Vector*) hello_msg_ptr->hello_msg_vptr;
					hello_msg_data_num = prg_vector_size (hello_msg_data_vptr);
					/* Go through each msg_data from the TAIL */
					for (i= hello_msg_data_num -1; i >= 0; i--)
						{
						hello_msg_data_ptr = (OlsrT_Hello_Message_Data*)
							prg_vector_remove (hello_msg_data_vptr, i);
						
						intf_addr_vptr = (PrgT_Vector*) hello_msg_data_ptr->nbr_intf_addr_vptr;
						intf_SDN_vptr = (PrgT_Vector*) hello_msg_data_ptr->nbr_intf_SDN_vptr;
						intf_addr_num = prg_vector_size (intf_addr_vptr);
				
						for (j=intf_addr_num -1; j>=0; j--)
							{
							/* Destroy each address in the intf_addr vector */
							intf_addr_ptr = (int*) prg_vector_remove (intf_addr_vptr, j);
							intf_SDN_ptr = (double*) prg_vector_remove (intf_SDN_vptr, j);
							op_prg_mem_free (intf_addr_ptr);
							}
						
						/* Free this vector and hello_msg_data */
						prg_vector_destroy (intf_addr_vptr, OPC_FALSE); 
						prg_vector_destroy (intf_SDN_vptr, OPC_FALSE);
						op_prg_mem_free (hello_msg_data_ptr);
						}
				
					/* Free this vector and hello_msg */
					prg_vector_destroy (hello_msg_data_vptr, OPC_FALSE); 
					op_prg_mem_free (hello_msg_ptr);
					break;
					}
				}
			
			case (OLSRC_TC_MESSAGE):
				{
				tc_msg_ptr = (OlsrT_TC_Message*) olsr_message_ptr->message;
				if (tc_msg_ptr != OPC_NIL)
					{
					intf_addr_vptr = (PrgT_Vector*) tc_msg_ptr->mpr_nodes_vptr;
					intf_SDN_vptr = (PrgT_Vector*) tc_msg_ptr->mpr_nodes_SDN_vptr;/////////////////////////////////////
					intf_addr_num = prg_vector_size (intf_addr_vptr);
					/* Go through each intf_addr from the TAIL */
					for (i= intf_addr_num -1; i >= 0; i--)
						{
						/* Destroy each address in the intf_addr vector */
						intf_addr_ptr = (int*) prg_vector_remove (intf_addr_vptr, i);
						intf_SDN_ptr =  (double*) prg_vector_remove (intf_SDN_vptr, i);////////////// Destroy each SDN in the SDN vector/////////////////
						op_prg_mem_free (intf_addr_ptr);
						}
					/* Free this vector and TC message */
					prg_vector_destroy (intf_addr_vptr, OPC_FALSE); 
					op_prg_mem_free (tc_msg_ptr);
					break;
					}
				}
				
			case (OLSRC_MID_MESSAGE):
				{
				mid_msg_ptr = (OlsrT_MID_Message*) olsr_message_ptr->message;
				if (mid_msg_ptr != OPC_NIL)
					{
					intf_addr_vptr = (PrgT_Vector*) mid_msg_ptr->intf_addr_vptr;
					intf_addr_num = prg_vector_size (intf_addr_vptr);
					/* Go through each intf_addr from the TAIL */
					for (i= intf_addr_num -1; i >= 0; i--)
						{
						/* Destroy each address in the intf_addr vector */
						intf_addr_ptr = (int*) prg_vector_remove (intf_addr_vptr, i);
						op_prg_mem_free (intf_addr_ptr);
						}
					/* Free this vector and TC message */
					prg_vector_destroy (intf_addr_vptr, OPC_FALSE); 
					op_prg_mem_free (mid_msg_ptr);
					break;
					}
				}
				
			}/*end switch */
			
			/* Free the olsr message */
			op_prg_mem_free (olsr_message_ptr);
		
		} /*end if-else*/
	  
    FOUT;
    }
		

static int*
olsr_rte_address_create (int addr)
    {
    int*                new_addr_ptr;
   
    FIN (olsr_rte_address_create (int));
     
    /* Allocate the duplicate set entry from the pooled memory  */
    new_addr_ptr = (int*) op_prg_pmo_alloc (new_addr_pmh);
	*new_addr_ptr = addr;
   
    FRET (new_addr_ptr);
    }

static double*
olsr_rte_sdn_create (double sdn)
    {
    double*                new_SDN_ptr;
   
    FIN (olsr_rte_sdn_create (double));
     
    /* Allocate the duplicate set entry from the pooled memory  */
    new_SDN_ptr = (double*) op_prg_pmo_alloc (sdn_pmh);
	*new_SDN_ptr = sdn;
   
    FRET (new_SDN_ptr);
    }

/************************************************/
/************ SUPPORT FUNCTIONS *****************/
/************************************************/ 

static void
olsr_rte_olsr_message_print (void* message_ptr, Prg_List* PRG_ARG_UNUSED (output_list))
	{
	OlsrT_Message* 				olsr_message_ptr;
	OlsrT_Hello_Message*		hello_msg_ptr = OPC_NIL;
	OlsrT_Hello_Message_Data*	hello_msg_data = OPC_NIL;
	OlsrT_TC_Message*			tc_msg_ptr = OPC_NIL;
	PrgT_Vector*				hello_msg_data_vptr = OPC_NIL;
	PrgT_Vector*				intf_addr_vptr = OPC_NIL;
	int 						i,j,linkcode = -99;
	int							intf_addr_num = 0;
	int							hello_msg_data_num = 0;
	char						addr_str[256];
	int							message_size, message_seq_num, vtime;
	int							ttl, hop_count, htime, willingness;
	int							originator_addr;
	int*						intf_addr_ptr;
	InetT_Address				inet_tmp_addr;
	
	FIN (lsr_rte_olsr_message_print (OlsrT_Message*));
	
	olsr_message_ptr = (OlsrT_Message*) message_ptr;
	
	/* Get information from the olsr message header */
	originator_addr = olsr_message_ptr->originator_addr;
	message_size = olsr_message_ptr->message_size;
	message_seq_num = olsr_message_ptr->message_seq_num;
	vtime = olsr_message_ptr->vtime;
	ttl = olsr_message_ptr->ttl;
	hop_count = olsr_message_ptr->hop_count;
	
	printf("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
	
	inet_tmp_addr = inet_rtab_index_to_addr_convert (originator_addr);
	inet_address_print (addr_str, inet_tmp_addr);
	
	printf("OLSR Message Header Info \n");
	printf("Orig Addr:%s	MsgSize:%d	SeqNum:%d	Vtime:%d	TTL:%d	HopCnt:%d\n\n", 
		addr_str, message_size, message_seq_num, vtime, ttl, hop_count);
				
	switch (olsr_message_ptr->message_type)
		{
		
		case (OLSRC_HELLO_MESSAGE):
			{
		
			/* Get the hello message from olsr_msg */
			hello_msg_ptr = (OlsrT_Hello_Message*) olsr_message_ptr->message;
	
			/* Get information from hello message */
			htime = hello_msg_ptr->htime;
			willingness = hello_msg_ptr->willingness;
	
			printf("Hello Message Header Info \n");
			printf("Htime: %d	Willingness:%d		", htime, willingness);
			
			energy_voisin = hello_msg_ptr->res_energy ;
		
			/* Get the list of hello msg data with different linkcodes */
			hello_msg_data_vptr = (PrgT_Vector*) hello_msg_ptr->hello_msg_vptr;
	

			if (hello_msg_data_vptr == OPC_NIL)
				{
				printf ("Total Msg Data: 0\n");
				}
			else
				{
			
				/* Get the number of hello_msg_data */
				hello_msg_data_num = prg_vector_size (hello_msg_data_vptr);
				printf ("Total Msg Data: %d\n\n", hello_msg_data_num);
	
				/* For each hello_msg_data */
				for (i=0; i < hello_msg_data_num; i++)
					{
					/* Get hello msg data */
					hello_msg_data = (OlsrT_Hello_Message_Data*) prg_vector_access (hello_msg_data_vptr, i);
		
					/* Get the linkcode for this hello msg data */
					linkcode = hello_msg_data->linkcode;
		
					/* Get list of interface address in the data */
					intf_addr_vptr = (PrgT_Vector*) hello_msg_data->nbr_intf_addr_vptr;
		
					/* Get the number of interface address */
					intf_addr_num = prg_vector_size (intf_addr_vptr);
		
					printf ("Hello Msg Data [%d]	LinkCode:%d\n", i, linkcode);
					printf("Intf Addresses: ");
		
					/* For each of the interface addresses */
					for (j=0; j < intf_addr_num; j++)
						{
						intf_addr_ptr = (int*) prg_vector_access (intf_addr_vptr, j);
						inet_tmp_addr = inet_rtab_index_to_addr_convert (*intf_addr_ptr);
						inet_address_print (addr_str, inet_tmp_addr);
					
						printf ("Intf addresses:%s	", addr_str);
						}
					printf("\n\n");
					}
				}
			break;
			}
			
		case (OLSRC_TC_MESSAGE):
			{
			tc_msg_ptr = (OlsrT_TC_Message*) olsr_message_ptr->message;
			
			printf ("TC Message\n\n");
			
			intf_addr_vptr = (PrgT_Vector*) tc_msg_ptr->mpr_nodes_vptr;
			intf_addr_num = prg_vector_size (intf_addr_vptr);
			
			if (intf_addr_num != 0)
				{
				printf ("MPR Addresses: ");
				/* Go through each intf_addr from the TAIL */
				for (i= 0; i < intf_addr_num; i++)
					{
					
					intf_addr_ptr = (int*) prg_vector_access (intf_addr_vptr, i);
					inet_tmp_addr = inet_rtab_index_to_addr_convert (*intf_addr_ptr);
					inet_address_print (addr_str, inet_tmp_addr);
					printf (" %s  ", addr_str);
					}
				printf ("\n\n");
				}
			else
				{
				printf ("\nEmpty TC Message. No MPR addresses \n");
				}
			
			break;
			}
		
		default:
			{
			printf ("\n ERROR: UNKNOWN Message Type\n\n");
			break;
			}
			
		}/*end switch*/
		
	printf("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n");
	FOUT;
	
	}

static void
olsr_rte_link_set_print_to_string (void)
	{
	/** Prints the Link Set Table maintained at this node	**/
	FIN (olsr_rte_link_set_print_to_string (void));
	
	if(!link_set_chain_head_ptr)
		{
		printf("=====================================================================\n");
		printf("		Empty Link Set \n");
		printf("=====================================================================\n");
		}
	else
		{
		OlsrT_Link_Set_Entry*		link_set_entry_ptr;
		
		printf("=====================================================================\n");
		printf("-                              LINK SET                              \n");
		printf("=====================================================================\n");
		printf("Nbr Intf Addr	My Intf Addr	SYM_time	ASYM_time	expiry_time	 	\n");
		printf("------------	-------------	----------	-----------	-----------  \n");

		for (link_set_entry_ptr = link_set_chain_head_ptr; link_set_entry_ptr;
			 link_set_entry_ptr = link_set_entry_ptr->next_link_set_entry_ptr)
			{		
			char						local_addr_str [INETC_ADDR_STR_LEN];
			char						nbr_str [INETC_ADDR_STR_LEN];
			
			InetT_Address inet_nbr_intf_addr = inet_rtab_index_to_addr_convert (link_set_entry_ptr->key.nbr_intf_addr);
            InetT_Address inet_local_intf_addr = inet_rtab_index_to_addr_convert (link_set_entry_ptr->key.local_intf_addr);

            inet_address_print (nbr_str, inet_nbr_intf_addr);
            inet_address_print (local_addr_str, inet_local_intf_addr);

			printf ("%s\t%s\t%10.3f\t%10.3f\t%10.3f\n", nbr_str, local_addr_str,
				link_set_entry_ptr->SYM_time, link_set_entry_ptr->ASYM_time, 
				link_set_entry_ptr->expiry_time);
			}
		printf("\n");
		}
		
	FOUT;
	
	}


static void
olsr_rte_neighbor_set_print_to_string (void)
	{
	OlsrT_Neighbor_Set_Entry*	nbr_set_entry_ptr = OPC_NIL;
	List*						keys_lptr = OPC_NIL;
	int							num_routes, count;
	char						status_str[128];
	char						will_str[128];
	char						nbr_str [256];
	InetT_Address				inet_nbr_addr;
	double						fs;
	int							msgs;
	int							conf;
		
	/** Prints the Neighbor Set Table maintained at this node	**/
	FIN (olsr_rte_neighbor_set_print_to_string (void));

	/* Get the number of entries in the link set	*/
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (neighbor_set_table);
	num_routes = op_prg_list_size (keys_lptr);
		printf("\n I am the noeud %d",own_main_address);
	print_addr(own_main_address);
	printf("\n");
	
	if(num_routes == 0)
		{
		printf("=====================================================================\n");
		printf("		Empty Neighbor Set \n");
		printf("=====================================================================\n");
		}
	else
		{
		
		printf("=====================================================================\n");
		printf("-                  NEIGHBOR SET                                      \n");
		printf("=====================================================================\n");
		printf("Neighbor Addr.	  Status	    Willingness   nbr msg  Stabilite	Conf\n");
		printf("--------------	------------	------------  -------- ------------\n");
		
		for (count = 0; count < num_routes; count++)
		{
	
		/* For each entry	*/
		nbr_set_entry_ptr = (OlsrT_Neighbor_Set_Entry*) op_prg_list_access (keys_lptr, count);
		
		if(nbr_set_entry_ptr == OPC_NIL)
			{
			printf("One Entry but Empty NBR Set \n");
			continue;
			}
		else
			{
			
			if (nbr_set_entry_ptr->status == OLSRC_SYM_STATUS)
				sprintf(status_str, "SYMMETRIC");
			else
				sprintf(status_str, "NOT SYMMETRIC");
			
			if (nbr_set_entry_ptr->willingness == OLSRC_WILL_NEVER)
				sprintf(will_str, "WILL NEVER");
			else if (nbr_set_entry_ptr->willingness == OLSRC_WILL_LOW)
				sprintf(will_str, "WILL LOW");
			else if (nbr_set_entry_ptr->willingness == OLSRC_WILL_DEFAULT)
				sprintf(will_str, "WILL DEFAULT");
			else if (nbr_set_entry_ptr->willingness == OLSRC_WILL_HIGH)
				sprintf(will_str, "WILL HIGH");
			else if (nbr_set_entry_ptr->willingness == OLSRC_WILL_ALWAYS)
				sprintf(will_str, "WILL ALWAYS");
			
			
			inet_nbr_addr = inet_rtab_index_to_addr_convert (nbr_set_entry_ptr->nbr_addr);
			inet_address_print (nbr_str, inet_nbr_addr);
			
			/****************************************************************/
			msgs=nbr_set_entry_ptr->val_signal.nbr_msg_recevu;
			fs=nbr_set_entry_ptr->stabilite.SDN;
			conf=nbr_set_entry_ptr->conf;
		
			/****************************************************************/			
			
		printf ("%s\t\t%s\t%s\t%d\t%d\t%g\t%d\n", nbr_str, status_str, will_str, op_prg_list_size (&nbr_set_entry_ptr->two_hop_nbr_list),msgs,fs,conf);
		
			}
		}
		printf("\n");
		
		}/* close else */
	
	/* Free the keys	*/
	prg_list_destroy (keys_lptr, OPC_FALSE);
		
	FOUT;
	
	}

static void
olsr_rte_two_hop_neighbor_set_print_to_string (void)
	{
	OlsrT_Two_Hop_Neighbor_Set_Entry*	two_hop_nbr_set_entry_ptr = OPC_NIL;
	List*								keys_lptr = OPC_NIL;
	int									num_routes, count;
	char								nbr_addr_str [INETC_ADDR_STR_LEN];
	OlsrT_Nbr_Addr_Two_Hop_Entry*		nbr_addr_ptr;
	int									nbr_num, i;
	InetT_Address						inet_two_hop_addr, inet_nbr_addr;
	char								two_hop_str [256];
	
	/** Prints the Neighbor Set Table maintained at this node	**/
	FIN (olsr_rte_two_hop_neighbor_set_print_to_string (void));

	/* Get the number of entries in the link set	*/
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (two_hop_nbr_set_table);
	num_routes = op_prg_list_size (keys_lptr);
	

	
	if(num_routes == 0)
		{
		printf("=====================================================================\n");
		printf("		Empty Two Hop Neighbor Set \n");
		printf("=====================================================================\n");
		
		}
	else
		{
		
		printf("=====================================================================\n");
		printf("-              TWO HOP NEIGHBOR SET                                  \n");
		printf("=====================================================================\n");
		printf("Two Hop Addr.	# Pointers	Nbr Addr List	\n");
		printf("--------------	----------	-------------- \n");
			   								
		for (count = 0; count < num_routes; count++)
		{
	
		/* For each entry	*/
		two_hop_nbr_set_entry_ptr = (OlsrT_Two_Hop_Neighbor_Set_Entry*) op_prg_list_access (keys_lptr, count);
		
		if(two_hop_nbr_set_entry_ptr == OPC_NIL)
			{
			printf("One Entry but Empty NBR Set \n");
			continue;
			}
		else
			{
			inet_two_hop_addr = inet_rtab_index_to_addr_convert (two_hop_nbr_set_entry_ptr->two_hop_addr);
			inet_address_print (two_hop_str, inet_two_hop_addr);
		
			//printf ("%s\t\t%d\t", two_hop_str,two_hop_nbr_set_entry_ptr->neighbor_list.size);
			nbr_num = op_prg_list_size (&two_hop_nbr_set_entry_ptr->neighbor_list);
			for (i=0; i< nbr_num; i++)
				{
				nbr_addr_ptr = (OlsrT_Nbr_Addr_Two_Hop_Entry*) op_prg_list_access 
										(&two_hop_nbr_set_entry_ptr->neighbor_list, i);
				inet_nbr_addr = inet_rtab_index_to_addr_convert (nbr_addr_ptr->nbr_ptr->nbr_addr);
				inet_address_print (nbr_addr_str, inet_nbr_addr);
		
				//if (!strcmp (nbr_addr_str, "192.0.1.31"))
					printf ("%s\n\t\t\t\t", nbr_addr_str);
				
				}
			printf ("\n");
			
			}
		}
		printf("\n");
		
		}/* close else */
		
	/* Free the keys	*/
	prg_list_destroy (keys_lptr, OPC_FALSE);
		
	FOUT;
	
	}


static void
olsr_rte_tc_set_print_to_string (void)
	{
	OlsrT_TC_Set_Entry*				tc_set_entry_ptr = OPC_NIL;
	OlsrT_TC_Dest_Addr_Entry*		cmn_tc_entry_ptr = OPC_NIL;
	List*							keys_lptr = OPC_NIL;
	int								num_routes, count;
	char							dest_addr_str [INETC_ADDR_STR_LEN];
	int								dest_num, i;
	int*							dest_addr_ptr;
	InetT_Address					inet_addr, inet_dest_addr;
	char							addr_str [256];
	double*                        dest_SDN_ptr;
	double                        intf_SDN;
	
	/** Prints the Neighbor Set Table maintained at this node	**/
	FIN (olsr_rte_tc_set_print_to_string (void));

	/* Get the number of entries in the link set	*/
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (tc_set_table);
	num_routes = op_prg_list_size (keys_lptr);
	
	if(num_routes == 0)
		{
		printf("=====================================================================\n");
		printf("		Empty TOPOLOGY Set \n");
		printf("=====================================================================\n");
		}
	else
		{
		
		printf("=====================================================================\n");
		printf("-              TOPOLOGY SET                                          \n");
		printf("=====================================================================\n");
		printf("Last Addr.	Seq Num		Exp Time	Dest Add 			SDN\n");
		printf("----------	-------		--------	---------		-------------\n");
			   								
		for (count = 0; count < num_routes; count++)
		{
	
		/* For each TC entry	*/
		tc_set_entry_ptr = (OlsrT_TC_Set_Entry*) op_prg_list_access (keys_lptr, count);
		
		if(tc_set_entry_ptr == OPC_NIL)
			{
			printf("One Entry but Empty TC Set \n");
			continue;
			}
		else
			{
			inet_addr = inet_rtab_index_to_addr_convert (tc_set_entry_ptr->last_addr);
			inet_address_print (addr_str, inet_addr);
			printf ("%s\t %d\t%12.3f\t\t", addr_str, tc_set_entry_ptr->tc_seq_num, tc_set_entry_ptr->tc_time);
			
			cmn_tc_entry_ptr = (OlsrT_TC_Dest_Addr_Entry*) tc_set_entry_ptr->state_ptr;
			if (cmn_tc_entry_ptr == OPC_NIL)
				{
				printf ("No OLSR TC Table entry, state_ptr is NIL\n");
				FOUT;
				}
				
			dest_num = op_prg_list_size (&cmn_tc_entry_ptr->dest_addr_list);
			
			for (i=0; i< dest_num; i++)
				{
				dest_addr_ptr = (int*) op_prg_list_access (&cmn_tc_entry_ptr->dest_addr_list, i);
				dest_SDN_ptr = (double*) op_prg_list_access (&cmn_tc_entry_ptr->SDN_list, i);////////////////////////////////////
				inet_dest_addr = inet_rtab_index_to_addr_convert (*dest_addr_ptr);
				 intf_SDN=*dest_SDN_ptr;////////////////////////////////////////////////////////////////////////////////////////
				inet_address_print (dest_addr_str, inet_dest_addr);
				
				printf ("%s \t\t %g\n\t\t\t\t\t\t\t", dest_addr_str,intf_SDN);
				
				}
			printf ("\n");
			
			}
		}
		printf("\n");
		
		}/* close else */
	
	/* Free the keys	*/
	prg_list_destroy (keys_lptr, OPC_FALSE);
	
	FOUT;
	
	}


static void
olsr_rte_mpr_set_print_to_stringara (void)
	{
	List*					keys_lptr = OPC_NIL;
	OlsrT_MPR_Set_Entry*	mpr_entry_ptr = OPC_NIL;
	int						num_routes, count;
	char					addr_str [INETC_ADDR_STR_LEN];
	InetT_Address			inet_addr;

	/** Prints the MPR Set Table maintained at this node	**/
	FIN (olsr_rte_mpr_set_print_to_stringara (void));

	/* Get the number of entries in the mpr set	*/
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (mpr_set_table);
	num_routes = op_prg_list_size (keys_lptr);
	
	if(num_routes == 0)
		{
		printf("=====================================================================\n");
		printf("		Empty MPR Set \n");
		printf("=====================================================================\n");
		}
	else
		{
		printf("=====================================================================\n");
		printf("-             		 MPR SET                                         \n");
		printf("=====================================================================\n");
		
		for (count = 0; count < num_routes; count++)
			{
	
			/* For each entry	*/
			mpr_entry_ptr = (OlsrT_MPR_Set_Entry*) op_prg_list_access (keys_lptr, count);
			inet_addr = inet_rtab_index_to_addr_convert (mpr_entry_ptr->mpr_addr);
			inet_address_print (addr_str, inet_addr);
			printf ("(%d)\t", mpr_entry_ptr->mpr_addr+1);
		
			}
		
		}/* close else */
	
	printf ("\n\n");
	
	/* Free the keys	*/
	prg_list_destroy (keys_lptr, OPC_FALSE);
	
	FOUT;
	
	}

static void
olsr_rte_mpr_selector_set_print_to_string (void)
	{
	OlsrT_MPR_Selector_Set_Entry*	mprs_entry_ptr = OPC_NIL;
	List*							keys_lptr = OPC_NIL;
	int								num_routes, count;
	char							addr_str [INETC_ADDR_STR_LEN];
	InetT_Address					inet_addr;

	/** Prints the MPR Set Table maintained at this node	**/
	FIN (olsr_rte_mpr_selector_set_print_to_string (void));

	/* Get the number of entries in the mpr set	*/
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (mpr_selector_set_table);
	num_routes = op_prg_list_size (keys_lptr);
	
	if(num_routes == 0)
		{
		printf("=====================================================================\n");
		printf("		Empty MPR Selector Set \n");
		printf("=====================================================================\n");
		}
	else
		{
		
		printf("=====================================================================\n");
		printf("-              MPR SELECTOR SET                                      \n");
		printf("=====================================================================\n");
		
		for (count = 0; count < num_routes; count++)
			{
	
			/* For each entry	*/
			mprs_entry_ptr = (OlsrT_MPR_Selector_Set_Entry*) op_prg_list_access (keys_lptr, count);
			inet_addr = inet_rtab_index_to_addr_convert (mprs_entry_ptr->mpr_selector_ptr->nbr_addr);
			inet_address_print (addr_str, inet_addr);
			printf ("%s\t%12.3f\n", addr_str, mprs_entry_ptr->expiry_time );
			}
		
		printf("\n");
		
		}/* close else */
	
	/* Free the keys	*/
	prg_list_destroy (keys_lptr, OPC_FALSE);
		
	FOUT;
	
	}


static void
olsr_rte_routing_table_print_to_string (void)
	{
	OlsrT_Routing_Table_Entry*	rt_entry_ptr = OPC_NIL;
	List*						keys_lptr = OPC_NIL;
	int							num_routes, count;
	char						local_addr_str [INETC_ADDR_STR_LEN];
	char						dest_addr_str [256];
	char						next_addr_str [256];
	InetT_Address				inet_next_addr;
	InetT_Address				inet_dest_addr;
	InetT_Address				inet_local_intf_addr;

	/** Prints the Routing Table maintained at this node	**/
	FIN (olsr_rte_routing_table_print_to_string (void));

	/* Get the number of entries in the link set	*/
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (olsr_routing_table);
	num_routes = op_prg_list_size (keys_lptr);
	
	if(num_routes == 0)
		{
		printf("=====================================================================\n");
		printf("		Empty Routing Table\n");
		printf("=====================================================================\n");
		}
	else
		{
		
		printf("=======================================================================\n");
		printf("-                     ROUTING TABLE                                    \n");
		printf("=======================================================================\n");
		printf("Dest Addr	Next Addr	Hops	Local Intf	\n");
		printf("----------	-----------	-------	----------- \n");
		
		for (count = 0; count < num_routes; count++)
		{
		
		/* For each entry	*/
		rt_entry_ptr = (OlsrT_Routing_Table_Entry*) op_prg_list_access (keys_lptr, count);
		
		if(rt_entry_ptr == OPC_NIL)
			{
			printf("Route Entry pointer = OPC_NIL \n");
			continue;
			}
		else if (rt_entry_ptr->next_addr == DIRECTLY_CONNECTED)
			{
			/* We should not be printing the directly connected  */
			/* routes. These are artificially inserted in the    */
			/* OLSR table and serve as placeholders for the      */
			/* dest_prefix that OLSR passes to IP. OLSR needs to */
			/* hang onto this dest_prefix, since OLSR is respon- */
			/* sible for destroying it. However, we are hiding   */
			/* this implementation detail from any trace. As far */
			/* as this function that prints the OLSR route table */
			/* is concerned, the OLSR route table contains only  */
			/* OLSR routes, not directly connected routes.       */
			continue; 
			}
		else
			{
			inet_dest_addr = inet_rtab_index_to_addr_convert (rt_entry_ptr->dest_addr);
			inet_next_addr = inet_rtab_index_to_addr_convert (rt_entry_ptr->next_addr);
			inet_local_intf_addr = inet_rtab_index_to_addr_convert (rt_entry_ptr->local_iface_addr);
			inet_address_print (dest_addr_str, inet_dest_addr);
			inet_address_print (next_addr_str, inet_next_addr);
            inet_address_print (local_addr_str, inet_local_intf_addr);

			printf ("%s\t%s\t%d\t%s\n", dest_addr_str, next_addr_str, rt_entry_ptr->hops, local_addr_str);
			}
		
		}
				
		}/* close else */
	
	printf("\n---------------------------------------------------------------------------------------------\n");
		
	/* Free the keys	*/
	op_prg_mem_free (keys_lptr);
		
	FOUT;
	
	}

static void
olsr_rte_interface_table_print_to_string (void)
	{
	PrgT_Bin_Hash_Table*	intf_set_table_ptr = OPC_NIL;	
	List*					keys_lptr = OPC_NIL;
	List*					intf_lptr;
	int						i, num_entries, num_intf, j;
	int*					intf_addr_ptr;
	InetT_Address			inet_tmp_addr;
	char					intf_addr_str [256], main_addr_str [256];
	OlsrT_Interface_Set_Entry* 	intf_set_entry_ptr;
	
	FIN (olsr_rte_interface_table_print_to_string(void));
	intf_set_table_ptr = olsr_support_interface_table_ptr_get();
	
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (intf_set_table_ptr);
	num_entries = op_prg_list_size (keys_lptr);
	
	printf("===================================================================\n");
	printf("-                       Interface TABLE                            \n");
	printf("===================================================================\n");
	printf("Intf Addr		Main Addr	Type	List of Interfaces\n");
	printf("----------		----------	----	------------------\n");
	
	for (i=0; i< num_entries; i++)
		{
		/* for each entry in MID table */
		intf_set_entry_ptr = (OlsrT_Interface_Set_Entry*) op_prg_list_access (keys_lptr, i);
		
		if (intf_set_entry_ptr->type == 2)
			{
			inet_tmp_addr = inet_rtab_index_to_addr_convert (intf_set_entry_ptr->intf_addr);
			inet_address_print (intf_addr_str, inet_tmp_addr);
			inet_tmp_addr = inet_rtab_index_to_addr_convert (intf_set_entry_ptr->main_addr);
			inet_address_print (main_addr_str, inet_tmp_addr);
			printf ("%s\t\t%s\t%d\t", intf_addr_str, main_addr_str, intf_set_entry_ptr->type);
		
			/* This will have list of intf */
			intf_lptr = (List*) intf_set_entry_ptr->intf_addr_lptr;
			num_intf = op_prg_list_size (intf_lptr);
			
			for (j=0; j< num_intf; j++)
				{
				intf_addr_ptr = (int*) op_prg_list_access (intf_lptr, j);
				inet_tmp_addr = inet_rtab_index_to_addr_convert (*intf_addr_ptr);
				inet_address_print (intf_addr_str, inet_tmp_addr);
				printf ("%s   ", intf_addr_str);
				}		
			}
		else
			{
			inet_tmp_addr = inet_rtab_index_to_addr_convert (intf_set_entry_ptr->intf_addr);
			inet_address_print (intf_addr_str, inet_tmp_addr);
			inet_tmp_addr = inet_rtab_index_to_addr_convert (intf_set_entry_ptr->main_addr);
			inet_address_print (main_addr_str, inet_tmp_addr);
		
			printf ("%s\t\t%s\t%d\tNIL", intf_addr_str, main_addr_str, intf_set_entry_ptr->type);
			}
		printf ("\n");
		
		}
	
	prg_list_destroy (keys_lptr, OPC_FALSE);
	
	FOUT;
	
	}

	
static void
olsr_rte_clear_table (void* table_ptr, int which_table)
	{
	/* Destroys the contents of the table */
	OlsrT_TC_Set_Entry* 				tc_entry_ptr;
	OlsrT_Neighbor_Set_Entry* 			nbr_entry_ptr;
	OlsrT_Two_Hop_Neighbor_Set_Entry*	two_hop_entry_ptr;
	int									i,j, num_keys, list_size;
	char*								key_ptr;
	List*								keys_lptr;
	PrgT_String_Hash_Table*				str_tbl_ptr;
	PrgT_Bin_Hash_Table*				bin_tbl_ptr;
	OlsrT_Routing_Table_Entry*			rt_entry_ptr;
	OlsrT_MPR_Selector_Set_Entry* 		mpr_selector_entry_ptr;
	OlsrT_MPR_Set_Entry* 				mpr_entry_ptr;
	OlsrT_Nbr_Addr_Two_Hop_Entry* 		two_hop_addr_ptr;
	InetT_Address						inet_next_addr;

	FIN (olsr_rte_clear_table (<args>));
	
	switch (which_table)
		{
		case (1):
			{
			bin_tbl_ptr = (PrgT_Bin_Hash_Table *) table_ptr;
			keys_lptr = (List*) prg_bin_hash_table_item_list_get (bin_tbl_ptr);
			num_keys = op_prg_list_size (keys_lptr);
			
			/* Clearing Nbr Table */
			for (i=0; i< num_keys; i++)
				{
				/* For each entry in table */
				nbr_entry_ptr = (OlsrT_Neighbor_Set_Entry*) op_prg_list_access (keys_lptr, i);
				prg_bin_hash_table_item_remove (bin_tbl_ptr, &(nbr_entry_ptr->nbr_addr));
				
				list_size = op_prg_list_size (&nbr_entry_ptr->two_hop_nbr_list);
					
				for (j=0; j< list_size; j++)
					{
					op_prg_list_remove (&nbr_entry_ptr->two_hop_nbr_list, PRGC_LISTPOS_HEAD);
					}
				op_prg_list_free (&nbr_entry_ptr->two_hop_nbr_list);
				op_prg_mem_free (nbr_entry_ptr);
				}
			
			/* Free the keys and the list */
			prg_list_destroy (keys_lptr, OPC_FALSE);
			break;
			}
			
		case (2):
			{
			bin_tbl_ptr = (PrgT_Bin_Hash_Table *) table_ptr;
			keys_lptr = (List*) prg_bin_hash_table_item_list_get (bin_tbl_ptr);
			num_keys = op_prg_list_size (keys_lptr);
			
			/* Clearing Two Hop Nbr Table */
			for (i=0; i< num_keys; i++)
				{
				/* For each entry in table */
				two_hop_entry_ptr = (OlsrT_Two_Hop_Neighbor_Set_Entry*) op_prg_list_access (keys_lptr, i);
				prg_bin_hash_table_item_remove (bin_tbl_ptr, &(two_hop_entry_ptr->two_hop_addr));
				
				list_size = op_prg_list_size (&two_hop_entry_ptr->neighbor_list);
				
				for (j=0; j< list_size; j++)
					{
					two_hop_addr_ptr = (OlsrT_Nbr_Addr_Two_Hop_Entry*) 
						op_prg_list_remove (&two_hop_entry_ptr->neighbor_list, PRGC_LISTPOS_HEAD);

					op_ev_cancel_if_pending (two_hop_addr_ptr->two_hop_expiry_evhandle);
					
					/* destroy memory												*/
					op_prg_mem_free (two_hop_addr_ptr);
					}
				prg_bin_hash_table_destroy (two_hop_entry_ptr->neighbor_hash_ptr, OPC_NIL);
				op_prg_mem_free (two_hop_entry_ptr);
				}
			
			/* Free the keys and the list */
			prg_list_destroy (keys_lptr, OPC_FALSE);
			break;
			}
			
		case (3):
			{
			bin_tbl_ptr = (PrgT_Bin_Hash_Table *) table_ptr;
			keys_lptr = (List*) prg_bin_hash_table_item_list_get (bin_tbl_ptr);
			num_keys = op_prg_list_size (keys_lptr);
			
			/* Clearing TC Table */
			for (i=0; i< num_keys; i++)
				{
				/* For each entry in table */
				tc_entry_ptr = (OlsrT_TC_Set_Entry*) op_prg_list_access (keys_lptr, i);
				
				oms_topo_table_item_remove (topo_table_hndl, 
					tc_entry_ptr->last_addr, tc_entry_ptr->tc_seq_num);
				
				prg_bin_hash_table_item_remove (bin_tbl_ptr, &(tc_entry_ptr->last_addr));
				op_prg_mem_free (tc_entry_ptr);
				}
			
			prg_list_destroy (keys_lptr, OPC_FALSE);
			break;
			}
			
		case (4):
			{
			OlsrT_Link_Set_Entry*			link_set_entry_ptr;
			OlsrT_Link_Set_Entry*			next_link_set_entry_ptr;
			char*							src_dest_addr_str;
			
			/* Clear entries in the link set table			*/
			bin_tbl_ptr = (PrgT_Bin_Hash_Table *) table_ptr;
			keys_lptr = (List*) prg_bin_hash_table_item_list_get (bin_tbl_ptr);
			num_keys = op_prg_list_size (keys_lptr);
			
			//str_tbl_ptr = (PrgT_String_Hash_Table *) table_ptr;
			//keys_lptr = (List*) prg_string_hash_table_keys_get (str_tbl_ptr);
			//num_keys = op_prg_list_size (keys_lptr);

			for (i = 0; i < num_keys; i++)
				{
				/* For each entry in the table	*/
				//key_ptr = (char*) op_prg_list_access (keys_lptr, i);
				//link_set_entry_ptr = (OlsrT_Link_Set_Entry*) prg_string_hash_table_item_remove (str_tbl_ptr, key_ptr);

				link_set_entry_ptr = (OlsrT_Link_Set_Entry*) op_prg_list_access (keys_lptr, i);
				prg_bin_hash_table_item_remove (bin_tbl_ptr, &link_set_entry_ptr->key);
					
				if (op_ev_valid (link_set_entry_ptr->sym_time_expiry_evhandle))
					{
					src_dest_addr_str = (char*) op_ev_state (link_set_entry_ptr->sym_time_expiry_evhandle);
					op_prg_mem_free (src_dest_addr_str);
					op_ev_cancel (link_set_entry_ptr->sym_time_expiry_evhandle);
					}
				
				//op_prg_mem_free (link_set_entry_ptr);
				}
			
			/* Free the keys and the list */
			//op_prg_list_free (keys_lptr);
			//op_prg_mem_free (keys_lptr);
			
			/* Link set entries are also chained together...make sure to remove them 		*/
			link_set_entry_ptr = link_set_chain_head_ptr;
			while (link_set_entry_ptr)
				{
				next_link_set_entry_ptr = link_set_entry_ptr->next_link_set_entry_ptr;
				op_prg_mem_free (link_set_entry_ptr);
				link_set_entry_ptr = next_link_set_entry_ptr;
				link_set_chain_head_ptr = link_set_entry_ptr;
				}
			
			prg_list_destroy (keys_lptr, OPC_FALSE);
			break;
			}
						
		case (5):
			{
			bin_tbl_ptr = (PrgT_Bin_Hash_Table *) table_ptr;
			keys_lptr = (List*) prg_bin_hash_table_item_list_get (bin_tbl_ptr);
			num_keys = op_prg_list_size (keys_lptr);
			
			/* Clearing MPR table		 */
			for (i=0; i< num_keys; i++)
				{
				/* For each entry in table */
				mpr_entry_ptr = (OlsrT_MPR_Set_Entry*) op_prg_list_access (keys_lptr, i);
				op_prg_mem_free (prg_bin_hash_table_item_remove (bin_tbl_ptr, &(mpr_entry_ptr->mpr_addr)));
				}
			
			/* Free the keys and the list */
			prg_list_destroy (keys_lptr, OPC_FALSE);
			break;
			}
			
		case (6):
			{
			bin_tbl_ptr = (PrgT_Bin_Hash_Table *) table_ptr;
			keys_lptr = (List*) prg_bin_hash_table_item_list_get (bin_tbl_ptr);
			num_keys = op_prg_list_size (keys_lptr);
			
			/* Clearing MPR Selector table */
			for (i=0; i< num_keys; i++)
				{
				/* For each entry in table */
				mpr_selector_entry_ptr = (OlsrT_MPR_Selector_Set_Entry*) op_prg_list_access (keys_lptr, i);
				prg_bin_hash_table_item_remove (bin_tbl_ptr, &(mpr_selector_entry_ptr->mpr_selector_ptr->nbr_addr));
				op_prg_mem_free (mpr_selector_entry_ptr);
				}
		
			/* Free the keys and the list */
			prg_list_destroy (keys_lptr, OPC_FALSE);
			break;
			}
			
		case (7):
			{
			bin_tbl_ptr = (PrgT_Bin_Hash_Table *) table_ptr;
			keys_lptr = (List*) prg_bin_hash_table_item_list_get (bin_tbl_ptr);
			num_keys = op_prg_list_size (keys_lptr);
			
			/* Clearing OLSR Rte Table */
			for (i=0; i< num_keys; i++)
				{
				/* For each entry in table */
				rt_entry_ptr = (OlsrT_Routing_Table_Entry*) op_prg_list_access (keys_lptr, i);
				
				/* Remove the corresponding entry from IP forwarding table				*/
		
				/* First get the next hop address 											*/
				inet_next_addr = inet_rtab_index_to_addr_convert (rt_entry_ptr->next_addr);
				Inet_Cmn_Rte_Table_Entry_Delete (module_data_ptr->ip_route_table, 
					rt_entry_ptr->dest_prefix, inet_next_addr, olsr_protocol_id);
				
				prg_bin_hash_table_item_remove (bin_tbl_ptr, &(rt_entry_ptr->dest_addr));
				op_prg_mem_free (rt_entry_ptr);
				}
			
			prg_list_destroy (keys_lptr, OPC_FALSE);
			break;
			}
			
		case (8):
			{
			OlsrT_Duplicate_Set_Entry*		dup_entry_ptr;
			char*							temp_str;
			
			/* Clear entries in the Duplicate set table			*/
			bin_tbl_ptr = (PrgT_Bin_Hash_Table *) table_ptr;
			keys_lptr = (List*) prg_bin_hash_table_item_list_get (bin_tbl_ptr);
			num_keys = op_prg_list_size (keys_lptr);
			
			//str_tbl_ptr = (PrgT_String_Hash_Table *) table_ptr;
			//keys_lptr = (List*) prg_string_hash_table_keys_get (str_tbl_ptr);
			//num_keys = op_prg_list_size (keys_lptr);
			
			for (i=0; i< num_keys; i++)
				{
				/* For each entry in table */
				//key_ptr = (char*) op_prg_list_access (keys_lptr, i);
				//dup_entry_ptr = (OlsrT_Duplicate_Set_Entry*) prg_string_hash_table_item_remove (str_tbl_ptr, key_ptr);
				
				dup_entry_ptr = (OlsrT_Duplicate_Set_Entry*) op_prg_list_access (keys_lptr, i);
				prg_bin_hash_table_item_remove (bin_tbl_ptr, &dup_entry_ptr->key);
				
				if (op_ev_valid (dup_entry_ptr->entry_expiry_evhandle))
					{
					temp_str = (char*) op_ev_state (dup_entry_ptr->entry_expiry_evhandle);
					op_prg_mem_free (temp_str);
				
					op_ev_cancel (dup_entry_ptr->entry_expiry_evhandle);
					}
				
				op_prg_mem_free (dup_entry_ptr);
				}
			
			/* Free the keys and the list */
			//op_prg_list_free (keys_lptr);
			//op_prg_mem_free (keys_lptr);
			prg_list_destroy (keys_lptr, OPC_FALSE);
			break;
			}
		default:
			{
			str_tbl_ptr = (PrgT_String_Hash_Table *) table_ptr;
			keys_lptr = (List*) prg_string_hash_table_keys_get (str_tbl_ptr);
			num_keys = op_prg_list_size (keys_lptr);
			
			/* Default clearing algorithm: Since we have accounted for all cases, this is no longer used */
			for (i=0; i< num_keys; i++)
				{
				/* For each entry in table */
				key_ptr = (char*) op_prg_list_access (keys_lptr, i);
		
				op_prg_mem_free (prg_string_hash_table_item_remove (str_tbl_ptr, key_ptr));
				}
			
			/* Free the keys and the list */
			op_prg_list_free (keys_lptr);
			op_prg_mem_free (keys_lptr);
			break;
			}
		}/*end switch */
	
	FOUT;
	}

static void
olsr_rte_fail_rec_handle (int intrpt_type)
	{
	/* Function to handle FAILURE / RECOVERY interrupts */
	Objid		fail_rec_obj_id;
	Objid		own_node_objid;
	
	FIN (olsr_rte_fail_rec_handle (int));
	
	/* First check if this FAILURE/RECOVERY interrupt 	*/
	/* was for this node. If not, do not process this	*/
	/* interrupt 										*/
	
	/* Obtain the ID of the failed/recovered object.*/
	fail_rec_obj_id = op_intrpt_source ();
	
	own_node_objid = op_topo_parent (op_id_self ());
	
	if (own_node_objid == fail_rec_obj_id)
		{
		
		if (intrpt_type == OPC_INTRPT_FAIL)
			{
			/* FAILURE interrupt 			  */
			
			List*	keys_lptr;
			int		num_mpr_selectors;
			
			/* Clear all scheduled interrupts */
			/* Clear HELLO Timer */
			op_ev_cancel_if_pending (hello_timer_evhandle);
			
			/* Clear TC Timer */
			op_ev_cancel_if_pending (tc_timer_evhandle);
			
			/* If this node was an MPR, update global MPR count		*/
			keys_lptr = (List*) prg_bin_hash_table_item_list_get (mpr_selector_set_table);
			num_mpr_selectors = prg_list_size (keys_lptr);
			if (num_mpr_selectors > 0)
				olsr_rte_update_global_mpr_count (OPC_FALSE);
			
			/* Clear all tables				  */
			olsr_rte_clear_table (mpr_selector_set_table, 6);
			olsr_rte_clear_table (neighbor_set_table, 1);
			olsr_rte_clear_table (two_hop_nbr_set_table, 2);
			olsr_rte_clear_table (tc_set_table, 3);
			olsr_rte_clear_table (link_set_table, 4);
			olsr_rte_clear_table (mpr_set_table, 5);
			olsr_rte_clear_table (olsr_routing_table, 7);
			olsr_rte_clear_table (duplicate_set_table, 8);
			
			/* Node loses its MPR status				*/
			if (op_stat_valid (local_stat_handles.mpr_status_shandle))
				op_stat_write (local_stat_handles.mpr_status_shandle, 0.0);
			}
		else if (intrpt_type == OPC_INTRPT_RECOVER)
			{
			/* RECOVERY interrupt				*/
			/* Schedule interrupts for periodic	*/
			/* hello and TC messages 			*/
			hello_timer_evhandle = op_intrpt_schedule_self (op_sim_time () + op_dist_uniform (hello_interval), OLSRC_HELLO_TIMER_EXPIRY);
			tc_timer_evhandle = op_intrpt_schedule_self (op_sim_time () + op_dist_uniform (tc_interval), OLSRC_TC_TIMER_EXPIRY);
			
			/* Node is not an MPR yet				*/
			if (op_stat_valid (local_stat_handles.mpr_status_shandle))
				op_stat_write (local_stat_handles.mpr_status_shandle, 0.0);
			}
		else
			{
			/* Unknown interrupt 	*/
			/* Do not do anything 	*/
			}
		}
	
	FOUT;
	}
		
static void
olsr_rte_error (const char* str1, char* str2, char* str3)
	{
	/** This function generates an error and	**/
	/** terminates the simulation				**/
	FIN (olsr_rte_error <args>);
	
	op_sim_end ("OLSR Routing Process : ", str1, str2, str3);
	
	FOUT;
	}

static void
olsr_rte_duplicate_entry_delete (void* v_dup_entry_ptr, int PRG_ARG_UNUSED (code))	
	{
	/* Deletes the expired duplicate set entry */
	OlsrT_Duplicate_Set_Entry* 	dup_entry_ptr = (OlsrT_Duplicate_Set_Entry*) v_dup_entry_ptr;
	
	FIN (olsr_rte_duplicate_entry_delete (<args>));
	
	prg_bin_hash_table_item_remove (duplicate_set_table, &dup_entry_ptr->key);
	prg_mem_free (dup_entry_ptr);
	
	FOUT;
	}
	
static void
olsr_rte_routing_table_entry_update (OlsrT_Routing_Table_Entry* rt_entry_ptr, int new_next_addr, 
	int new_hops, int new_local_iface_addr)
	{
	/* Function to update nextaddr, hops and local intf  in OLSR rte tbl */
	FIN (olsr_rte_routing_table_entry_update (<args>));
	op_stat_write (global_stat_handles.rte_table_calcs_global_shandle, 1.0);
	rt_entry_ptr->next_addr = new_next_addr;
	rt_entry_ptr->hops = new_hops;
	rt_entry_ptr->local_iface_addr = new_local_iface_addr;
	
	FOUT;
	}

static void
olsr_rte_table_incremental_entry_add (PrgT_Bin_Hash_Table* old_olsr_rte_table_ptr, int dest_addr,
	int new_nexthop, int new_cost, int new_local_intf)
	{
	InetT_Address				inet_next_addr;
	InetT_Address				old_inet_next_addr;
	InetT_Address				inet_local_intf_addr;
	InetT_Address				inet_dest_addr;
	IpT_Dest_Prefix				dest_prefix;
	int							intf_index;
	IpT_Port_Info				port_info;
	OlsrT_Routing_Table_Entry*	olsr_rte_entry_ptr = OPC_NIL;
	void*						old_contents_ptr;
	
	/* Function to implement incremental routing addition	*/
	/* Function checks if a rte entry for this destination 	*/
	/* is present in Old OLSR table. If no, then create new	*/
	/* entry in IP Cmn Tbl and new OLSR tbl. If old entry 	*/
	/* exists and there's change in cost/nexthop, update IP	*/
	/* Cmn Tbl. Then add this entry in new OLSR table.		*/
	
	FIN (olsr_rte_table_incremental_entry_add (<args>));
	
	/* Get the outgoing port info */
	inet_local_intf_addr = inet_rtab_index_to_addr_convert (new_local_intf);
	inet_rte_is_local_address (inet_local_intf_addr, module_data_ptr, &intf_index);
	port_info = ip_rte_port_info_from_tbl_index (module_data_ptr, intf_index);
	
	/* First check if an entry for this dest exists in Old olsr rte tbl */
	if ((olsr_rte_entry_ptr = (OlsrT_Routing_Table_Entry*) 
		prg_bin_hash_table_item_remove (old_olsr_rte_table_ptr, &dest_addr)) != OPC_NIL)
		{
		/* Old Olsr entry exists */
		
		/* Check if there's change in nexthop or cost */
		if ((new_nexthop != olsr_rte_entry_ptr->next_addr) ||
			(new_cost != olsr_rte_entry_ptr->hops))
			{
			/* Either nexthop or path costs are different 	*/
			/* If nexthops are not different, do not send	*/
			/* new_next_hop info to IP.						*/
			if (new_nexthop == olsr_rte_entry_ptr->next_addr)
				inet_next_addr = INETC_ADDRESS_INVALID;
			else
				inet_next_addr = inet_rtab_index_to_addr_convert (new_nexthop);
			
			/* Get old next hop address */
			old_inet_next_addr = inet_rtab_index_to_addr_convert (olsr_rte_entry_ptr->next_addr);
			
			/* Update the IP Cmn Rte Table: using the old dest_prefix */
			Inet_Cmn_Rte_Table_Entry_Update (module_data_ptr->ip_route_table, olsr_rte_entry_ptr->dest_prefix,
				old_inet_next_addr, olsr_protocol_id, inet_next_addr, port_info, new_cost, OPC_NIL);
			
			/* Update the next_hop and cost of old entry */
			olsr_rte_routing_table_entry_update (olsr_rte_entry_ptr, new_nexthop, new_cost, new_local_intf);
			}
		
		/* Transfer the old rte entry to new olsr_routing_table */
		prg_bin_hash_table_item_insert (olsr_routing_table, &dest_addr, olsr_rte_entry_ptr, &old_contents_ptr);
		}
	else
		{
		/* This is a new entry. Add it in OLSR and IP Cmn Tbl */
		
		inet_dest_addr = inet_rtab_index_to_addr_convert (dest_addr);
		inet_next_addr = inet_rtab_index_to_addr_convert (new_nexthop);
		
		/* Create new dest_prefix */
		dest_prefix = ip_cmn_rte_table_dest_prefix_create (inet_dest_addr,
			(is_ipv6_enabled ? subnet_mask_128 : subnet_mask_32));
		
		/* Add in Olsr routing table */
		olsr_rte_routing_table_entry_add (dest_addr, new_nexthop, 
			new_cost, new_local_intf, dest_prefix);
		
		/* Add in IP Cmn Tbl */
		Inet_Cmn_Rte_Table_Entry_Add_Options (module_data_ptr->ip_route_table, OPC_NIL, dest_prefix,
			inet_next_addr, port_info, new_cost, olsr_protocol_id, 1, IPC_CMN_RTE_TABLE_ENTRY_ADD_INDIRECT_NEXTHOP_OPTION);
		
		}
	
	FOUT;
	}

/****** DJK related functions ******/

static void
olsr_rte_djk_rte_table_calculate (void)
	{
	PrgT_Vector*				edge_vector_ptr;
	PrgT_Vector*				vertex_vector_ptr;
	PrgT_Graph_Vertex*			vertex_ptr;
//	PrgT_Graph_Vertex*			next_hop_vertex_ptr;
	PrgT_Graph_Edge *			next_hop_edge_ptr;
	List*						keys_lptr;
	InetT_Address				inet_dest_addr, inet_next_addr, inet_local_intf_addr;
//	OlsrT_Djk_Edge_State*		edge_state_ptr;
	OlsrT_Djk_State*			next_hop_state_ptr;
	OlsrT_Djk_State*			dest_state_ptr;
	int							intf_index;
	IpT_Port_Info				port_info;
	int							num_edges = 0,num_vertex=0,num_edge=0;
	OlsrT_Routing_Table_Entry*	olsr_rte_entry_ptr = OPC_NIL;
	PrgT_Bin_Hash_Table*		old_olsr_rte_table;
	int							num_old_entries, k,m=0;
	InetT_Address				old_inet_next_addr;
	void*                       next_hops_ptr = PRGC_NIL;
	double                      path_cost;
	int                         num_next_hops = 0;
	PrgT_List*                  next_hops_lptr = PRGC_NIL;
	PrgT_Bin_Hash_Table*		intf_set_table_ptr;
	OlsrT_Interface_Set_Entry*	intf_set_entry_ptr;
	int							i=0;
//	int							index;
//	char 						  main_addr_str[20];
	double                       dist_edge;
	OlsrT_Djk_State*	         my_vertex_stat;
//	PrgT_Graph_Vertex*           min_vertex_ptr;
	PrgT_Graph_Edge *       	 my_edge;
	PrgT_Graph_Vertex*   	     my_vertex;
	PrgT_Vector*                 edges_vector_ptr=PRGC_NIL;
	PrgT_Graph_Vertex* 			 vertex_b;
	OlsrT_Djk_Edge_State*        edges_state_ptr;
	OlsrT_Djk_State*             state_nbr_vertex;
    PrgT_Vector*                 all_vertex_vector_ptr=PRGC_NIL;
	OlsrT_Djk_State*             min_vertex_stat;
	int							 num_vertexs=0;
	PrgT_Graph_Vertex*           min_vertex;
	OlsrT_Djk_State*             pred_state_vertex ;
	PrgT_Graph_Vertex*           pred_vertex;
	PrgT_Graph_Vertex*           vertex;
	PrgT_Graph_Edge *            simplex_edge;
	OlsrT_Djk_Edge_State*        simplex_edge_stat;
	/* Use DJK to build route table */
	FIN (olsr_rte_djk_rte_table_calculate (void));

	if (op_prg_odb_ltrace_active ("trace_rte_table")== OPC_TRUE)
		{
		op_prg_odb_print_major (pid_string, "\n Deleting all the entries of routing table \n", OPC_NIL);
		}

	/****************************************************/
	/******** Starting Cals for New Rte Table ***********/
	/****************************************************/
	
	//op_stat_write (global_stat_handles.rte_table_calcs_global_shandle, 1.0);
	
	/* First initialize the graph for PRG DJK.	*/
	prg_djk_graph_init (prg_graph_ptr);
	
	/* Enable the caching */
	prg_djk_graph_cache_enable (prg_graph_ptr);

	/* Set the weights to all edges */
	edge_vector_ptr = prg_graph_edge_all_get (prg_graph_ptr);
	
	num_edges = prg_vector_size (edge_vector_ptr);

	vertex_vector_ptr = prg_graph_vertex_all_get (prg_graph_ptr);
	all_vertex_vector_ptr = vertex_vector_ptr;
	num_vertex = prg_vector_size (vertex_vector_ptr);
	num_vertexs =prg_vector_size (all_vertex_vector_ptr);

	
	/****calculat the stable path to all dest****/
	while (num_vertexs > 0)/*s*/
		
		{
		     
		   int      H=0;
		   double   dist =1;
		   int      index=0;
		   int      m=0,vector_size=0;
		   int      l=0;
		   int        s=0;
//		   PrgT_Graph_Edge_Type* edge; 
		   
		   
		   num_vertexs =prg_vector_size (all_vertex_vector_ptr);
		   
		//printf("\n*////////////////////////////////////dans la boucle while////////////////////////////////\n");
		   
		 for (H =0 ; H < num_vertexs ;H++)
			   
			   { 
			      // printf("\n*--------------------------iteration N-----------------*%d\n",H);
			       my_vertex=(PrgT_Graph_Vertex*)  prg_vector_access (all_vertex_vector_ptr,H);
			       my_vertex_stat=(OlsrT_Djk_State*) prg_vertex_client_state_get(my_vertex,OLSRC_DJK_STATE);
				 //printf("\n*-------------------------- my vertex state-----------------*%g\n",my_vertex_stat->dist);
				 if (my_vertex_stat->dist < dist)
					 
					 {
					 //printf("\n*-------------test-------------\n");
					    dist= my_vertex_stat->dist;
						min_vertex=my_vertex;
					 	min_vertex_stat=my_vertex_stat;
						index=H;
					 }
				   
			
				}
		   
		   
		    (PrgT_Graph_Vertex*)prg_vector_remove(all_vertex_vector_ptr,index);
			num_vertexs =prg_vector_size (all_vertex_vector_ptr);
			edges_vector_ptr =(PrgT_Vector*) prg_vertex_edges_get (min_vertex, PrgC_Graph_Element_Set_Outgoing);
	        num_edge=prg_vector_size (edges_vector_ptr);
			//printf("\n*-------------test--%d-----------\n",num_edge);
			if (num_edge>0)
				{
				
			for (s=0; s<num_edge;s++)
			{
			  simplex_edge = (PrgT_Graph_Edge *) prg_vector_access (edges_vector_ptr, s);
			  simplex_edge_stat=(OlsrT_Djk_Edge_State*) prg_edge_client_state_get(simplex_edge,OLSRC_DJK_STATE);
			  if( simplex_edge_stat->neighbor_intf == min_vertex_stat->addr)
				  { 
				    //printf("\n*------------oui------------\n");
				    prg_vector_remove(edges_vector_ptr,s);
				  }
			  }
			 }
			  
		//printf("\n*-----------nombre des edgs---------------%d\n",num_edge);
			num_edge=prg_vector_size (edges_vector_ptr);
			if (num_edge >0)
				
				{ 
				   
			   for (m= 0;m < num_edge ; m++)
				   
				  {
				    my_edge = (PrgT_Graph_Edge *) prg_vector_access (edges_vector_ptr, m);
					vertex_b =prg_edge_vertex_b_get (my_edge);
	                edges_state_ptr = (OlsrT_Djk_Edge_State*) prg_edge_client_state_get (my_edge, OLSRC_DJK_STATE);
					state_nbr_vertex=(OlsrT_Djk_State *) prg_vertex_client_state_get(vertex_b, OLSRC_DJK_STATE);
				    dist_edge=edges_state_ptr->SDN;
		      //  printf("\n-------dist edge=-------(%g)-----dist noeud=----(%g)\n", edges_state_ptr->SDN,state_nbr_vertex->dist);
				
						   
				if ((dist_edge < state_nbr_vertex->dist)&&(min_vertex_stat->dist < state_nbr_vertex->dist))
				 
				 {
				//printf("\n--------------------dist edge != 0---------------------------(%g)\n", state_nbr_vertex->dist);
				   
				   state_nbr_vertex->dist=dist_edge;
				    num_vertex = prg_vector_size (vertex_vector_ptr);
					    if (num_vertex >0)
							{
					       for (i=0 ; i < num_vertex ; i++)
						      {
						               pred_vertex=(PrgT_Graph_Vertex*)  prg_vector_access (vertex_vector_ptr,i);
						               pred_state_vertex=(OlsrT_Djk_State*) prg_vertex_client_state_get(pred_vertex,OLSRC_DJK_STATE);
						      if (pred_state_vertex->addr == state_nbr_vertex->addr)
								  {
								    
							      pred_state_vertex->pred=min_vertex_stat->addr;
								  prg_vertex_client_state_set (pred_vertex, OLSRC_DJK_STATE, (void *) pred_state_vertex);
								  prg_vector_set (vertex_vector_ptr,pred_vertex,i);
								 //printf("\n*////////////////////////////////////////////////////////////////////%d\n",pred_state_vertex->pred);
								  }
							   }
						    }
				   
		         }
				
				
					
					}
			   
			    
			   
			   
			   }
			
			
			
			
			
			
		   }
		 
	
	/******test*****/
	 /*if (vertex_vector_ptr !=0)
		 {
	int    d=0;    
	OlsrT_Djk_State*   m_vertex_stat ;        
	PrgT_Graph_Vertex*	m_vertex;
	vertex_vector_ptr=prg_graph_vertex_all_get (prg_graph_ptr);
	 printf ("\n*************begin*******%d\n",num_vertex);
           for (d=0; d < num_vertex ;d++)
			   {
			        m_vertex=(PrgT_Graph_Vertex*)  prg_vector_access (vertex_vector_ptr,d);
			        m_vertex_stat=(OlsrT_Djk_State*) prg_vertex_client_state_get(m_vertex,OLSRC_DJK_STATE);  
					 printf ("\n*************%d*************dist= %g**********%d\n",m_vertex_stat->addr,m_vertex_stat->dist,m_vertex_stat->pred);
					}
	 printf ("\n*************end*******\n"); 
	
	}*/
 //olsr_rte_routing_table_print_to_string();

	/* If there are less than 1 ege, FOUT */
	if (num_edges < 1)
		{
		prg_vector_destroy (edge_vector_ptr, OPC_FALSE);
		FOUT;
		}

	
	/* Destroy the vector of edges.		*/
	prg_vector_destroy (edge_vector_ptr, PRGC_FALSE);

	/* Put the handle of olsr_routing_table into an old_olsr_rte_table_ptr */
	old_olsr_rte_table = olsr_routing_table;
	
	/* Create a new olsr_routing_table */
	olsr_routing_table = prg_bin_hash_table_create (4, 4);

	/* Invoke DJK for the root vertex.	*/
	if (prg_djk_single_source_compute_with_options (root_vertex_ptr, PRGC_DJK_SINGLE_SOURCE_COMPUTE_OPT_FIRST_HOP) == PrgC_Compcode_Failure)
		{
		/* Something went wrong while running DJK. 	*/
		/* Warn the user, and continue on.			*/
		op_sim_error(OPC_SIM_ERROR_WARNING, "Error while running PRG DJK on the OLSR Topology Graph", OPC_NIL);
		
		/* Disable the caching */
		prg_djk_graph_cache_disable (prg_graph_ptr);
		prg_djk_graph_init (prg_graph_ptr);
		
		FOUT;
		}
	
	/* Initialize the iterator for the routing table constructed at the source vertex by single_source_compute */
	if (!prg_djk_graph_routing_table_map_init (root_vertex_ptr))
		FOUT;

	/* Loop through the routing table entries */
	/* Calling entry_next_get without initializing the map iterator leads to undefined results */
	/* Return values: vertex_ptr = destn vertex, path_cost = cost to destn, next_hops_lptr = list of next hop nodes to destn */
	/* vertex_ptr should never be freed */
	/* Depending upon the value of prg_djk_edge_weight, next_hops_ptr is dereferenced - such an API has been provided for perf reasons */
	
	
	//printf("\nSrc		Dest		n_chemain		n_cost		path[i]\n\n");

	while ( prg_djk_graph_routing_table_map_entry_next_get  (root_vertex_ptr, &vertex_ptr, &path_cost, &next_hops_ptr, &num_next_hops))
		{
			
		int                     addr;
	    Boolean                 no_link=OPC_FALSE;
		OlsrT_Djk_State*        vertex_state;
		OlsrT_Djk_State*        root_vertex_state;
		
        vertex_state=(OlsrT_Djk_State*) prg_vertex_client_state_get(vertex_ptr,OLSRC_DJK_STATE);
		root_vertex_state=(OlsrT_Djk_State*) prg_vertex_client_state_get(root_vertex_ptr,OLSRC_DJK_STATE);
		addr=vertex_state->addr;
		//printf("\n---root_vertex ---%d---destination=---%d---\n",root_vertex_state->addr,vertex_state->addr);	
			
		/* Ignore if this is root vertex */ 
 		if (vertex_ptr == root_vertex_ptr)
			
			continue;
		
		
		if (path_cost == -1)
			{
			printf("one");
			continue;
			
			}
		
		/* Loop through the graph nodes */
		/*get the next hop for the destination*/
		//printf("\n-------adress=----%d----------%d--------\n\n",root_vertex_state->addr,addr);
	   while (addr != root_vertex_state->addr)
			   
			   {
			       int                  d=0;    
	               OlsrT_Djk_State*     m_vertex_stat;        
	               PrgT_Graph_Vertex*	m_vertex;
				   int                  path_cost=0;
	               vertex_vector_ptr=prg_graph_vertex_all_get (prg_graph_ptr);
				   num_vertex=prg_vector_size(vertex_vector_ptr);
				   
		    for (d=0; d < num_vertex ;d++)
			        {
					
			            m_vertex=(PrgT_Graph_Vertex*)  prg_vector_access (vertex_vector_ptr,d);
			            m_vertex_stat=(OlsrT_Djk_State*) prg_vertex_client_state_get(m_vertex,OLSRC_DJK_STATE);  
					   
						//printf ("\n---------------m_vertex_stat->addr--------%d---------%d \n",m_vertex_stat->addr,m_vertex_stat->pred);
						if (addr == m_vertex_stat->addr)
							
							 { 
							   no_link=OPC_TRUE;
							   //printf ("\n in the  if instruction\n");
							   addr=m_vertex_stat->pred;
							   next_hop_state_ptr=m_vertex_stat;
							   vertex=m_vertex;
							    
							 }
						
						
					
					}
				          
      					  
						  path_cost++;
						
						
				        //printf("\n---root_vertex ---%d---next_hop------%d---- to dest -------------%d\n\n",root_vertex_state->addr,next_hop_state_ptr->addr,vertex_state->addr);
				        /* if there is no link to dest break*/ 
					   if( no_link == OPC_FALSE)
							continue;
			     }
	
		
		
		op_stat_write (global_stat_handles.nbr_delete_global_shandle, path_cost);
		
		/* We are going to add this in route table */
		
		/************************************************/
		/*********** Get dest address, prefix ***********/
		/************************************************/
		
		/* Get the state_ptr of the vertex */
		dest_state_ptr = (OlsrT_Djk_State *) prg_vertex_client_state_get (vertex_ptr, OLSRC_DJK_STATE);
		
		/* Get the destination address & Create dest prefix */
		inet_dest_addr = inet_rtab_index_to_addr_convert (dest_state_ptr->addr);
		

		
		/************************************************/
		/*********** Get nexthop address ****************/
		/************************************************/
		
		//Find the best nexthop (tiebreaker for nexthops)
		if (num_next_hops != 1)
			next_hop_edge_ptr = olsr_rte_djk_next_hop_get (next_hops_lptr);
		
		/* Get the next hop vertex and nexthop address */
		//next_hop_vertex_ptr = prg_edge_vertex_b_get (next_hop_edge_ptr);
	    //next_hop_state_ptr = (OlsrT_Djk_State *) prg_vertex_client_state_get (next_hop_vertex_ptr, OLSRC_DJK_STATE);
		inet_next_addr = inet_rtab_index_to_addr_convert (next_hop_state_ptr->addr);
		
		/************************************************/
		/*********** Get outgoing port ******************/
		/************************************************/
		
		/* Get the edge state ptr  and local interface address */
		//edge_state_ptr = (OlsrT_Djk_Edge_State *) prg_edge_client_state_get (next_hop_edge_ptr, OLSRC_DJK_STATE);
		inet_local_intf_addr = inet_rtab_index_to_addr_convert (root_vertex_state->addr);
		//printf("\n--------edg state--------\n :%g",edge_state_ptr->SDN);
		
		//printf("\n\n\n code 2323  SDN= %g",edge_state_ptr->SDN);
			
		/*Get outgoing port info */
		inet_rte_is_local_address (inet_local_intf_addr, module_data_ptr, &intf_index);
		port_info = ip_rte_port_info_from_tbl_index (module_data_ptr, intf_index);
		
		/*****************************************************/
		/************ Check OLSR Table ***********************/
		/************** Update IP Table **********************/
		
		/* The next hop is NOT the node's main address, rather its interface address	*/
		//olsr_rte_table_incremental_entry_add (old_olsr_rte_table, dest_state_ptr->addr, next_hop_state_ptr->addr,
		//	path_cost, edge_state_ptr->local_intf);
		olsr_rte_table_incremental_entry_add (old_olsr_rte_table, dest_state_ptr->addr, next_hop_state_ptr->addr,
			path_cost, root_vertex_state->addr);
		//printf("\n Ara5:the conset is:%f\n",path_cost);

		/* When an entry corresponding to *any* prefix for the given node is added			*/
		/* we will add entries for *all* prefixes of this node through the same next hop.	*/
		/* This is valid due to the simple fact that if the SPT yields a next hop to reach	*/
		/* any prefix of the given node, the same next hop will be on at least one of the 	*/
		/* shortest hop paths to reach all prefixes of that node.							*/
		
		/* Prefixes of the node can be obtained through the global MID table						*/
		intf_set_table_ptr = olsr_support_interface_table_ptr_get ();
		
		/* If this table is NOT NIL, obtain the list of interfaces corresponding to the main address	*/
		/* of the current vertex.																		*/
		if (intf_set_table_ptr != OPC_NIL)
			{
			keys_lptr = (List*) prg_bin_hash_table_item_list_get (intf_set_table_ptr);
			for (i = 0; i < op_prg_list_size (keys_lptr); i++)
				{
				intf_set_entry_ptr = (OlsrT_Interface_Set_Entry*) op_prg_list_access (keys_lptr, i);
				
				/* If the entry's main address matches the current vertex's main address, add this interface	*/
				/* prefix to the routing table if applicable													*/
				if ((intf_set_entry_ptr->main_addr == dest_state_ptr->addr) && 
					(intf_set_entry_ptr->intf_addr != intf_set_entry_ptr->main_addr))
					olsr_rte_table_incremental_entry_add (old_olsr_rte_table, intf_set_entry_ptr->intf_addr, 
						next_hop_state_ptr->addr, path_cost, root_vertex_state->addr);
				}
			
			prg_list_destroy (keys_lptr, OPC_FALSE);
			}
		
		} /* End looping through all vertices */
		//op_stat_write (global_stat_handles.rte_table_calcs_global_shandle, 1.0);
	
	/* go through all the remaining entries in old OLSR rte table */
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (old_olsr_rte_table);
	num_old_entries = op_prg_list_size (keys_lptr);
	
	for (k=0; k < num_old_entries; k++)
		{
		/* for each entry in routing table */
		olsr_rte_entry_ptr = (OlsrT_Routing_Table_Entry*) op_prg_list_access (keys_lptr, k);
		prg_bin_hash_table_item_remove (old_olsr_rte_table, &(olsr_rte_entry_ptr->dest_addr));
		
		/* Get the old next hop address */
		old_inet_next_addr = inet_rtab_index_to_addr_convert (olsr_rte_entry_ptr->next_addr);
				
		/* Delete these entries from IP Rte table */
		Inet_Cmn_Rte_Table_Entry_Delete (module_data_ptr->ip_route_table, 
			olsr_rte_entry_ptr->dest_prefix, old_inet_next_addr, olsr_protocol_id);
		
		/* Destroy the dest_prefix */
		ip_cmn_rte_table_dest_prefix_destroy (olsr_rte_entry_ptr->dest_prefix); 	
		
		/* Destroy this entry from old olsr table */
		op_prg_mem_free (olsr_rte_entry_ptr);
		}
	
	/* Free the key list		*/
	/* but not the keys themselves as these are still in the hash table	*/
	prg_list_destroy (keys_lptr, OPC_FALSE);
	
	/* Destroy the old OLSR String HASH TaBLE */
	/* Does not destroy table values - but we do not expect any value to be there */
	prg_bin_hash_table_destroy (old_olsr_rte_table, OPC_NIL);
	
	/* Disable the caching */
	prg_djk_graph_cache_disable (prg_graph_ptr);
	
	/* Note: Make sure we do not need graph_init() here */
	//prg_djk_graph_init (prg_graph_ptr);

	FOUT;
	
	}
		
static PrgT_Graph_Edge*
olsr_rte_djk_next_hop_get (PrgT_List* nexthop_list_ptr)
	{
	int 				list_size, index;
	int					mprs_willingness = 1;
	int					non_mprs_willingness = 1;
	PrgT_Graph_Edge*	next_hop_edge_ptr;
	PrgT_Graph_Edge*	mprs_edge_ptr = OPC_NIL;
	PrgT_Graph_Edge*	non_mprs_edge_ptr = OPC_NIL;
	OlsrT_Djk_State*	next_hop_st_ptr;
	int 				selected=0;
	
	
	
	/* Obtain the MPR and non-MPR selector nodes with highest willingness 		*/
	/* then return element with highest willingness, MPR selector property		*/
	/* being used to break the tie.												*/
	FIN (olsr_rte_djk_next_hop_get (PrgT_Vector* nexthop_vector_ptr));
	
	list_size = prg_list_size (nexthop_list_ptr);
	for (index = 0; index < list_size; index++)
		{ 
		/* Access the first next-hop path in the path list.	*/
		next_hop_edge_ptr = (PrgT_Graph_Edge *) prg_list_access (nexthop_list_ptr, index);
		
//	ara_state = (OlsrT_Djk_State *) prg_vertex_client_state_get (prg_edge_vertex_a_get (next_hop_edge_ptr), OLSRC_DJK_STATE);

	//	printf("\ni=%d",index);
	//	print_vertex(" the noeud in Edge",prg_edge_vertex_b_get (next_hop_edge_ptr)," ");
	//	print_vertex(".....the noeud source",root_vertex_ptr,"");

		

 
		
		next_hop_st_ptr = (OlsrT_Djk_State *) prg_vertex_client_state_get (prg_edge_vertex_b_get (next_hop_edge_ptr), OLSRC_DJK_STATE);
		//printf("\n\n Ara:(%d)the Src Is (%d) the vertxRoot is (%d) \n",index,list_size,ara_state->addr,rootstate->addr);
		
		if (next_hop_st_ptr->mpr_selector)
			{//printf("\n will %d= %d",index,next_hop_st_ptr->willingness);
			/* It is a mpr selector */
			if ((mprs_edge_ptr == OPC_NIL) || 
				(next_hop_st_ptr->willingness > mprs_willingness))
				{
				mprs_edge_ptr = next_hop_edge_ptr;
				mprs_willingness = next_hop_st_ptr->willingness;
				//printf("%d will\n",mprs_willingness);
				}
			}
		else
			{
			if ((non_mprs_edge_ptr == OPC_NIL) ||
				(next_hop_st_ptr->willingness > non_mprs_willingness))
				{
			//	printf("\n will %d= %d",index,next_hop_st_ptr->willingness);
				non_mprs_edge_ptr = next_hop_edge_ptr;
				non_mprs_willingness = next_hop_st_ptr->willingness;
				//printf("%d will\n",non_mprs_willingness);
				}
			}
		}
	
	if (mprs_willingness < non_mprs_willingness)
		FRET (non_mprs_edge_ptr);
	FRET (mprs_edge_ptr);
	}
	

/***********************************************************/
/******* Incremental Graph Build Functions *****************/
/***********************************************************/

static void
olsr_rte_graph_nbr_add (OlsrT_Neighbor_Set_Entry* nbr_set_entry_ptr, OlsrT_Link_Set_Entry* link_set_entry_ptr)
	{
	PrgT_Graph_Vertex*			vertex_ptr = PRGC_NIL;
	PrgT_Graph_Edge*			edge_ptr = PRGC_NIL;
	OlsrT_Djk_State*			state_ptr;
	OlsrT_Djk_Edge_State*		edge_state_ptr;
	void*						old_entry = OPC_NIL;
	
	FIN (olsr_rte_graph_nbr_add (<args>));
	
	/* This is a symmetric and willing neighbor 	 */
	/* Check if vertex corresponding to main address */
	/* is not already present in the graph		   	 */
	if ((vertex_ptr = (PrgT_Graph_Vertex*) prg_bin_hash_table_item_get 
		(djk_hash_table_ptr, &(nbr_set_entry_ptr->nbr_addr))) == PRGC_NIL)
		{
		/* No such vertex already exists, Create new */
		vertex_ptr = prg_graph_vertex_insert (prg_graph_ptr);
				
		/* Allocate memory for an OLSR Vertex State.	*/
		state_ptr = (OlsrT_Djk_State *) op_prg_pmo_alloc (olsr_djk_state_pmoh);
				
		state_ptr->addr = nbr_set_entry_ptr->nbr_addr;
		state_ptr->willingness = nbr_set_entry_ptr->willingness;
		state_ptr->dist=4.2913541e+09;
				
		if (prg_bin_hash_table_item_get (mpr_selector_set_table, &(nbr_set_entry_ptr->nbr_addr)))
			state_ptr->mpr_selector = OPC_TRUE;
		else
			state_ptr->mpr_selector = OPC_FALSE;
				
		/* Set the client state on the vertex */
		prg_vertex_client_state_set (vertex_ptr, OLSRC_DJK_STATE, (void *) state_ptr);
				
		/* Insert this entry in hash table */
		prg_bin_hash_table_item_insert (djk_hash_table_ptr, &(nbr_set_entry_ptr->nbr_addr), vertex_ptr, &old_entry);
				
		}
	else
		{
		/* There's already an vertex created for this NBR */
		/* Make sure willingness and mpr_selector fields  */
		/* were correctly populated.					  */
								
		/* Get the state */
		state_ptr = (OlsrT_Djk_State *) prg_vertex_client_state_get (vertex_ptr, OLSRC_DJK_STATE);
				
		/* Set willingness and mpr_selector fields */
		state_ptr->willingness = nbr_set_entry_ptr->willingness;
				
		if (prg_bin_hash_table_item_get (mpr_selector_set_table, &(nbr_set_entry_ptr->nbr_addr)))
			state_ptr->mpr_selector = OPC_TRUE;
		else
			state_ptr->mpr_selector = OPC_FALSE;
		}
					
			
	/* Create an edge between root and this 1-hop nbr if its not already present */
	if ((edge_ptr = prg_graph_edge_exists (prg_graph_ptr, root_vertex_ptr, 
		vertex_ptr, PrgC_Graph_Edge_Simplex)) == PRGC_NIL)
		{
		/* Create an edge between this vertex and root vertex */

		edge_ptr = prg_graph_edge_insert (prg_graph_ptr, root_vertex_ptr, vertex_ptr, PrgC_Graph_Edge_Simplex);
				
		
				
		/* Populate edge_client state */
		edge_state_ptr = (OlsrT_Djk_Edge_State *) op_prg_pmo_alloc (olsr_djk_edge_state_pmoh);
		edge_state_ptr->local_intf = link_set_entry_ptr->key.local_intf_addr;
		edge_state_ptr->neighbor_intf = link_set_entry_ptr->key.nbr_intf_addr;
		edge_state_ptr->SDN=nbr_set_entry_ptr->stabilite.SDN;
		
		
		//printf("Mouloud %g",nbr_set_entry_ptr->stabilite.SDN);
		//
		// inserer votre sdn 
				
		prg_edge_client_state_set (edge_ptr, OLSRC_DJK_STATE, (void *) edge_state_ptr);

		}
	else
		{
		/* Edge already exists. Make sure the local_intf value is set correctly */
		/* Get the state */
				
		edge_state_ptr = (OlsrT_Djk_Edge_State *) prg_edge_client_state_get (edge_ptr, OLSRC_DJK_STATE);
		edge_state_ptr->local_intf = link_set_entry_ptr->key.local_intf_addr;
		edge_state_ptr->neighbor_intf = link_set_entry_ptr->key.nbr_intf_addr;
		edge_state_ptr->SDN=nbr_set_entry_ptr->stabilite.SDN;
		
		//edge_state_ptr->SDN
		// inserer votre sdn 
		
		
		}
		
	
	FOUT;
	}

static void
olsr_rte_graph_nbr_delete (OlsrT_Neighbor_Set_Entry* nbr_set_entry_ptr)
	{
	PrgT_Graph_Vertex*			vertex_ptr = PRGC_NIL;
	PrgT_Graph_Edge*			edge_ptr = PRGC_NIL;
	PrgT_Graph_Edge*			two_hop_edge_ptr;
	
	int							j;
	PrgT_Vector*				edge_vector_ptr;
	int							num_edges;	
	
	FIN (olsr_rte_graph_nbr_delete (<args>));
	
	/* Check if this nbr vertex exists in the graph */
	if ((vertex_ptr = (PrgT_Graph_Vertex*) prg_bin_hash_table_item_get 
		(djk_hash_table_ptr, &(nbr_set_entry_ptr->nbr_addr))) != PRGC_NIL)
		{
		/* This Nbr vertex exists in the graph */
		/* Check if there exist and edge between root vertex and this nbr */
		if ((edge_ptr = prg_graph_edge_exists (prg_graph_ptr, root_vertex_ptr, 
			vertex_ptr, PrgC_Graph_Edge_Simplex)) != PRGC_NIL)
			{
			/* An edge exists between root_vertex and this nbr */
			/* Delete this edge */
			prg_graph_edge_remove (prg_graph_ptr, edge_ptr, 1);
			}
		
		/* Get all the edges going out of this vertex and delete them */
		edge_vector_ptr = (PrgT_Vector *) prg_vertex_edges_get (vertex_ptr, PrgC_Graph_Element_Set_Outgoing);
		
		num_edges = prg_vector_size (edge_vector_ptr);
		
		for (j=num_edges -1; j >= 0; j--)
			{
			two_hop_edge_ptr = (PrgT_Graph_Edge *) prg_vector_remove (edge_vector_ptr, j);
			prg_graph_edge_remove (prg_graph_ptr, two_hop_edge_ptr, 1);
			}
		
		prg_vector_destroy (edge_vector_ptr, OPC_FALSE);

		} /* End - if we find nbr vertex */			
	
	FOUT;
	}

static void
olsr_rte_graph_two_hop_nbr_add (int nbr_addr, OlsrT_Two_Hop_Neighbor_Set_Entry* two_hop_entry_ptr)
	{
	PrgT_Graph_Vertex*			vertex_ptr = PRGC_NIL;
	PrgT_Graph_Vertex*			two_hop_vertex_ptr = PRGC_NIL;
	
	PrgT_Graph_Edge*			edge_ptr = PRGC_NIL;
	void*						old_entry = OPC_NIL;
	OlsrT_Djk_State*			state_ptr;
	OlsrT_Djk_State* 			one_hop_neighbor_state_ptr;
//	double 							SDN;
	OlsrT_Djk_Edge_State*       edge_state_ptr;
	

	
	FIN (olsr_rte_graph_two_hop_nbr_add (<args>));
		
	/* Check if this nbr vertex exists in the graph */
	if ((vertex_ptr = (PrgT_Graph_Vertex*) prg_bin_hash_table_item_get (djk_hash_table_ptr, &nbr_addr)) != PRGC_NIL)
		{
		/* This Nbr exists, add this two hop vertex in graph */
		
		/* Check if two-hop vertex is already present in the graph */
		if ((two_hop_vertex_ptr = (PrgT_Graph_Vertex*) prg_bin_hash_table_item_get(djk_hash_table_ptr, &(two_hop_entry_ptr->two_hop_addr))) == PRGC_NIL)
			{
			/* No such vertex already exists, Create new */
			two_hop_vertex_ptr = prg_graph_vertex_insert (prg_graph_ptr);
				
			/* Allocate memory for an OLSR Vertex State.	*/
			state_ptr = (OlsrT_Djk_State *) op_prg_pmo_alloc (olsr_djk_state_pmoh);
				
			state_ptr->addr = two_hop_entry_ptr->two_hop_addr;
			state_ptr->willingness = OLSRC_INVALID;
			state_ptr->dist=4.2913541e+09;
		
			/* Set the client state on the vertex */
			prg_vertex_client_state_set (two_hop_vertex_ptr, OLSRC_DJK_STATE, (void *) state_ptr);
					
			/* Insert this entry in hash table */
			prg_bin_hash_table_item_insert (djk_hash_table_ptr, &two_hop_entry_ptr->two_hop_addr, two_hop_vertex_ptr, &old_entry);
			}
				
		/* Either we have added new vertex for this 2-hop or it was already present */
		/* In either case, create an edge between 1-hop-nbr and 2-hop-nbr			*/
		
		/* If the neighbor has a willingness of NEVER, a link must not be added.	*/
		one_hop_neighbor_state_ptr = (OlsrT_Djk_State*) prg_vertex_client_state_get (vertex_ptr, OLSRC_DJK_STATE);
		if (one_hop_neighbor_state_ptr->willingness == OLSRC_WILL_NEVER)
			FOUT;
			
		/* Create edge only when edge does not exists */
		if (prg_graph_edge_exists (prg_graph_ptr, vertex_ptr, two_hop_vertex_ptr, PrgC_Graph_Edge_Simplex) == PRGC_NIL)
			{
			edge_ptr = prg_graph_edge_insert (prg_graph_ptr, vertex_ptr /*1-hop-nbr*/, two_hop_vertex_ptr /*2-hop-nbr*/, PrgC_Graph_Edge_Simplex);
			
			//state_vertex= (OlsrT_Djk_State*) prg_vertex_client_state_get (two_hop_vertex_ptr, OLSRC_DJK_STATE);
			//SDN=get_SDN(two_hop_entry_ptr->two_hop_addr);		
		//declarer eddge state ptr
			
		edge_state_ptr = (OlsrT_Djk_Edge_State *) op_prg_pmo_alloc (olsr_djk_edge_state_pmoh);
		edge_state_ptr->local_intf = nbr_addr;
		edge_state_ptr->neighbor_intf = two_hop_entry_ptr->two_hop_addr;
		edge_state_ptr->SDN=two_hop_entry_ptr->SDN;
		//printf("\n---------%g---------\n",edge_state_ptr->SDN);
			
		
		//edge_state_ptr->SDN
		// inserer votre sdn 
				
	//	prg_edge_client_state_set (edge_ptr, OLSRC_DJK_STATE, (void *) edge_state_ptr)
			
				
			/* Set OPC_NIL for client state edge */
			prg_edge_client_state_set (edge_ptr, OLSRC_DJK_STATE, (void *) edge_state_ptr);
			}

		}
	
	
	FOUT;
	}

static void
olsr_rte_graph_two_hop_nbr_delete (int nbr_addr, int two_hop_addr)
	{
	PrgT_Graph_Vertex*			vertex_ptr = PRGC_NIL;
	PrgT_Graph_Vertex*			two_hop_vertex_ptr = PRGC_NIL;
	PrgT_Graph_Edge*			two_hop_edge_ptr = PRGC_NIL;
	
	FIN (olsr_rte_graph_two_hop_nbr_delete (<args>));
	
	/* Check if this nbr vertex exists in the graph */
	if ((vertex_ptr = (PrgT_Graph_Vertex*) prg_bin_hash_table_item_get 
		(djk_hash_table_ptr, &nbr_addr)) != PRGC_NIL)
		{
		/* This Nbr vertex exists in the graph */
		/* Check if two-hop vertex is already present in the graph */
		if ((two_hop_vertex_ptr = (PrgT_Graph_Vertex*) prg_bin_hash_table_item_get 
			(djk_hash_table_ptr, &two_hop_addr)) != PRGC_NIL)
			{
			/* Check if there exist an edge between nbr and 2-hop-nbr */
			if ((two_hop_edge_ptr = prg_graph_edge_exists (prg_graph_ptr, vertex_ptr, 
				two_hop_vertex_ptr, PrgC_Graph_Edge_Simplex)) != PRGC_NIL)
				{
				/* An edge exists between nbr and this 2-hop-nbr */
				/* Delete this edge */
				prg_graph_edge_remove (prg_graph_ptr, two_hop_edge_ptr, 1);
				}
			}
		
		} /* End - if we find nbr vertex */			
	
	FOUT;
	}

static void
olsr_rte_graph_tc_add (OlsrT_TC_Set_Entry* tc_set_entry_ptr)
	{
	OlsrT_Djk_State* 	state_ptr;
	PrgT_Graph_Vertex *	vertex_ptr;
	PrgT_List_Cell *	dest_addr_list_cell_ptr;
	PrgT_List_Cell *	dest_SDN_list_cell_ptr;
	double              intf_SDN;
	int                 i=0;
	double*	            dest_SDN_ptr;
//    PrgT_Graph_Edge*    test_edge_ptr;
	OlsrT_Djk_Edge_State*  ara_edge;
	PrgT_Graph_Edge *     edge_ptr;
	
	FIN (olsr_rte_graph_tc_add (<args>));
	
	/* Check if this vertex is already present in the graph */
	if ((vertex_ptr = (PrgT_Graph_Vertex*) prg_bin_hash_table_item_get 
		(djk_hash_table_ptr, &(tc_set_entry_ptr->last_addr))) == PRGC_NIL)
		{
		/* No such vertex already exists, Create new */
		vertex_ptr = prg_graph_vertex_insert (prg_graph_ptr);
				
		/* Allocate memory for an OLSR Vertex State	*/
		state_ptr = (OlsrT_Djk_State *) op_prg_pmo_alloc (olsr_djk_state_pmoh);
				
		state_ptr->addr = tc_set_entry_ptr->last_addr;
		state_ptr->willingness = OLSRC_INVALID;
		state_ptr->dist=4.2913541e+09;
	
		/* Set the client state on the vertex */
		prg_vertex_client_state_set (vertex_ptr, OLSRC_DJK_STATE, (void *) state_ptr);
					
		/* Insert this entry in hash table */
		prg_bin_hash_table_item_insert (djk_hash_table_ptr, &(tc_set_entry_ptr->last_addr), vertex_ptr, OPC_NIL);
		}
		
	/* Either we've created new vertex for this MPR 	*/
	/* node or it was already present. In either case, 	*/
	/* vertex_ptr variable has its handle. 				*/
		
	/* Go through the MPR selectors this MPR node can reach */
	for (dest_addr_list_cell_ptr = prg_list_head_cell_get (&tc_set_entry_ptr->state_ptr->dest_addr_list),dest_SDN_list_cell_ptr = prg_list_head_cell_get (&tc_set_entry_ptr->state_ptr->SDN_list);
		 dest_addr_list_cell_ptr , dest_SDN_list_cell_ptr;
		 dest_addr_list_cell_ptr = prg_list_cell_next_get (dest_addr_list_cell_ptr), dest_SDN_list_cell_ptr = prg_list_cell_next_get (dest_SDN_list_cell_ptr))
		{
		
		
				
		
		PrgT_Graph_Vertex *	mprs_vertex_ptr;
		int * 				dest_addr_ptr = (int*) prg_list_cell_data_get (dest_addr_list_cell_ptr);			
 				
		dest_SDN_ptr= (double*) prg_list_cell_data_get (dest_SDN_list_cell_ptr);
		
		 intf_SDN=*dest_SDN_ptr;
		//printf("\n\n \t    103  %d  %g    %g",dest_SDN_ptr,*dest_SDN_ptr,&dest_SDN_ptr);
			
		if ((mprs_vertex_ptr = (PrgT_Graph_Vertex*) prg_bin_hash_table_item_get 
			(djk_hash_table_ptr, dest_addr_ptr)) == PRGC_NIL)
			{
			/* No such vertex already exists, Create new */
			mprs_vertex_ptr = prg_graph_vertex_insert (prg_graph_ptr);
				
			/* Allocate memory for an OSPF DJK node. */
			state_ptr = (OlsrT_Djk_State *) op_prg_pmo_alloc (olsr_djk_state_pmoh);
				
			state_ptr->addr = *dest_addr_ptr;
			state_ptr->willingness = OLSRC_INVALID;
			state_ptr->dist=4.2913541e+09;
	
			/* Set the client state on the vertex */
			prg_vertex_client_state_set (mprs_vertex_ptr, OLSRC_DJK_STATE, (void *) state_ptr);
					
			/* Insert this entry in hash table */
			prg_bin_hash_table_item_insert (djk_hash_table_ptr, dest_addr_ptr, mprs_vertex_ptr, OPC_NIL);
			}
			
		/* Either we created new vertex or it was already present 	*/
		/* In either case, we will create edge between MPR node		*/
		/* and MPR selector node. 									*/
		if (prg_graph_edge_exists (prg_graph_ptr, vertex_ptr, mprs_vertex_ptr, PrgC_Graph_Edge_Simplex) == PRGC_NIL)
			{
			 edge_ptr = prg_graph_edge_insert (prg_graph_ptr, vertex_ptr /*mpr-node*/, mprs_vertex_ptr /*mpr-selector-node*/, PrgC_Graph_Edge_Simplex);
			
			
			
			
			ara_edge  = (OlsrT_Djk_Edge_State *) op_prg_pmo_alloc (olsr_djk_edge_state_pmoh);
			ara_edge->SDN=intf_SDN;
			ara_edge->local_intf=tc_set_entry_ptr->last_addr;
			ara_edge->neighbor_intf=*dest_addr_ptr;
			//printf("\n\n\n\n\n\n\n\n jiji   %g",intf_SDN);
		
			/* Set OPC_NIL for client state edge */
			prg_edge_client_state_set (edge_ptr, OLSRC_DJK_STATE, (void *) ara_edge );
				
	
			}
		
		/*if ((test_edge_ptr=prg_graph_edge_exists (prg_graph_ptr, vertex_ptr, mprs_vertex_ptr, PrgC_Graph_Edge_Simplex)) == PRGC_NIL)
			printf("in if");
		else
			 {OlsrT_Djk_Edge_State* ara_edgea;
			 ara_edgea= (OlsrT_Djk_Edge_State *)prg_edge_client_state_get (test_edge_ptr, OLSRC_DJK_STATE);

			 if(ara_edgea!=OPC_NIL)		          
			 
			 printf("\n\n ja3far %g",ara_edge->SDN);
			 }
			
	*/
		
		} /* End loop through mpr-selectors */
	
	FOUT;
	}

static void
olsr_rte_graph_tc_delete (OlsrT_TC_Set_Entry* tc_set_entry_ptr)
	{	
	PrgT_Graph_Vertex* 			vertex_ptr;
	
	FIN (olsr_rte_graph_tc_delete (<args>));
	
	/* Check if this vertex is already present in the graph */
	if ((vertex_ptr = (PrgT_Graph_Vertex*) prg_bin_hash_table_item_get 
		(djk_hash_table_ptr, &(tc_set_entry_ptr->last_addr))) != PRGC_NIL)
		{
		/* Mpr vertex already exists */
		PrgT_List_Cell* list_cell_ptr;
		
		for (list_cell_ptr = prg_list_head_cell_get (&tc_set_entry_ptr->state_ptr->dest_addr_list);
			 list_cell_ptr;
			 list_cell_ptr = prg_list_cell_next_get (list_cell_ptr))
			{
			PrgT_Graph_Vertex* 		mprs_vertex_ptr;
			int * dest_addr_ptr 	= (int*) prg_list_cell_data_get (list_cell_ptr);
			
			/* Check if mpr-selector vertex exists */
			if ((mprs_vertex_ptr = (PrgT_Graph_Vertex*) prg_bin_hash_table_item_get 
				(djk_hash_table_ptr, dest_addr_ptr)) != PRGC_NIL)
				{				
				PrgT_Graph_Edge*			mpr_edge_ptr;
				
				/* Check if edge between MPR and Mpr-Selector exists */
				if ((mpr_edge_ptr = prg_graph_edge_exists (prg_graph_ptr, vertex_ptr, 
					mprs_vertex_ptr, PrgC_Graph_Edge_Simplex)) != PRGC_NIL)
					{
					/* Delete the edge between MPR and Mpr-Selector */
					prg_graph_edge_remove (prg_graph_ptr, mpr_edge_ptr, 1);
					}
				}
			} /* End for looping of mpr-selectors */
		} /*end if MPR vertex exists */	
		
	FOUT;
	}








/////////////////////////////////////////////////////stabel Route/////////////////////////////////////////////////
//void chemin_stable ()
	//{
	

/***********************************************************************************************/
void Olsr_Valeur_du_Signal(OlsrT_Neighbor_Set_Entry** noeud,double signal)
	{
	
	
	FIN (Olsr_Valeur_du_Signal (void));
	
//	   noeud->val_signal->val_signal[noeud->val_signal->nbr_msg_recevu++]=signal;
	//noeud->val_signal->val_signal[*noeud->val_signal->nbr_msg_recevu++]=signal;
//noeud.val_signal.val_signal[noeud.val_signal.nbr_msg_recevu++]=signal;
		
	FOUT;
	}

double Sous(double a,double b)
	{
	
	double c;
	FIN (Sous (<args>));
	if(a==b)
		c=0.0;
	else{
		if (a>b)printf("\nA (%g) biggest then B (%g)",a,b);
			else printf("\nB (%g) biggest then A (%g)",b,a);
		 c=a-b;
		}
	FRET (c);
	}








/***********************************************************************************************/

void Olsr_calculer_stablilte(int adr,double power)
	{
		

		double 	 fs=0.0;//return fonction de stabilite
		double 	 fs2=0.0;		
//int		 i;
//int 	 max; // max 
		double 	 Xbar=0.0;//esperance mathematique
		double Ara_power=0.01,Ara_fs=0.02;
	
		double  arabica1=2.738e-14;
		double  arabica2=3.23e-27;
		double   vitesse,zone_local;
		int     nbr_msg_hello;
        int	    i,zone_franchis;
		
		double 	zone_nouveau,zone_ancien;
		int nbr_msg_recevu=0;
		//double 	 Xbar2;
		double x=0, y=0, z=0;
	//	double n;
		
	//	double xi;
//	int n,Sum;
		
		OlsrT_Neighbor_Set_Entry*			ara;
		
		FIN (Olsr_calculer_stablilte(<args>));
		vitesse=1;
		zone_local=1.0;
		
		
		//power=2.72e-18;
		
		ara=(OlsrT_Neighbor_Set_Entry*) olsr_rte_neighbor_set_entry_get (adr);
	
		
		nbr_msg_hello = ara->val_signal.nbr_msg_recevu;
 //   printf("\n\n\n\n****************************\n\n")	;
	//printf("Le voisin = %d a envoy = %d Messages Hello",ara->nbr_addr,nbr_msg_hello);
	
	
//max=((ara->val_signal.nbr_msg_recevu>=40)?ara->val_signal.nbr_msg_recevu%40:ara->val_signal.nbr_msg_recevu);
		
	
		
//	if(max==8)power-=0.00001e-14;
		
	//ara->val_signal.val_signal[max]=power;

    zone_local = (ara->val_signal.val_signal[nbr_msg_hello-1])*10000.0;
		
	//printf("\non this case je recevu  %:8:2f et %g",ara->val_signal.val_signal[ara->val_signal.nbr_msg_recevu],rcvd_power);
	//ara->val_signal.nbr_msg_recevu++;
    //printf(" Zone locale %g \n",zone_local);
		
		
		
		
		//Vitesse ;
			
				
				zone_franchis =0;
				zone_ancien=0;
				
				for (i = 0;i < nbr_msg_hello ;i++ ) 
					{
						zone_nouveau = ara->val_signal.val_signal[i];
			            
						//printf(" \n *********************************** i== %d   val_signal = %g zone_nouveau == %d \n \n",i, ara->val_signal.val_signal[i],zone_nouveau);
						
						
						if (i != 0)
						{
		
						   if(zone_nouveau != zone_ancien)
							{
							
							     zone_franchis++;
							//	 printf(" \n *********************************** i== %d   zone_ancien == %g zone_nouveau == %g \n \n",i, zone_ancien,zone_nouveau);
								
							}
						
						}
						
							zone_ancien = zone_nouveau;

					}
		
		
				
				vitesse = (double) zone_franchis/(ara->val_signal.temps2 - ara->val_signal.temps1);
 
		  //  printf("\n");
		//	printf("zone_franchis= %d  temps1 = %f temps2 = %f vitesse = %f\n \n",zone_franchis,ara->val_signal.temps1 , ara->val_signal.temps2, vitesse);						
				 
			
			
			
			
		
		
		//calcul de fs;
				
				
				nbr_msg_recevu=ara->val_signal.nbr_msg_recevu;
				x=0.0;
				
				for(i=0; i<nbr_msg_recevu; i++)
				{
					x += (((ara->val_signal.val_signal[i])*(ara->val_signal.val_signal[i]))/nbr_msg_recevu);

					//printf( "\n x= %g ",x);
				}
            
				y=0.0;
				
                for(i=0; i<nbr_msg_recevu; i++)
				{
					y+= ((ara->val_signal.val_signal[i])/nbr_msg_recevu);

					//printf( "\n y = %g ", y);
				}
			
				z= y*y; 
				//printf( "\n z= %g ", z);
				fs = x-z;
				//printf( "\n fs= %g ", fs);




	fs= fs * vitesse * zone_local;	
         printf(" \n");
	     printf(" fs =  %g \n  vitesse= %f \n zone_local= %d \n \n",fs,vitesse,zone_local);
				
				
		
		
		
		
		/*
		
		
		
		
		
		
		
		
		
		
		
		
		//if(ara->val_signal.nbr_msg_recevu>=40)max=40;
		//else
				max = ara->val_signal.nbr_msg_recevu;
		printf("\n\n\n\n****************************\n\n")	;
				//printf("\n max= %d",  ara->val_signal.nbr_msg_recevu);
		

				max--;
	max=((ara->val_signal.nbr_msg_recevu>50)?ara->val_signal.nbr_msg_recevu%50:ara->val_signal.nbr_msg_recevu);
		
		printf("max value %d \n",max);
		
		
		
		
		/****************************************************************/
		
		
		
		
/*if((max==0)&&(ara->val_signal.nbr_msg_recevu!=0))	
		{
		fs=0.0;
		printf("\n    www.Thardet.com %d",ara->val_signal.nbr_msg_recevu);}
	else
		{
		//
		
		
		
	for(i=0;i<max;i++)
		{
		Xbar+=(ara->val_signal.val_signal[i]);
	printf("\n X[%d]= %g",i,(ara->val_signal.val_signal[i]));
		}
	Xbar/=max;
	//Xbar+=5;
	printf("\n Xbar=%g",Xbar);
	for(i=0;i<max;i++)
		{		}
	fs/=max;
	
	
 
	//printf("NEIGHBOR BATTERY  = %d  \n",ara->energie );
	fs-=(Xbar*Xbar);
		 Xbar2= Xbar* Xbar;

//fs= Sum(xi*xi/n)- (Xbar2) //variance;
	fs= Xbar-Xbar2;

	printf("\n  Xbar2 =%g ",  Xbar2);
	printf("\n fs=%g", fs);
	
	//	printf("\n (xi2/n-Xbar2)=( %g ) -( %g )= ( %g ) ara souti n ",fs,Xbar2,Sous(fs,Xbar*Xbar));
	
		//printf("\n fs =%g ", fs);


	
	
/*	
	if(fs<0)fs*=-1;
//	if(fs>1e-45)
	{
//	print_addr(own_main_address);	
//	printf("\n	%g - %g =	 %g		",fs+Xbar*Xbar,Xbar*Xbar,fs);
//	print_addr(adr);
	
/*	printf("\n	%g	 %g		",Xbar-3*sqrt(fs),Xbar+3*sqrt(fs));
	printf("\n	%g	 %g		",Xbar-2*sqrt(fs),Xbar+2*sqrt(fs));
	printf("\n	%g	 %g		",Xbar-1*sqrt(fs),Xbar+1*sqrt(fs));*/
	//printf("\n");
		
	//}
	/*if(fs<0)fs*=-1;
	
//printf("\nthe max address %d val=%g ",max,fs);
	}
	
	
	/*fs=fs*vitesse*zone_local;	*/
	//ara->stabilite.SDN=fs* ara->val_signal.val_signal[max]/(ara->energie*test_energy(ara->energie));
	/*bn resultats sauf il s'affiche pas le packet draped*/
   
	//printf("fs =  %g \n   of @ %g",own_main_address,ara->stabilite.SDN );
	
/*printf("\n________________________________________________________");
	printf("\nIts one");
	printf("\npower=%g,\n Fs=%g \n Codeur=%g",power,fs,Codeur(power,fs));

	
	Decodeur(Codeur(power,fs),&Ara_power,&Ara_fs);
	printf("\nAra_pwer=%g \n Ara_fs=%g",get_sdn_fs(Codeur(power,fs),SDN_POWER),get_sdn_fs(Codeur(power,fs),SDN_FS));
	
*/		
	
	FOUT;
	}
	


		
	void
prg_djk_example_code ()
	{
	int i, vsize;
	PrgT_Graph_State_ID state_id;
	PrgT_Graph *graph_ptr;
	PrgT_Graph_Vertex *vtx_a_ptr, *vtx_b_ptr;
	PrgT_Graph_Vertex *vtx_c_ptr, *vtx_d_ptr;
	PrgT_Graph_Edge *edge_ab_ptr, *edge_bd_ptr;
	PrgT_Graph_Edge *edge_ac_ptr, *edge_cd_ptr;
	PrgT_Graph_Edge *edge_ptr;
	PrgT_Vector *path_set_vptr, *path_vptr;
	PrgT_Compcode status;

	FIN (prg_djk_example_code (void));

	/* Register handlers for our namespace. */
	state_id = prg_graph_state_handler_register (EXAMPLE_NAMESPACE,
	EXAMPLE_STATE, PRGC_NIL, PRGC_NIL);

	if (state_id == PRGC_GRAPH_INVALID_ID)
		FOUT;

	graph_ptr = prg_graph_create (EXAMPLE_NAMESPACE);

	/* Build up the following graph. */
	/*       */
	/*   B   */
	/*  / \  */
	/* A   D */
	/*  \ /  */
	/*   C   */
	/*       */

	/* Insert Vertices. */
	vtx_a_ptr = prg_graph_vertex_insert (graph_ptr);
	vtx_b_ptr = prg_graph_vertex_insert (graph_ptr);
	vtx_c_ptr = prg_graph_vertex_insert (graph_ptr);
	vtx_d_ptr = prg_graph_vertex_insert (graph_ptr);

	/* Insert edges. */
	edge_ab_ptr = prg_graph_edge_insert (graph_ptr, vtx_a_ptr,
		vtx_b_ptr, PrgC_Graph_Edge_Duplex);

	edge_ac_ptr = prg_graph_edge_insert (graph_ptr, vtx_a_ptr,
		vtx_c_ptr, PrgC_Graph_Edge_Duplex);

	edge_bd_ptr = prg_graph_edge_insert (graph_ptr, vtx_b_ptr,
		vtx_d_ptr, PrgC_Graph_Edge_Duplex);

	edge_cd_ptr = prg_graph_edge_insert (graph_ptr, vtx_c_ptr,
		vtx_d_ptr, PrgC_Graph_Edge_Duplex);

	/* Initialize the DJK state on our graph */
	status = prg_djk_graph_init (graph_ptr);
	if (status == PrgC_Compcode_Failure)
		{ prg_graph_destroy (graph_ptr, PRGC_TRUE); FOUT; }

	/* The DJK graph structure is now initialized. Configure parameters.    */

	/* Set the edge weights:                                                */
	/* A-B => 1; A-C => 2; B-D => 2; C-D => 1                               */
	/* This graph has two shortest-paths from vertex A to vertex D          */
	prg_djk_edge_weight_set (edge_ab_ptr, 1);
	prg_djk_edge_weight_set (edge_ac_ptr, 2);
	prg_djk_edge_weight_set (edge_bd_ptr, 2);
	prg_djk_edge_weight_set (edge_cd_ptr, 1);

	
	printf ("\tEdge address: (%lx)\n", (long) edge_ab_ptr);
	printf ("\tEdge address: (%lx)\n", (long) edge_ac_ptr);
	printf ("\tEdge address: (%lx)\n", (long) edge_bd_ptr);
	printf ("\tEdge address: (%lx)\n", (long) edge_cd_ptr);
	/* Now the graph is ready for path calculations.                        */ 

	/***** Example 1: Compute a single path.                           *****/
	printf ("\nExample 1:\n");

	/* First, compute a path between vertex A and vertex B                  */
	/* Since we have not run prg_djk_all_source_compute(), the path         */
	/* will be computed without consulting routing tables.                  */
	path_set_vptr = prg_djk_path_get (vtx_a_ptr, vtx_b_ptr);
	printf ("Path set contains %d path(s).\n", prg_vector_size (path_set_vptr));

	/* path_set_vptr is a vector (set) of vectors (paths) of edges.         */
	/* There is one path from A to B, so path_set_vptr contains one vector. */
	path_vptr = (PrgT_Vector *) prg_vector_access (path_set_vptr, 0);

	/* path_vptr contains a single edge: edge_ab_ptr */
	printf ("Path vector contains %d edge(s).\n", prg_vector_size (path_vptr));
	edge_ptr = (PrgT_Graph_Edge *) prg_vector_access (path_vptr, 0);
	printf ("Path's edge is%s edge_ab_ptr\n",
		(edge_ptr == edge_ab_ptr) ? "" : " not");

	/* We are done with the path and the path set, deallocate them: */
	/* The contained edge is owned by the graph, so do not destroy elements. */
	prg_vector_destroy (path_vptr, PRGC_FALSE); 

	/* The paths have just been freed; do not re-free the path_set elements. */
	prg_vector_destroy (path_set_vptr, PRGC_FALSE);

	/***** Example 2: Compute all-pairs shortest paths.                  *****/
	printf ("\nExample 2:\n");

	/* Note that we do not re-initialized the DJK state or the edge weights  */
	/* to run another path calculations.                                     */
	status = prg_djk_all_sources_compute (graph_ptr);
	if (status == PrgC_Compcode_Failure)
		{ prg_graph_destroy (graph_ptr, PRGC_TRUE); FOUT;}


	/* With routing tables established, every call to prg_djk_path_get will  */
	/* use the routing tables to get the paths and will not recompute paths  */

	/* Get the total cost of the path between A and D                        */
	/* Note that no path vector is needed.                                   */
	printf("The total cost of the shortest path between A and D is: %f\n",
		prg_djk_path_cost_get (vtx_a_ptr, vtx_d_ptr));

	/* Retrieve the path set from A to D, there are 2. */
	path_set_vptr = prg_djk_path_get (vtx_a_ptr, vtx_d_ptr);

	/* Confirm that there are 2 paths */
	printf ("Path set contains %d path(s).\n", prg_vector_size (path_set_vptr));
	if (prg_vector_size (path_set_vptr) != 2)
		{
		prg_vector_destroy (path_set_vptr, PRGC_TRUE);
		prg_graph_destroy (graph_ptr, PRGC_TRUE);
		FOUT;
		}

	/* Retrieve the second path */
	printf ("Displaying  path:\n", prg_vector_size (path_set_vptr));
	path_vptr = prg_vector_access (path_set_vptr, 0);
	vsize = prg_vector_size (path_vptr);
	for (i=0; i< vsize; i++)
		{
		PrgT_Graph_Edge *edge_ptr = 
			(PrgT_Graph_Edge *) prg_vector_access (path_vptr, i);

		/* For each edge in the path, perform some operation */
		printf ("\tEdge address: (%lx)\n", (long) edge_ptr);
		}

	/* Deallocate paths and path set */

	vsize = prg_vector_size (path_set_vptr);
	for (i=0; i< vsize; i++)
		{
		PrgT_Vector *vptr = (PrgT_Vector *) prg_vector_access (path_set_vptr, i);
			prg_vector_destroy (vptr, PRGC_FALSE); 
		}
	prg_vector_destroy (path_set_vptr, PRGC_FALSE);

	/* Clean up.*/
	prg_graph_destroy (graph_ptr, PRGC_TRUE);
	FOUT;
	} 
	
		
	void print_vertex(char* s1,PrgT_Graph_Vertex * vertex,char* s2)	
		{
		
		OlsrT_Djk_State* 		ara_state;
		char  add[20];
		InetT_Address		inet_local_intf_addr;
		
		FIN (print_vertex(<args>));
		
		ara_state = (OlsrT_Djk_State *) prg_vertex_client_state_get (vertex, OLSRC_DJK_STATE);
		
		
		

			inet_local_intf_addr = inet_rtab_index_to_addr_convert (ara_state->addr);
	
            inet_address_print (add, inet_local_intf_addr);

			
		
		
		printf(s1);
		
		
		printf(" %s ",add);
		
		printf(s2);
		
		FOUT;
		}
		
	
	
	double* get_SDN(int addr)
		{
	
		
		OlsrT_Neighbor_Set_Entry* 	nbr_set_entry_ptr = OPC_NIL;
		double*                new_SDN_ptr;
	
			
		FIN (get_SDN(int));
		nbr_set_entry_ptr = (OlsrT_Neighbor_Set_Entry*) 
			prg_bin_hash_table_item_get (neighbor_set_table, &addr);

		new_SDN_ptr = (double*) op_prg_pmo_alloc (sdn_pmh);
		*new_SDN_ptr = nbr_set_entry_ptr->stabilite.SDN;
		
		FRET(new_SDN_ptr);  
   
 
		}
	
	


void print_addr(int addr)
	{
	
		InetT_Address				inet_nbr_addr;
	char str[20];
	
		FIN (get_addr_str(<args>));
	
			inet_nbr_addr = inet_rtab_index_to_addr_convert (addr);
			inet_address_print (str, inet_nbr_addr);
		printf(" %s",str);
		
		FOUT;
	
	}


void	olsr_rte_calculate_FdN(void)
	{
	OlsrT_Two_Hop_Neighbor_Set_Entry*	voisin_de_deux_sauts;/*two_hop_nbr_entry_ptr*/
	OlsrT_Neighbor_Set_Entry*			nbr_entry_ptr;
	List*								keys_lptr;
	int									i, num_keys;
	int									j, num_one_hop_nbrs;
	OlsrT_Nbr_Addr_Two_Hop_Entry*		Voisin = OPC_NIL;
	OlsrT_Neighbor_Set_Entry*			Voisin_Candidat;
		
		
		
	FIN(olsr_rte_calculate_FdN(void))

	
/****************************************************/
update_conf();/*initialiser Le FdN tous les noeud dans le voisinage*/
/****************************************************/
	
	
	
if(Sim_Type!=TYPE_STANDARD)	
{
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (two_hop_nbr_set_table);
	num_keys = op_prg_list_size (keys_lptr);
	
	/* For each entry in two hop neighbor table	*/
	//printf("il y'a %d noeud(s) 2-hop",num_keys);
	//if(!num_keys)F;
	for (i=0; i< num_keys; i++)
		{
		/* Get the two-hop-nbr entry ptr */
		voisin_de_deux_sauts = (OlsrT_Two_Hop_Neighbor_Set_Entry*) op_prg_list_access (keys_lptr, i);
		
		//si l'@ de 2-hop ==mon @ alors Skip
		if (voisin_de_deux_sauts->two_hop_addr == own_main_address)
			{
			continue;
			}
			
		/* Initializing nbr ptr */
		nbr_entry_ptr = OPC_NIL;
		
		/* Checking if this 2-hop-nbr is a SYM NBR */
		/*ce noeud de deux saut est aussi d'un seul saut  Skip it*/
		nbr_entry_ptr = (OlsrT_Neighbor_Set_Entry*) 
			prg_bin_hash_table_item_get (neighbor_set_table, &(voisin_de_deux_sauts->two_hop_addr));
		
		/* Check the SYM-nbr condition */
		if ((nbr_entry_ptr != OPC_NIL) &&
			(nbr_entry_ptr->status == OLSRC_SYM_STATUS))
			{
			/* This 2-hop nbr is my SYM voisin */
			/* Skip this 2-hop voisisn			*/
			continue;
			}
	/*	if(!voisin_de_deux_sauts->strict_two_hop)
			continue;
			
			
			/* Get the number of one-hop-nbr to reach this 2-hop-nbr */
			
			num_one_hop_nbrs = op_prg_list_size (&voisin_de_deux_sauts->neighbor_list);
	/****************************************************************************/		
		/*	if(own_main_address==0){
			printf("\n****** number of two hops %d --->",num_one_hop_nbrs);
			print_addr(voisin_de_deux_sauts->two_hop_addr);
			}*
   /****************************************************************************/		
			
			//if(num_one_hop_nbrs>1)
			{ double Temp_SdN=51.0,Temp_Signal=-51.0;
			
				for (j=0; j< num_one_hop_nbrs; j++)
				{
				/* For each one hop nbr addr */
				Voisin = (OlsrT_Nbr_Addr_Two_Hop_Entry*)
					op_prg_list_access (&voisin_de_deux_sauts->neighbor_list, j);

				/* Get the neighbor entry ptr */
			/*	if(Voisin->SDN> Temp_SdN)
					{
					Temp_SdN=Voisin->SDN;
					Voisin_Candidat=Voisin->nbr_ptr;					
					}
			*/
				
				if(Sim_Type==TYPE_POWER)
					{
				
					if(get_sdn_fs(Voisin->SDN,SDN_POWER) > Temp_Signal)
						
						{
						Temp_Signal=get_sdn_fs(Voisin->SDN,SDN_POWER);
						Voisin_Candidat=Voisin->nbr_ptr;
						}
					}
				else
					{
						if(Sim_Type==TYPE_FS)
							{
					
							if(get_sdn_fs(Voisin->SDN,SDN_FS)< Temp_SdN)
						
								{
								Temp_SdN=get_sdn_fs(Voisin->SDN,SDN_FS);
								Voisin_Candidat=Voisin->nbr_ptr;
								}
							}
						else
							{
							if(Sim_Type==TYPE_POWER_FS)
								{
					
								if(get_sdn_fs(Voisin->SDN,SDN_FS)< Temp_SdN)
						
									{
									Temp_SdN=get_sdn_fs(Voisin->SDN,SDN_FS);
									Voisin_Candidat=Voisin->nbr_ptr;
									}
								}
							else
								{
								if((get_sdn_fs(Voisin->SDN,SDN_FS)== Temp_SdN)&&
									(get_sdn_fs(Voisin->SDN,SDN_POWER) > Temp_Signal))
									{
										Temp_SdN=get_sdn_fs(Voisin->SDN,SDN_FS);
										Temp_Signal=get_sdn_fs(Voisin->SDN,SDN_POWER);
										Voisin_Candidat=Voisin->nbr_ptr;
									}
								}
							}
						}
			
				
				}

				Voisin_Candidat->conf++;
			/*	if(own_main_address==0){
				printf("\nCalcule de FdN de :");print_addr(Voisin_Candidat->nbr_addr);
				printf(", Son SDN: %g",Voisin_Candidat->stabilite.SDN);
				}*/
				
			
			}
		
		}/*end for*/
		
	prg_list_destroy (keys_lptr, OPC_FALSE);
	}
	FOUT;
	}


static Boolean get_conf_tow_hop(double *Temp,OlsrT_Nbr_Addr_Two_Hop_Entry* voisin)
{
Boolean						is_great = OPC_FALSE;
	FIN(get_conf_tow_hop(double* ,OlsrT_Nbr_Addr_Two_Hop_Entry*))

	is_great=OPC_TRUE;
	
	FRET(is_great);
}

void update_conf(void)
	{	
	
	OlsrT_Neighbor_Set_Entry*			nbr_entry_ptr=OPC_NIL;
	List*								keys_lptr;

	PrgT_List_Cell	* key_cell_ptr;
	
			
	FIN(update_conf(void))

		
	keys_lptr = (List*) prg_bin_hash_table_item_list_get (neighbor_set_table);

	
	for (key_cell_ptr = prg_list_head_cell_get (keys_lptr);
		 key_cell_ptr;
		 key_cell_ptr = prg_list_cell_next_get (key_cell_ptr))
		{
		/* For each entry value in neighbor table	*/
		OlsrT_Neighbor_Set_Entry * nbr_entry_ptr =
			(OlsrT_Neighbor_Set_Entry*) prg_list_cell_data_get (key_cell_ptr);
		
		nbr_entry_ptr->conf=0;
		}
	FOUT;
	}


	float signal_to_int(float a)
	{	
	
		double i=0;		
		int		alpha=0;
		
	FIN	(signal_to_int(float));
		FRET(a);
		
	/*	while(a<1)
		{
			i++;
			a*=10;

		}
	alpha=a*100;
	alpha=999-alpha;
	i=i*100+alpha;
	*/	

	}
	

	/*
char* get_addr_str(int addr)
	{
	
		InetT_Address				inet_nbr_addr;
	char* str=OPC_NIL;
		//char* str2;
	
		FIN (get_addr_str(<args>));
	
			inet_nbr_addr = inet_rtab_index_to_addr_convert (addr);
			inet_address_print (str, inet_nbr_addr);
		//*str2=str;
		FRET(str);
	
	}

		*/
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
/*for(i=0;i<max+1;i++)
	{
		Xbar+=ara->val_signal.val_signal[i];
		//printf("\n X[%d]= %g",i,noeud->val_signal.val_signal[i]);
		}
	Xbar/=(max+1);
	printf("\nXbar=%g",Xbar);
	
	 Xbar2= Xbar* Xbar;
	for(i=0;i<max+1;i++)
		{
		fs+=(ara->val_signal.val_signal[i]*ara->val_signal.val_signal[i]);
		}
	fs/=(max+1);
	
fs2=fs-Xbar2;
		printf("\n(xi2/n-Xbar2)=( %g ) -( %g )= ( %g ) ara souti",fs,Xbar2,Sous(fs,Xbar*Xbar));
	fs-=(Xbar*Xbar);// fs=somme(xi*xi/n)- (xbar*xbar) //variance;
	
	
		printf("\nMy first stabilite %g",fs);
	if(fs<0)fs*=-1;
	ara->stabilite.SDN=fs;
	
	
	
	//if((ara->val_signal.nbr_msg_recevu)==40 || (ara->val_signal.nbr_msg_recevu)==80){
		
		if(ara->nbr_addr==0)
			{

	printf("\nN		Valeur   From %d Message(s)",max);	
	for(i=0;i<max;i++)
	{
	printf("\n%d        %g",i,ara->val_signal.val_signal[i]);
	}
}
	
	printf("\nMy stabilite %g",fs);
	printf("\nMy Second stabilite %g",ara->stabilite.SDN);
				//olsr_rte_neighbor_set_print_to_string();

		
	FOUT;
	}


	/*
	double Codeur(double a,double b)
	{

		int a1=0,a2=0;
		double  b1=0,Gamma=0.0;
		int b2=0;
		
	FIN (Codeur(double,double));

		printf("\nCodeur:.........Partie:1#");

	while(a<1 && a>0)
		{
			a2++;
			a*=10;

		}
	printf("\nCodeur:.........Partie:2#");
		a1=a;
  //	printf("\n\n(%d)e-(%d)",a1,a2);


	

	while(b<1 && b>0)
		{
			b2++;
			b*=10;

		}
			printf("\nCodeur:.........Partie:3#");
		b1=b;

	// printf("\n\n(%g)e-(%d)",b1,b2);
	  Gamma=(a1*100+a2*10+b1)/pow(10,b2);
	  //printf("\n\nThe final =%g",Gamma);
					printf("\nCodeur:.........Partie:Fin#");


	FRET(Gamma);
		}

void Decodeur (double Gamma,double* power,double* fs)
  {
	double	a,b1;
		int 	a1,a2=0,b2=0;

	FIN (Decodeur (double ,double* ,double* ));

	//	printf("\nDecodeur#");
		a=Gamma;//printf("\na=  %g",a);

		a/=100;
	
			printf("\nDecodeur:.........Partie:1#");
		while(a<1 && a>0)
		{
			b2++;
			a*=10;

		}
			printf("\nDecodeur:.........Partie:2#");
		a1=a;
		a2=((a2=(a*100))%100)/10;
		b1=(((a*100))-((a1*100)+a2*10));

	//	printf("\na= %g\na1=  %d\na2=  %d\nb1= %g\nb2= %d",a,a1,a2,b1,b2);


		*power=a1/pow(10,a2);
		*fs=b1/pow(10,b2);
						printf("\nDecodeur:.........Partie:Fin#");
	//	printf("\nAna nabeel signal=%g",*power);
//		printf("\nAna nabeel FS=%g",*fs);
		
		FOUT;


  }

*/

double Codeur(double a,double b)
	{

		int a1=0,a2=0;
		double  b1=0,Gamma=0.0;
		int b2=0;

		FIN (Codeur(double,double));

	while(a<1 && a>0)
		{
			a2++;
			a*=10;

		}
		a1=a*10;	


	while(b<1 && b>0)
		{
			b2++;
			b*=10;

		}
		b1=b;


	  Gamma=(a1*100+a2*10+b1)/pow(10,b2);
	


	FRET (Gamma);
		}



  void Decodeur (double Gamma,double *power,double *fs)
  {
	double	a,a1,b1=133.33;

	  long	int 	a2=0,b2=0,a1x=0;

 	FIN (Decodeur (double ,double* ,double* ));
		a=Gamma;

		
		if(Gamma>1)
		{

			a1x=((a1x=a)%10000);
			a1x/=100;
			a1=(a1=a1x)/10;

			a1x=((a1x=a)%100);
			a1x/=10;

		//	printf("\n\nRaha thadet Fs=0 wa a =%g   a1=%g",a,a1);
		//	printf("\nExp:%d",a1x);
			*power=a1/pow(10,a1x);
			*fs=0;

		//	printf("\n\n\nFinal Problem power %g   and Fs= %f",&power,&fs);
		}
		else
		{
		a/=100;
		while(a<1 && a>0)
		{
			b2++;
			a*=10;

		}
		b2++;


		a1x=((a1x=a*10000)%100);
		b1=(b1=a1x)/10;

		a1x=((a1x=a*10)%100);
		a1=(a1=a1x)/10;



		a2=((a2=(a*100))%100);
	 
	

		*power=a1/pow(10,a2);
		*fs=b1/pow(10,b2);
		}
		FOUT;


  }
  
  double get_sdn_fs(double sdn,int type)
	 { double power,fs;
	  	
	 FIN ( get_sdn_fs(double ,int ));
	Decodeur(sdn,&power,&fs);
	 
	 if (type==1)
		{ FRET (power);}
	 else	
		{ FRET (fs);}
		
	 }
  
  
  /*******************************************************************************/
  
  /*****update energy    c'est pour metrre a jour le niveau d'energie d'un noued *******/
  
  static int update_energy()
	  {

	FIN(update_energy());
		  
		    
	 
	  
	 
	  intial_energy = intial_energy - 1;
	  
	  FRET (intial_energy);
	  
	  }
   
  
    /*****update energy    c'est pour recupirer le niveau d'energie d'un noued *******/

  static int get_energy()
	  {
	   int current_energy;
	FIN(get_energy());
		  
		    
	 
	  
	  current_energy = intial_energy;
	  
	  FRET (current_energy);
	  
	  }
   static int test_energy(int e)
	  {
	     int alpha ;
	  
	FIN( test_energy() );
	  
		  
	   if(e > 70000 ) { /*60000*/
	   alpha = 1  ;
	   }
	   else if(e > 20000 ){ /*20000*/
	   alpha = 0.5  ;
	   }
	   else if (e < 1500){ /*100*/
	   alpha = 0.1 ;
		    
	   }
	  
	  FRET (alpha);
	  
	  }
  
  /*******************************************************************************/
  
   /*static int update_energy()
	  {
	   int resu_energy;
	FIN(update_energy());
		  
		    
	 
	  
	  resu_energy = intial_energy;
	  resu_energy = resu_energy - 1;
	  
	  FRET (resu_energy);
	  
	  }
  */
	  

